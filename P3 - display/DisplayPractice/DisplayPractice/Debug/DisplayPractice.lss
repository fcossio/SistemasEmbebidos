
DisplayPractice.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00003ba0  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  80005c00  80005c00  00006000  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000006ac  80005e00  80005e00  00006200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .lalign       00000004  800064ac  800064ac  000068ac  2**0
                  ALLOC
  6 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  7 .data         00000118  00000008  800064b0  00006c08  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .bss          00000100  00000120  00000120  00000000  2**2
                  ALLOC
  9 .heap         0000ede0  00000220  00000220  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  00006d20  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00000810  00000000  00000000  00006d50  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 00001056  00000000  00000000  00007560  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   0000ba3b  00000000  00000000  000085b6  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 00002829  00000000  00000000  00013ff1  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000785c  00000000  00000000  0001681a  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00001270  00000000  00000000  0001e078  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00002c5b  00000000  00000000  0001f2e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    00004c5f  00000000  00000000  00021f43  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_macinfo 0076f987  00000000  00000000  00026ba2  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 21 .debug_ranges 00000b18  00000000  00000000  00796530  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf d2 60 	sub	pc,pc,-11680

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf f2 64 	sub	pc,pc,-3484

Disassembly of section .text:

80002008 <et024006_SetLimits>:
80002008:	eb cd 40 80 	pushm	r7,lr

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000200c:	fc 1e c0 00 	movh	lr,0xc000
80002010:	30 28       	mov	r8,2
80002012:	bc 08       	st.h	lr[0x0],r8
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002014:	ef dc c1 08 	bfextu	r7,r12,0x8,0x8
80002018:	fc 18 c0 20 	movh	r8,0xc020
8000201c:	b0 07       	st.h	r8[0x0],r7

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000201e:	30 37       	mov	r7,3
80002020:	bc 07       	st.h	lr[0x0],r7
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002022:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002024:	30 4c       	mov	r12,4
80002026:	bc 0c       	st.h	lr[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002028:	f9 da c1 08 	bfextu	r12,r10,0x8,0x8
8000202c:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000202e:	30 5c       	mov	r12,5
80002030:	bc 0c       	st.h	lr[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002032:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002034:	30 6a       	mov	r10,6
80002036:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002038:	f5 db c1 08 	bfextu	r10,r11,0x8,0x8
8000203c:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000203e:	30 7a       	mov	r10,7
80002040:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002042:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002044:	30 8a       	mov	r10,8
80002046:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002048:	f5 d9 c1 08 	bfextu	r10,r9,0x8,0x8
8000204c:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000204e:	30 9a       	mov	r10,9
80002050:	bc 0a       	st.h	lr[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002052:	b0 09       	st.h	r8[0x0],r9
  et024006_WriteRegister( HIMAX_COL_ADDR_END1, (x2 & 0xff) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START2, (y1 >> 8) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START1, (y1 & 0xff) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_END2, (y2 >> 8) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_END1, (y2 & 0xff) );
}
80002054:	e3 cd 80 80 	ldm	sp++,r7,pc

80002058 <et024006_DrawPixel>:
  return color;
}


void et024006_DrawPixel( uint16_t x, uint16_t y, et024006_color_t color )
{
80002058:	eb cd 40 80 	pushm	r7,lr
8000205c:	14 97       	mov	r7,r10
  // Sanity check on parameters.
  Assert( x < ET024006_WIDTH );
  Assert( y < ET024006_HEIGHT );

  // Set up draw area and write the two bytes of pixel data.
  et024006_SetLimits( x, y, x, y );
8000205e:	5c 7b       	castu.h	r11
80002060:	5c 7c       	castu.h	r12
80002062:	16 99       	mov	r9,r11
80002064:	18 9a       	mov	r10,r12
80002066:	f0 1f 00 06 	mcall	8000207c <et024006_DrawPixel+0x24>
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000206a:	32 29       	mov	r9,34
8000206c:	fc 18 c0 00 	movh	r8,0xc000
80002070:	b0 09       	st.h	r8[0x0],r9
  et024006_SendSPI( ET024006_ID | ET024006_BS0 | ET024006_RS );
  et024006_SendSPI( color & 0xff );
  et024006_SendSPI( color >> 8 );
  et024006_DeselectSPI();
#else
  *ET024006_PARAM_ADDR = color;
80002072:	fc 18 c0 20 	movh	r8,0xc020
80002076:	b0 07       	st.h	r8[0x0],r7
#endif
}
80002078:	e3 cd 80 80 	ldm	sp++,r7,pc
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	20 08       	sub	r8,0

80002080 <et024006_SetQuickLimits>:

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002080:	fc 19 c0 00 	movh	r9,0xc000
80002084:	30 28       	mov	r8,2
80002086:	b2 08       	st.h	r9[0x0],r8
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002088:	f5 dc c1 08 	bfextu	r10,r12,0x8,0x8
8000208c:	fc 18 c0 20 	movh	r8,0xc020
80002090:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002092:	30 3a       	mov	r10,3
80002094:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002096:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002098:	30 6a       	mov	r10,6
8000209a:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000209c:	f5 db c1 08 	bfextu	r10,r11,0x8,0x8
800020a0:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800020a2:	30 7a       	mov	r10,7
800020a4:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800020a6:	b0 0b       	st.h	r8[0x0],r11
{
  et024006_WriteRegister( HIMAX_COL_ADDR_START2, (x >> 8) );
  et024006_WriteRegister( HIMAX_COL_ADDR_START1, (x & 0xff) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START2, (y >> 8) );
  et024006_WriteRegister( HIMAX_ROW_ADDR_START1, (y & 0xff) );
}
800020a8:	5e fc       	retal	r12
800020aa:	d7 03       	nop

800020ac <et024006_DrawQuickPixel>:
  et024006_WriteRegister( HIMAX_ROW_ADDR_END1, (y & 0xff) );
}


void et024006_DrawQuickPixel( uint16_t x, uint16_t y, et024006_color_t color )
{
800020ac:	eb cd 40 80 	pushm	r7,lr
800020b0:	14 97       	mov	r7,r10
  // Sanity check on parameters.
  Assert( x < ET024006_WIDTH );
  Assert( y < ET024006_HEIGHT );

  // Set up draw area and write the two bytes of pixel data.
  et024006_SetQuickLimits( x, y );
800020b2:	5c 7b       	castu.h	r11
800020b4:	5c 7c       	castu.h	r12
800020b6:	f0 1f 00 06 	mcall	800020cc <et024006_DrawQuickPixel+0x20>
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800020ba:	32 29       	mov	r9,34
800020bc:	fc 18 c0 00 	movh	r8,0xc000
800020c0:	b0 09       	st.h	r8[0x0],r9
  et024006_SendSPI( color & 0xff );
  et024006_SendSPI( color >> 8 );
  et024006_DeselectSPI();
#endif
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  *ET024006_PARAM_ADDR = color;
800020c2:	fc 18 c0 20 	movh	r8,0xc020
800020c6:	b0 07       	st.h	r8[0x0],r7
#endif

}
800020c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	20 80       	sub	r0,8

800020d0 <et024006_PrintString>:
void et024006_PrintString(char *lcd_string, const unsigned char *font_style,
                          uint16_t x,
                          uint16_t y,
                          uint16_t fcolor,
                          int bcolor)
{
800020d0:	d4 31       	pushm	r0-r7,lr
800020d2:	20 dd       	sub	sp,52
800020d4:	18 97       	mov	r7,r12
800020d6:	50 6b       	stdsp	sp[0x18],r11
800020d8:	50 8a       	stdsp	sp[0x20],r10
800020da:	50 29       	stdsp	sp[0x8],r9
800020dc:	10 94       	mov	r4,r8
800020de:	41 63       	lddsp	r3,sp[0x58]
  unsigned char mask = 0, xfont, yfont, font_size;
  const unsigned char *data;
  uint16_t saved_x = x;

  // if string is empty there is nothing to do
  if( *lcd_string == '\0')
800020e0:	19 89       	ld.ub	r9,r12[0x0]
800020e2:	30 08       	mov	r8,0
800020e4:	f0 09 18 00 	cp.b	r9,r8
800020e8:	e0 80 01 0c 	breq	80002300 <et024006_PrintString+0x230>
    return;

  data = font_style;  // point to the start of the font table
  xfont = *data;  // get font x width
800020ec:	16 98       	mov	r8,r11
800020ee:	11 3a       	ld.ub	r10,r8++
800020f0:	50 4a       	stdsp	sp[0x10],r10
  data++;
  yfont = *data;  // get font y length
800020f2:	11 89       	ld.ub	r9,r8[0x0]
800020f4:	50 39       	stdsp	sp[0xc],r9
  data++;
  font_size = *data;  // get data bytes per font
800020f6:	11 98       	ld.ub	r8,r8[0x1]
800020f8:	50 58       	stdsp	sp[0x14],r8

  // If transparent mode
  if(bcolor == -1)
800020fa:	5b f3       	cp.w	r3,-1
800020fc:	e0 81 00 8d 	brne	80002216 <et024006_PrintString+0x146>
  {
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );
80002100:	e0 69 00 ef 	mov	r9,239
80002104:	e0 6a 01 3f 	mov	r10,319
80002108:	30 0b       	mov	r11,0
8000210a:	16 9c       	mov	r12,r11
8000210c:	f0 1f 00 7e 	mcall	80002304 <et024006_PrintString+0x234>
        data =  (font_style + font_size) +  // header offset
          (font_size * (int)(*lcd_string - 32)); // character select
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;
80002110:	40 58       	lddsp	r8,sp[0x14]
80002112:	50 c8       	stdsp	sp[0x30],r8
80002114:	f0 08 00 18 	add	r8,r8,r8<<0x1
80002118:	a5 78       	lsl	r8,0x5
8000211a:	40 69       	lddsp	r9,sp[0x18]
8000211c:	10 09       	add	r9,r8
8000211e:	50 b9       	stdsp	sp[0x2c],r9
80002120:	ee c8 ff ff 	sub	r8,r7,-1
80002124:	50 98       	stdsp	sp[0x24],r8
80002126:	40 8a       	lddsp	r10,sp[0x20]
80002128:	5c 8a       	casts.h	r10
8000212a:	50 aa       	stdsp	sp[0x28],r10
      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
        {
          if (*data & mask) // if pixel data then put dot
8000212c:	30 03       	mov	r3,0
          {
            et024006_DrawQuickPixel( col, row, fcolor );
8000212e:	08 90       	mov	r0,r4
80002130:	5c 70       	castu.h	r0
    // set window to display size
    et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );

    do
    {
      if(*lcd_string =='\n') {
80002132:	40 99       	lddsp	r9,sp[0x24]
80002134:	f3 38 ff ff 	ld.ub	r8,r9[-1]
80002138:	30 aa       	mov	r10,10
8000213a:	f4 08 18 00 	cp.b	r8,r10
8000213e:	c0 b1       	brne	80002154 <et024006_PrintString+0x84>
        x = saved_x;
        y += yfont;
80002140:	40 28       	lddsp	r8,sp[0x8]
80002142:	40 39       	lddsp	r9,sp[0xc]
80002144:	12 08       	add	r8,r9
80002146:	5c 88       	casts.h	r8
80002148:	50 28       	stdsp	sp[0x8],r8
8000214a:	40 98       	lddsp	r8,sp[0x24]
8000214c:	40 8a       	lddsp	r10,sp[0x20]
8000214e:	5c 8a       	casts.h	r10
80002150:	50 aa       	stdsp	sp[0x28],r10
        lcd_string++;  // next character in string
        continue;
80002152:	c5 a8       	rjmp	80002206 <et024006_PrintString+0x136>
      } else if(*lcd_string =='\t') {
80002154:	30 99       	mov	r9,9
80002156:	f2 08 18 00 	cp.b	r8,r9
8000215a:	c0 81       	brne	8000216a <et024006_PrintString+0x9a>
        x += xfont;
8000215c:	40 a8       	lddsp	r8,sp[0x28]
8000215e:	40 49       	lddsp	r9,sp[0x10]
80002160:	12 08       	add	r8,r9
80002162:	5c 88       	casts.h	r8
80002164:	50 a8       	stdsp	sp[0x28],r8
80002166:	40 98       	lddsp	r8,sp[0x24]
        lcd_string++;  // next character in string
        continue;
80002168:	c4 f8       	rjmp	80002206 <et024006_PrintString+0x136>
      }
      // Checks if the character can be printed
      if (*lcd_string >= 32 && *lcd_string < (32 + 96))
8000216a:	f0 ca 00 20 	sub	r10,r8,32
8000216e:	35 f9       	mov	r9,95
80002170:	f2 0a 18 00 	cp.b	r10,r9
80002174:	e0 88 00 04 	brls	8000217c <et024006_PrintString+0xac>
80002178:	40 b5       	lddsp	r5,sp[0x2c]
8000217a:	c0 a8       	rjmp	8000218e <et024006_PrintString+0xbe>
      {
        // point to character data in font table
        data =  (font_style + font_size) +  // header offset
8000217c:	22 08       	sub	r8,32
8000217e:	40 ca       	lddsp	r10,sp[0x30]
80002180:	f0 0a 02 45 	mul	r5,r8,r10
80002184:	40 59       	lddsp	r9,sp[0x14]
80002186:	12 05       	add	r5,r9
80002188:	40 68       	lddsp	r8,sp[0x18]
8000218a:	f0 05 00 05 	add	r5,r8,r5
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
8000218e:	40 22       	lddsp	r2,sp[0x8]
80002190:	5c 72       	castu.h	r2
80002192:	40 3a       	lddsp	r10,sp[0xc]
80002194:	e4 0a 00 0a 	add	r10,r2,r10
80002198:	50 1a       	stdsp	sp[0x4],r10
8000219a:	04 3a       	cp.w	r10,r2
8000219c:	e0 8a 00 2f 	brle	800021fa <et024006_PrintString+0x12a>
800021a0:	40 21       	lddsp	r1,sp[0x8]
800021a2:	5c 81       	casts.h	r1
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
800021a4:	40 a9       	lddsp	r9,sp[0x28]
800021a6:	5c 79       	castu.h	r9
800021a8:	50 09       	stdsp	sp[0x0],r9
800021aa:	12 94       	mov	r4,r9
800021ac:	40 48       	lddsp	r8,sp[0x10]
800021ae:	10 04       	add	r4,r8
800021b0:	40 aa       	lddsp	r10,sp[0x28]
800021b2:	5c 8a       	casts.h	r10
800021b4:	50 7a       	stdsp	sp[0x1c],r10
800021b6:	c1 b8       	rjmp	800021ec <et024006_PrintString+0x11c>
        {
          if (*data & mask) // if pixel data then put dot
          {
            et024006_DrawQuickPixel( col, row, fcolor );
          }
          mask >>= 1;
800021b8:	a1 96       	lsr	r6,0x1
      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
        {
          if (*data & mask) // if pixel data then put dot
800021ba:	0b 88       	ld.ub	r8,r5[0x0]
800021bc:	ed e8 00 08 	and	r8,r6,r8
800021c0:	e6 08 18 00 	cp.b	r8,r3
800021c4:	c0 50       	breq	800021ce <et024006_PrintString+0xfe>
          {
            et024006_DrawQuickPixel( col, row, fcolor );
800021c6:	00 9a       	mov	r10,r0
800021c8:	04 9b       	mov	r11,r2
800021ca:	f0 1f 00 50 	mcall	80002308 <et024006_PrintString+0x238>
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
800021ce:	2f f7       	sub	r7,-1
800021d0:	5c 87       	casts.h	r7
800021d2:	0e 9c       	mov	r12,r7
800021d4:	5c 7c       	castu.h	r12
800021d6:	08 3c       	cp.w	r12,r4
800021d8:	cf 05       	brlt	800021b8 <et024006_PrintString+0xe8>
      }
      // Print default character
      else
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
800021da:	2f f1       	sub	r1,-1
800021dc:	5c 81       	casts.h	r1
800021de:	e5 d1 c0 10 	bfextu	r2,r1,0x0,0x10
800021e2:	40 19       	lddsp	r9,sp[0x4]
800021e4:	04 39       	cp.w	r9,r2
800021e6:	e0 8a 00 0a 	brle	800021fa <et024006_PrintString+0x12a>
            et024006_DrawQuickPixel( col, row, fcolor );
          }
          mask >>= 1;
        }
        // Next row data
        data++;
800021ea:	2f f5       	sub	r5,-1
        data =  (font_style + font_size) + font_size * 95;

      for (row = y; row < (y + yfont); row++)
      {
        mask = 0x80;
        for (col = x; col < (x + xfont); col++)
800021ec:	40 0c       	lddsp	r12,sp[0x0]
800021ee:	08 3c       	cp.w	r12,r4
800021f0:	cf 54       	brge	800021da <et024006_PrintString+0x10a>
800021f2:	40 77       	lddsp	r7,sp[0x1c]
800021f4:	e0 66 00 80 	mov	r6,128
800021f8:	ce 1b       	rjmp	800021ba <et024006_PrintString+0xea>
        }
        // Next row data
        data++;
      }
      // move to next character start pixel
      x += xfont;
800021fa:	40 a8       	lddsp	r8,sp[0x28]
800021fc:	40 4a       	lddsp	r10,sp[0x10]
800021fe:	14 08       	add	r8,r10
80002200:	5c 88       	casts.h	r8
80002202:	50 a8       	stdsp	sp[0x28],r8
80002204:	40 98       	lddsp	r8,sp[0x24]
80002206:	40 99       	lddsp	r9,sp[0x24]
80002208:	2f f9       	sub	r9,-1
8000220a:	50 99       	stdsp	sp[0x24],r9
      lcd_string++;  // next character in string

    }while(*lcd_string !='\0');  // keep spitting chars out until end of string
8000220c:	11 88       	ld.ub	r8,r8[0x0]
8000220e:	e6 08 18 00 	cp.b	r8,r3
80002212:	c9 01       	brne	80002132 <et024006_PrintString+0x62>
80002214:	c7 68       	rjmp	80002300 <et024006_PrintString+0x230>
80002216:	f8 c8 ff ff 	sub	r8,r12,-1
8000221a:	50 08       	stdsp	sp[0x0],r8
8000221c:	40 8c       	lddsp	r12,sp[0x20]
8000221e:	5c 8c       	casts.h	r12
      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
        {
          if (*data & mask) // if pixel data then put dot
80002220:	30 06       	mov	r6,0
          {
            *ET024006_PARAM_ADDR = fcolor;
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
80002222:	5c 83       	casts.h	r3
80002224:	fc 15 c0 20 	movh	r5,0xc020
  }
  else
  {
    do
    {
      if(*lcd_string =='\n') {
80002228:	40 0a       	lddsp	r10,sp[0x0]
8000222a:	f5 31 ff ff 	ld.ub	r1,r10[-1]
8000222e:	30 a8       	mov	r8,10
80002230:	f0 01 18 00 	cp.b	r1,r8
80002234:	c0 b1       	brne	8000224a <et024006_PrintString+0x17a>
        x = saved_x;
        y += yfont;
80002236:	40 28       	lddsp	r8,sp[0x8]
80002238:	40 39       	lddsp	r9,sp[0xc]
8000223a:	12 08       	add	r8,r9
8000223c:	5c 88       	casts.h	r8
8000223e:	50 28       	stdsp	sp[0x8],r8
80002240:	14 98       	mov	r8,r10
80002242:	40 8a       	lddsp	r10,sp[0x20]
80002244:	5c 8a       	casts.h	r10
80002246:	50 1a       	stdsp	sp[0x4],r10
        lcd_string++;  // next character in string
        continue;
80002248:	c5 28       	rjmp	800022ec <et024006_PrintString+0x21c>
      } else if(*lcd_string =='\t') {
8000224a:	30 98       	mov	r8,9
8000224c:	f0 01 18 00 	cp.b	r1,r8
80002250:	c0 71       	brne	8000225e <et024006_PrintString+0x18e>
        x += xfont;
80002252:	40 49       	lddsp	r9,sp[0x10]
80002254:	12 0c       	add	r12,r9
80002256:	5c 8c       	casts.h	r12
80002258:	50 1c       	stdsp	sp[0x4],r12
8000225a:	40 08       	lddsp	r8,sp[0x0]
        lcd_string++;  // next character in string
        continue;
8000225c:	c4 88       	rjmp	800022ec <et024006_PrintString+0x21c>
      // point to character data in font table
      data =  (font_style + font_size) +  // header offset
        (font_size * (int)(*lcd_string - 32)); // character select

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
8000225e:	40 32       	lddsp	r2,sp[0xc]
80002260:	40 47       	lddsp	r7,sp[0x10]
80002262:	f8 07 00 08 	add	r8,r12,r7
80002266:	5c 88       	casts.h	r8
80002268:	50 18       	stdsp	sp[0x4],r8
8000226a:	04 99       	mov	r9,r2
8000226c:	20 19       	sub	r9,1
8000226e:	40 28       	lddsp	r8,sp[0x8]
80002270:	10 09       	add	r9,r8
80002272:	40 1a       	lddsp	r10,sp[0x4]
80002274:	20 1a       	sub	r10,1
80002276:	5c 79       	castu.h	r9
80002278:	5c 7a       	castu.h	r10
8000227a:	10 9b       	mov	r11,r8
8000227c:	5c 7b       	castu.h	r11
8000227e:	5c 7c       	castu.h	r12
80002280:	f0 1f 00 21 	mcall	80002304 <et024006_PrintString+0x234>
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002284:	32 29       	mov	r9,34
80002286:	fc 18 c0 00 	movh	r8,0xc000
8000228a:	b0 09       	st.h	r8[0x0],r9

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
8000228c:	40 3a       	lddsp	r10,sp[0xc]
8000228e:	58 0a       	cp.w	r10,0
80002290:	c2 d0       	breq	800022ea <et024006_PrintString+0x21a>
        x += xfont;
        lcd_string++;  // next character in string
        continue;
      }
      // point to character data in font table
      data =  (font_style + font_size) +  // header offset
80002292:	e2 ce 00 20 	sub	lr,r1,32
80002296:	40 59       	lddsp	r9,sp[0x14]
80002298:	f2 0e 02 4e 	mul	lr,r9,lr
8000229c:	12 0e       	add	lr,r9
8000229e:	40 68       	lddsp	r8,sp[0x18]
800022a0:	f0 0e 00 0e 	add	lr,r8,lr
800022a4:	30 0c       	mov	r12,0
      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
        {
          if (*data & mask) // if pixel data then put dot
800022a6:	e0 60 00 80 	mov	r0,128
800022aa:	18 91       	mov	r1,r12
800022ac:	c1 98       	rjmp	800022de <et024006_PrintString+0x20e>
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
          }
          mask >>= 1;
800022ae:	a1 99       	lsr	r9,0x1
      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
        {
          if (*data & mask) // if pixel data then put dot
800022b0:	f3 eb 00 0a 	and	r10,r9,r11
          {
            *ET024006_PARAM_ADDR = fcolor;
800022b4:	ec 0a 18 00 	cp.b	r10,r6
800022b8:	e8 0a 17 10 	movne	r10,r4
800022bc:	eb fa 1c 00 	st.hne	r5[0x0],r10
          }
          else  // else use background color
          {
            *ET024006_PARAM_ADDR = bcolor;
800022c0:	eb f3 0c 00 	st.heq	r5[0x0],r3
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
800022c4:	2f f8       	sub	r8,-1
800022c6:	5c 88       	casts.h	r8
800022c8:	f0 07 19 00 	cp.h	r7,r8
800022cc:	fe 9b ff f1 	brhi	800022ae <et024006_PrintString+0x1de>

      // set a window for the character
      et024006_SetLimits( x, y, x + xfont - 1, y + yfont - 1 );
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
800022d0:	2f fc       	sub	r12,-1
800022d2:	5c 8c       	casts.h	r12
800022d4:	f8 02 19 00 	cp.h	r2,r12
800022d8:	e0 88 00 09 	brls	800022ea <et024006_PrintString+0x21a>
          }
          mask >>= 1;
        }

        // Next row data
        data++;
800022dc:	2f fe       	sub	lr,-1
      et024006_SelectRegister( HIMAX_SRAMWRITE );

      for (row=0; row < yfont;row++)
      {
        mask = 0x80;
        for (col = 0; col < xfont; col++)
800022de:	58 07       	cp.w	r7,0
800022e0:	cf 80       	breq	800022d0 <et024006_PrintString+0x200>
        {
          if (*data & mask) // if pixel data then put dot
800022e2:	1d 8b       	ld.ub	r11,lr[0x0]
800022e4:	00 99       	mov	r9,r0
800022e6:	02 98       	mov	r8,r1
800022e8:	ce 4b       	rjmp	800022b0 <et024006_PrintString+0x1e0>
800022ea:	40 08       	lddsp	r8,sp[0x0]
800022ec:	40 09       	lddsp	r9,sp[0x0]
800022ee:	2f f9       	sub	r9,-1
800022f0:	50 09       	stdsp	sp[0x0],r9
      }
      // move to next character start pixel
      x += xfont;
      lcd_string++;  // next character in string

    }while(*lcd_string !='\0');  // keep spitting chars out until end of string
800022f2:	11 88       	ld.ub	r8,r8[0x0]
800022f4:	ec 08 18 00 	cp.b	r8,r6
800022f8:	c0 40       	breq	80002300 <et024006_PrintString+0x230>
800022fa:	40 1c       	lddsp	r12,sp[0x4]
800022fc:	5c 8c       	casts.h	r12
800022fe:	c9 5b       	rjmp	80002228 <et024006_PrintString+0x158>
  }
}
80002300:	2f 3d       	sub	sp,-52
80002302:	d8 32       	popm	r0-r7,pc
80002304:	80 00       	ld.sh	r0,r0[0x0]
80002306:	20 08       	sub	r8,0
80002308:	80 00       	ld.sh	r0,r0[0x0]
8000230a:	20 ac       	sub	r12,10

8000230c <et024006_DrawLine>:
  et024006_DrawFilledRect( x, y, 1, length, color );
}


void et024006_DrawLine( uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, et024006_color_t color )
{
8000230c:	d4 31       	pushm	r0-r7,lr
8000230e:	20 3d       	sub	sp,12
80002310:	18 95       	mov	r5,r12
80002312:	16 94       	mov	r4,r11
80002314:	14 93       	mov	r3,r10
80002316:	12 92       	mov	r2,r9
80002318:	10 91       	mov	r1,r8
  et024006_SetLimits( 0, 0, ET024006_WIDTH - 1, ET024006_HEIGHT - 1 );
8000231a:	e0 69 00 ef 	mov	r9,239
8000231e:	e0 6a 01 3f 	mov	r10,319
80002322:	30 0b       	mov	r11,0
80002324:	16 9c       	mov	r12,r11
80002326:	f0 1f 00 3e 	mcall	8000241c <et024006_DrawLine+0x110>
  Assert( y2 < ET024006_HEIGHT );

  // Compute deltas, ie. "width" and "height" of line, then
  // compute x and y direction, and make deltas positive for later use.
  int16_t xinc = 1; // Start off assuming direction is positive, ie. right.
  int16_t dx = x2 - x1;
8000232a:	0a 13       	sub	r3,r5
8000232c:	5c 83       	casts.h	r3
  if (dx < 0){
8000232e:	30 08       	mov	r8,0
80002330:	f0 03 19 00 	cp.h	r3,r8
80002334:	c0 35       	brlt	8000233a <et024006_DrawLine+0x2e>
80002336:	30 10       	mov	r0,1
80002338:	c0 48       	rjmp	80002340 <et024006_DrawLine+0x34>
    xinc = -1;
    dx = -dx;
8000233a:	5c 33       	neg	r3
8000233c:	5c 83       	casts.h	r3
8000233e:	3f f0       	mov	r0,-1
  }
  int16_t yinc = 1; // Start off assuming direction is positive, ie. down.
  int16_t dy = y2 - y1;
80002340:	08 12       	sub	r2,r4
80002342:	5c 82       	casts.h	r2
  if (dy < 0){
80002344:	30 08       	mov	r8,0
80002346:	f0 02 19 00 	cp.h	r2,r8
8000234a:	c0 45       	brlt	80002352 <et024006_DrawLine+0x46>
8000234c:	30 18       	mov	r8,1
8000234e:	50 18       	stdsp	sp[0x4],r8
80002350:	c0 58       	rjmp	8000235a <et024006_DrawLine+0x4e>
    yinc = -1;
    dy = -dy;
80002352:	5c 32       	neg	r2
80002354:	5c 82       	casts.h	r2
80002356:	3f f9       	mov	r9,-1
80002358:	50 19       	stdsp	sp[0x4],r9
  // Set up current point.
  uint16_t x = x1;
  uint16_t y = y1;
  uint16_t i;
  // A "flat" line (dx>dy) is handled differently from a "steep" line (dx<dy).
  if (dx > dy) {
8000235a:	e4 03 19 00 	cp.h	r3,r2
8000235e:	e0 8a 00 2e 	brle	800023ba <et024006_DrawLine+0xae>
    // Walk along X, draw pixel, and step Y when required.
    int16_t e = dx >> 1;
    for ( i = 0; i <= dx; ++i) {
80002362:	50 03       	stdsp	sp[0x0],r3
80002364:	58 03       	cp.w	r3,0
80002366:	c5 85       	brlt	80002416 <et024006_DrawLine+0x10a>
  uint16_t y = y1;
  uint16_t i;
  // A "flat" line (dx>dy) is handled differently from a "steep" line (dx<dy).
  if (dx > dy) {
    // Walk along X, draw pixel, and step Y when required.
    int16_t e = dx >> 1;
80002368:	e6 07 14 01 	asr	r7,r3,0x1
8000236c:	5c 84       	casts.h	r4
8000236e:	5c 85       	casts.h	r5
80002370:	30 06       	mov	r6,0
    for ( i = 0; i <= dx; ++i) {
      et024006_DrawQuickPixel(x,y,color);
80002372:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
      // Sub-pixel "error" overflowed, so we step Y and reset the "error".
      if (e <= 0){
80002376:	30 01       	mov	r1,0
80002378:	50 23       	stdsp	sp[0x8],r3
8000237a:	1c 93       	mov	r3,lr
  // A "flat" line (dx>dy) is handled differently from a "steep" line (dx<dy).
  if (dx > dy) {
    // Walk along X, draw pixel, and step Y when required.
    int16_t e = dx >> 1;
    for ( i = 0; i <= dx; ++i) {
      et024006_DrawQuickPixel(x,y,color);
8000237c:	06 9a       	mov	r10,r3
8000237e:	08 9b       	mov	r11,r4
80002380:	5c 7b       	castu.h	r11
80002382:	f9 d5 c0 10 	bfextu	r12,r5,0x0,0x10
80002386:	f0 1f 00 27 	mcall	80002420 <et024006_DrawLine+0x114>
      // Sub-pixel "error" overflowed, so we step Y and reset the "error".
      if (e <= 0){
8000238a:	e2 07 19 00 	cp.h	r7,r1
8000238e:	e0 89 00 08 	brgt	8000239e <et024006_DrawLine+0x92>
        e += dx;
80002392:	40 29       	lddsp	r9,sp[0x8]
80002394:	12 07       	add	r7,r9
80002396:	5c 87       	casts.h	r7
        y += yinc;
80002398:	40 18       	lddsp	r8,sp[0x4]
8000239a:	10 04       	add	r4,r8
8000239c:	5c 84       	casts.h	r4
  uint16_t i;
  // A "flat" line (dx>dy) is handled differently from a "steep" line (dx<dy).
  if (dx > dy) {
    // Walk along X, draw pixel, and step Y when required.
    int16_t e = dx >> 1;
    for ( i = 0; i <= dx; ++i) {
8000239e:	2f f6       	sub	r6,-1
800023a0:	5c 86       	casts.h	r6
800023a2:	f1 d6 c0 10 	bfextu	r8,r6,0x0,0x10
800023a6:	40 09       	lddsp	r9,sp[0x0]
800023a8:	12 38       	cp.w	r8,r9
800023aa:	e0 89 00 36 	brgt	80002416 <et024006_DrawLine+0x10a>
      if (e <= 0){
        e += dx;
        y += yinc;
      }
      // Walk one step along X.
      e -= dy;
800023ae:	04 17       	sub	r7,r2
800023b0:	5c 87       	casts.h	r7
800023b2:	e0 05 00 05 	add	r5,r0,r5
800023b6:	5c 85       	casts.h	r5
800023b8:	ce 2b       	rjmp	8000237c <et024006_DrawLine+0x70>
      x += xinc;
    }
  } else {
    // Walk along Y, draw pixel, and step X when required.
    int16_t e = dy >> 1;
    for (i = 0; i <= dy; ++i) {
800023ba:	50 02       	stdsp	sp[0x0],r2
800023bc:	58 02       	cp.w	r2,0
800023be:	c2 c5       	brlt	80002416 <et024006_DrawLine+0x10a>
      e -= dy;
      x += xinc;
    }
  } else {
    // Walk along Y, draw pixel, and step X when required.
    int16_t e = dy >> 1;
800023c0:	e4 07 14 01 	asr	r7,r2,0x1
800023c4:	5c 84       	casts.h	r4
800023c6:	5c 85       	casts.h	r5
800023c8:	30 06       	mov	r6,0
    for (i = 0; i <= dy; ++i) {
      et024006_DrawQuickPixel(x,y,color);
800023ca:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
      // Sub-pixel "error" overflowed, so we step X and reset the "error".
      if (e <= 0){
800023ce:	30 01       	mov	r1,0
800023d0:	50 22       	stdsp	sp[0x8],r2
800023d2:	40 12       	lddsp	r2,sp[0x4]
800023d4:	50 10       	stdsp	sp[0x4],r0
800023d6:	1c 90       	mov	r0,lr
    }
  } else {
    // Walk along Y, draw pixel, and step X when required.
    int16_t e = dy >> 1;
    for (i = 0; i <= dy; ++i) {
      et024006_DrawQuickPixel(x,y,color);
800023d8:	00 9a       	mov	r10,r0
800023da:	08 9b       	mov	r11,r4
800023dc:	5c 7b       	castu.h	r11
800023de:	f9 d5 c0 10 	bfextu	r12,r5,0x0,0x10
800023e2:	f0 1f 00 10 	mcall	80002420 <et024006_DrawLine+0x114>
      // Sub-pixel "error" overflowed, so we step X and reset the "error".
      if (e <= 0){
800023e6:	e2 07 19 00 	cp.h	r7,r1
800023ea:	e0 89 00 08 	brgt	800023fa <et024006_DrawLine+0xee>
        e += dy;
800023ee:	40 29       	lddsp	r9,sp[0x8]
800023f0:	12 07       	add	r7,r9
800023f2:	5c 87       	casts.h	r7
        x += xinc;
800023f4:	40 18       	lddsp	r8,sp[0x4]
800023f6:	10 05       	add	r5,r8
800023f8:	5c 85       	casts.h	r5
      x += xinc;
    }
  } else {
    // Walk along Y, draw pixel, and step X when required.
    int16_t e = dy >> 1;
    for (i = 0; i <= dy; ++i) {
800023fa:	2f f6       	sub	r6,-1
800023fc:	5c 86       	casts.h	r6
800023fe:	f1 d6 c0 10 	bfextu	r8,r6,0x0,0x10
80002402:	40 09       	lddsp	r9,sp[0x0]
80002404:	12 38       	cp.w	r8,r9
80002406:	e0 89 00 08 	brgt	80002416 <et024006_DrawLine+0x10a>
      if (e <= 0){
        e += dy;
        x += xinc;
      }
      // Walk one step along Y.
      e -= dx;
8000240a:	06 17       	sub	r7,r3
8000240c:	5c 87       	casts.h	r7
8000240e:	e4 04 00 04 	add	r4,r2,r4
80002412:	5c 84       	casts.h	r4
80002414:	ce 2b       	rjmp	800023d8 <et024006_DrawLine+0xcc>
      y += yinc;
    }
  }
}
80002416:	2f dd       	sub	sp,-12
80002418:	d8 32       	popm	r0-r7,pc
8000241a:	00 00       	add	r0,r0
8000241c:	80 00       	ld.sh	r0,r0[0x0]
8000241e:	20 08       	sub	r8,0
80002420:	80 00       	ld.sh	r0,r0[0x0]
80002422:	20 ac       	sub	r12,10

80002424 <et024006_DuplicatePixel>:
  return *ET024006_PARAM_ADDR;
}

__always_inline static void et024006_SelectRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002424:	32 29       	mov	r9,34
80002426:	fc 18 c0 00 	movh	r8,0xc000
8000242a:	b0 09       	st.h	r8[0x0],r9
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  //uint8_t countLowByte = count;
  while (count >= 8) {
8000242c:	58 7b       	cp.w	r11,7
8000242e:	e0 88 00 13 	brls	80002454 <et024006_DuplicatePixel+0x30>
80002432:	16 99       	mov	r9,r11
    *ET024006_PARAM_ADDR = color;
80002434:	fc 18 c0 20 	movh	r8,0xc020
80002438:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
8000243a:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
8000243c:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
8000243e:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
80002440:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
80002442:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
80002444:	b0 0c       	st.h	r8[0x0],r12
    *ET024006_PARAM_ADDR = color;
80002446:	b0 0c       	st.h	r8[0x0],r12
    count-=8;
80002448:	20 89       	sub	r9,8
  Assert( count > 0 );

  et024006_SelectRegister( HIMAX_SRAMWRITE );
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  //uint8_t countLowByte = count;
  while (count >= 8) {
8000244a:	58 79       	cp.w	r9,7
8000244c:	fe 9b ff f6 	brhi	80002438 <et024006_DuplicatePixel+0x14>



/* --- Pixel block operations --- */

void et024006_DuplicatePixel( et024006_color_t color, uint32_t count )
80002450:	f7 db c0 03 	bfextu	r11,r11,0x0,0x3
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    count-=8;
  }
  while (count > 0) {
80002454:	58 0b       	cp.w	r11,0
80002456:	5e 0c       	reteq	r12
    *ET024006_PARAM_ADDR = color;
80002458:	fc 18 c0 20 	movh	r8,0xc020
8000245c:	b0 0c       	st.h	r8[0x0],r12
    --count;
8000245e:	20 1b       	sub	r11,1
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    *ET024006_PARAM_ADDR = color;
    count-=8;
  }
  while (count > 0) {
80002460:	cf e1       	brne	8000245c <et024006_DuplicatePixel+0x38>
80002462:	5e fc       	retal	r12

80002464 <et024006_DrawFilledRect>:
  }
}


void et024006_DrawFilledRect( uint16_t x, uint16_t y, uint16_t width, uint16_t height, et024006_color_t color )
{
80002464:	eb cd 40 e0 	pushm	r5-r7,lr
80002468:	14 97       	mov	r7,r10
8000246a:	12 96       	mov	r6,r9
8000246c:	10 95       	mov	r5,r8
  // More sanity check.
  Assert( x2 < ET024006_WIDTH );
  Assert( y2 < ET024006_HEIGHT );

  // Set up draw area and copy pixel color until area is full.
  et024006_SetLimits( x, y, x2, y2 );
8000246e:	f6 c9 00 01 	sub	r9,r11,1
80002472:	0c 09       	add	r9,r6
80002474:	f8 ca 00 01 	sub	r10,r12,1
80002478:	0e 0a       	add	r10,r7
8000247a:	5c 79       	castu.h	r9
8000247c:	5c 7a       	castu.h	r10
8000247e:	5c 7b       	castu.h	r11
80002480:	5c 7c       	castu.h	r12
80002482:	f0 1f 00 07 	mcall	8000249c <et024006_DrawFilledRect+0x38>
  uint32_t count = (uint32_t) width * height;
  et024006_DuplicatePixel( color, count );
80002486:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
8000248a:	5c 77       	castu.h	r7
8000248c:	af 3b       	mul	r11,r7
8000248e:	f9 d5 c0 10 	bfextu	r12,r5,0x0,0x10
80002492:	f0 1f 00 04 	mcall	800024a0 <et024006_DrawFilledRect+0x3c>
}
80002496:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000249a:	00 00       	add	r0,r0
8000249c:	80 00       	ld.sh	r0,r0[0x0]
8000249e:	20 08       	sub	r8,0
800024a0:	80 00       	ld.sh	r0,r0[0x0]
800024a2:	24 24       	sub	r4,66

800024a4 <et024006_DrawVertLine>:
  et024006_DrawFilledRect( x, y, length, 1, color );
}


void et024006_DrawVertLine( uint16_t x, uint16_t y, uint16_t length, et024006_color_t color )
{
800024a4:	d4 01       	pushm	lr
  et024006_DrawFilledRect( x, y, 1, length, color );
800024a6:	f1 d9 c0 10 	bfextu	r8,r9,0x0,0x10
800024aa:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
800024ae:	30 1a       	mov	r10,1
800024b0:	5c 7b       	castu.h	r11
800024b2:	5c 7c       	castu.h	r12
800024b4:	f0 1f 00 02 	mcall	800024bc <et024006_DrawVertLine+0x18>
}
800024b8:	d8 02       	popm	pc
800024ba:	00 00       	add	r0,r0
800024bc:	80 00       	ld.sh	r0,r0[0x0]
800024be:	24 64       	sub	r4,70

800024c0 <et024006_DrawHorizLine>:
  return color;
}


void et024006_DrawHorizLine( uint16_t x, uint16_t y, uint16_t length, et024006_color_t color )
{
800024c0:	d4 01       	pushm	lr
  et024006_DrawFilledRect( x, y, length, 1, color );
800024c2:	f1 d9 c0 10 	bfextu	r8,r9,0x0,0x10
800024c6:	30 19       	mov	r9,1
800024c8:	5c 7a       	castu.h	r10
800024ca:	5c 7b       	castu.h	r11
800024cc:	5c 7c       	castu.h	r12
800024ce:	f0 1f 00 02 	mcall	800024d4 <et024006_DrawHorizLine+0x14>
}
800024d2:	d8 02       	popm	pc
800024d4:	80 00       	ld.sh	r0,r0[0x0]
800024d6:	24 64       	sub	r4,70

800024d8 <et024006_AdjustGamma>:

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800024d8:	fc 19 c0 00 	movh	r9,0xc000
800024dc:	34 6a       	mov	r10,70
800024de:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800024e0:	fc 18 c0 20 	movh	r8,0xc020
800024e4:	e0 6b 00 94 	mov	r11,148
800024e8:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800024ea:	34 7b       	mov	r11,71
800024ec:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800024ee:	34 1b       	mov	r11,65
800024f0:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800024f2:	34 8b       	mov	r11,72
800024f4:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800024f6:	30 0b       	mov	r11,0
800024f8:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800024fa:	34 9b       	mov	r11,73
800024fc:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
800024fe:	33 3b       	mov	r11,51
80002500:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002502:	34 ab       	mov	r11,74
80002504:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002506:	32 5b       	mov	r11,37
80002508:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000250a:	34 bb       	mov	r11,75
8000250c:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000250e:	34 5b       	mov	r11,69
80002510:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002512:	34 cb       	mov	r11,76
80002514:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002516:	34 4b       	mov	r11,68
80002518:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000251a:	34 db       	mov	r11,77
8000251c:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000251e:	37 7b       	mov	r11,119
80002520:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002522:	34 eb       	mov	r11,78
80002524:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002526:	31 2b       	mov	r11,18
80002528:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000252a:	34 fb       	mov	r11,79
8000252c:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000252e:	e0 6b 00 cc 	mov	r11,204
80002532:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002534:	35 0b       	mov	r11,80
80002536:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002538:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000253a:	35 1a       	mov	r10,81
8000253c:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000253e:	e0 69 00 82 	mov	r9,130
80002542:	b0 09       	st.h	r8[0x0],r9
  et024006_WriteRegister( HIMAX_GAMMACTRL8, 0x77 );
  et024006_WriteRegister( HIMAX_GAMMACTRL9, 0x12 );
  et024006_WriteRegister( HIMAX_GAMMACTRL10, 0xCC );
  et024006_WriteRegister( HIMAX_GAMMACTRL11, 0x46 );
  et024006_WriteRegister( HIMAX_GAMMACTRL12, 0x82 );
}
80002544:	5e fc       	retal	r12
80002546:	d7 03       	nop

80002548 <et024006_Init>:
 *  @param cpu_hz CPU speed in Hz. This is needed for power up timings.
 *  @param hsb_hz HSB bus speed in Hz. This parameter is needed to set up the SMC.
 *  If SPI mode is used then this parameter is ignored.
 */
void et024006_Init( unsigned long cpu_hz, unsigned long hsb_hz )
{
80002548:	eb cd 40 c0 	pushm	r6-r7,lr
  tft_data.cpu_hz = cpu_hz;
8000254c:	fe f7 04 80 	ld.w	r7,pc[1152]
80002550:	8f 0c       	st.w	r7[0x0],r12
  tft_data.hsb_hz = hsb_hz;
80002552:	8f 1b       	st.w	r7[0x4],r11

#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_SPI)
  et024006_InitSPI();
#endif
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  smc_init(tft_data.hsb_hz);
80002554:	16 9c       	mov	r12,r11
80002556:	f0 1f 01 1f 	mcall	800029d0 <et024006_Init+0x488>
static void et024006_SetupInterface( void )
{

  // et024006_TE (tearing sync) signal from display is input
  // without any pull resistors
  gpio_enable_gpio_pin(ET024006DHU_TE_PIN);
8000255a:	35 5c       	mov	r12,85
8000255c:	f0 1f 01 1e 	mcall	800029d4 <et024006_Init+0x48c>

  // Backlight pin (PWM) for display is output
  gpio_enable_module_pin(ET024006DHU_BL_PIN, ET024006DHU_BL_FUNCTION);
80002560:	30 2b       	mov	r11,2
80002562:	33 2c       	mov	r12,50
80002564:	f0 1f 01 1d 	mcall	800029d8 <et024006_Init+0x490>
  // Turns backlight ON
  /*TODO Add backlight driver */

  // Reset pin for display is output
  gpio_set_gpio_pin(ET024006DHU_RESET_PIN);
80002568:	35 2c       	mov	r12,82
8000256a:	f0 1f 01 1d 	mcall	800029dc <et024006_Init+0x494>
/*! \brief Does a hard reset of the display.
 */
static void et024006_ResetDisplay( void )
{
  // clear reset line
  gpio_clr_gpio_pin(ET024006DHU_RESET_PIN);
8000256e:	35 2c       	mov	r12,82
80002570:	f0 1f 01 1c 	mcall	800029e0 <et024006_Init+0x498>
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
80002574:	6e 07       	ld.w	r7,r7[0x0]
80002576:	33 28       	mov	r8,50
80002578:	ee 08 06 46 	mulu.d	r6,r7,r8
8000257c:	ee 78 42 40 	mov	r8,1000000
80002580:	30 09       	mov	r9,0
80002582:	ee 7a 42 3f 	mov	r10,999999
80002586:	30 0b       	mov	r11,0
80002588:	ec 0a 00 0a 	add	r10,r6,r10
8000258c:	ee 0b 00 4b 	adc	r11,r7,r11
80002590:	f0 1f 01 15 	mcall	800029e4 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002594:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002598:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000259c:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800025a0:	14 38       	cp.w	r8,r10
800025a2:	e0 88 00 09 	brls	800025b4 <et024006_Init+0x6c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800025a6:	12 38       	cp.w	r8,r9
800025a8:	fe 98 ff fa 	brls	8000259c <et024006_Init+0x54>
800025ac:	12 3a       	cp.w	r10,r9
800025ae:	e0 83 00 a2 	brlo	800026f2 <et024006_Init+0x1aa>
800025b2:	cf 5b       	rjmp	8000259c <et024006_Init+0x54>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800025b4:	12 38       	cp.w	r8,r9
800025b6:	e0 8b 00 9e 	brhi	800026f2 <et024006_Init+0x1aa>
800025ba:	12 3a       	cp.w	r10,r9
800025bc:	e0 83 00 9b 	brlo	800026f2 <et024006_Init+0x1aa>
800025c0:	ce eb       	rjmp	8000259c <et024006_Init+0x54>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800025c2:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800025c6:	14 38       	cp.w	r8,r10
800025c8:	e0 88 00 09 	brls	800025da <et024006_Init+0x92>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800025cc:	12 38       	cp.w	r8,r9
800025ce:	fe 98 ff fa 	brls	800025c2 <et024006_Init+0x7a>
800025d2:	12 3a       	cp.w	r10,r9
800025d4:	e0 83 00 a9 	brlo	80002726 <et024006_Init+0x1de>
800025d8:	cf 5b       	rjmp	800025c2 <et024006_Init+0x7a>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800025da:	12 38       	cp.w	r8,r9
800025dc:	e0 8b 00 a5 	brhi	80002726 <et024006_Init+0x1de>
800025e0:	12 3a       	cp.w	r10,r9
800025e2:	e0 83 00 a2 	brlo	80002726 <et024006_Init+0x1de>
800025e6:	ce eb       	rjmp	800025c2 <et024006_Init+0x7a>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800025e8:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800025ec:	14 38       	cp.w	r8,r10
800025ee:	e0 88 00 09 	brls	80002600 <et024006_Init+0xb8>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800025f2:	12 38       	cp.w	r8,r9
800025f4:	fe 98 ff fa 	brls	800025e8 <et024006_Init+0xa0>
800025f8:	12 3a       	cp.w	r10,r9
800025fa:	e0 83 01 1e 	brlo	80002836 <et024006_Init+0x2ee>
800025fe:	cf 5b       	rjmp	800025e8 <et024006_Init+0xa0>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002600:	12 38       	cp.w	r8,r9
80002602:	e0 8b 01 1a 	brhi	80002836 <et024006_Init+0x2ee>
80002606:	12 3a       	cp.w	r10,r9
80002608:	e0 83 01 17 	brlo	80002836 <et024006_Init+0x2ee>
8000260c:	ce eb       	rjmp	800025e8 <et024006_Init+0xa0>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000260e:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002612:	14 38       	cp.w	r8,r10
80002614:	e0 88 00 09 	brls	80002626 <et024006_Init+0xde>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002618:	12 38       	cp.w	r8,r9
8000261a:	fe 98 ff fa 	brls	8000260e <et024006_Init+0xc6>
8000261e:	12 3a       	cp.w	r10,r9
80002620:	e0 83 01 29 	brlo	80002872 <et024006_Init+0x32a>
80002624:	cf 5b       	rjmp	8000260e <et024006_Init+0xc6>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002626:	12 38       	cp.w	r8,r9
80002628:	e0 8b 01 25 	brhi	80002872 <et024006_Init+0x32a>
8000262c:	12 3a       	cp.w	r10,r9
8000262e:	e0 83 01 22 	brlo	80002872 <et024006_Init+0x32a>
80002632:	ce eb       	rjmp	8000260e <et024006_Init+0xc6>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002634:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002638:	14 38       	cp.w	r8,r10
8000263a:	e0 88 00 09 	brls	8000264c <et024006_Init+0x104>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000263e:	12 38       	cp.w	r8,r9
80002640:	fe 98 ff fa 	brls	80002634 <et024006_Init+0xec>
80002644:	12 3a       	cp.w	r10,r9
80002646:	e0 83 01 35 	brlo	800028b0 <et024006_Init+0x368>
8000264a:	cf 5b       	rjmp	80002634 <et024006_Init+0xec>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000264c:	12 38       	cp.w	r8,r9
8000264e:	e0 8b 01 31 	brhi	800028b0 <et024006_Init+0x368>
80002652:	12 3a       	cp.w	r10,r9
80002654:	e0 83 01 2e 	brlo	800028b0 <et024006_Init+0x368>
80002658:	ce eb       	rjmp	80002634 <et024006_Init+0xec>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000265a:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000265e:	14 38       	cp.w	r8,r10
80002660:	e0 88 00 09 	brls	80002672 <et024006_Init+0x12a>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80002664:	12 38       	cp.w	r8,r9
80002666:	fe 98 ff fa 	brls	8000265a <et024006_Init+0x112>
8000266a:	12 3a       	cp.w	r10,r9
8000266c:	e0 83 01 40 	brlo	800028ec <et024006_Init+0x3a4>
80002670:	cf 5b       	rjmp	8000265a <et024006_Init+0x112>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002672:	12 38       	cp.w	r8,r9
80002674:	e0 8b 01 3c 	brhi	800028ec <et024006_Init+0x3a4>
80002678:	12 3a       	cp.w	r10,r9
8000267a:	e0 83 01 39 	brlo	800028ec <et024006_Init+0x3a4>
8000267e:	ce eb       	rjmp	8000265a <et024006_Init+0x112>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80002680:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80002684:	14 38       	cp.w	r8,r10
80002686:	e0 88 00 09 	brls	80002698 <et024006_Init+0x150>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000268a:	12 38       	cp.w	r8,r9
8000268c:	fe 98 ff fa 	brls	80002680 <et024006_Init+0x138>
80002690:	12 3a       	cp.w	r10,r9
80002692:	e0 83 01 4b 	brlo	80002928 <et024006_Init+0x3e0>
80002696:	cf 5b       	rjmp	80002680 <et024006_Init+0x138>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80002698:	12 38       	cp.w	r8,r9
8000269a:	e0 8b 01 47 	brhi	80002928 <et024006_Init+0x3e0>
8000269e:	12 3a       	cp.w	r10,r9
800026a0:	e0 83 01 44 	brlo	80002928 <et024006_Init+0x3e0>
800026a4:	ce eb       	rjmp	80002680 <et024006_Init+0x138>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800026a6:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800026aa:	14 38       	cp.w	r8,r10
800026ac:	e0 88 00 09 	brls	800026be <et024006_Init+0x176>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800026b0:	12 38       	cp.w	r8,r9
800026b2:	fe 98 ff fa 	brls	800026a6 <et024006_Init+0x15e>
800026b6:	12 3a       	cp.w	r10,r9
800026b8:	e0 83 01 56 	brlo	80002964 <et024006_Init+0x41c>
800026bc:	cf 5b       	rjmp	800026a6 <et024006_Init+0x15e>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800026be:	12 38       	cp.w	r8,r9
800026c0:	e0 8b 01 52 	brhi	80002964 <et024006_Init+0x41c>
800026c4:	12 3a       	cp.w	r10,r9
800026c6:	e0 83 01 4f 	brlo	80002964 <et024006_Init+0x41c>
800026ca:	ce eb       	rjmp	800026a6 <et024006_Init+0x15e>
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800026cc:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800026d0:	14 38       	cp.w	r8,r10
800026d2:	e0 88 00 09 	brls	800026e4 <et024006_Init+0x19c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800026d6:	12 38       	cp.w	r8,r9
800026d8:	fe 98 ff fa 	brls	800026cc <et024006_Init+0x184>
800026dc:	12 3a       	cp.w	r10,r9
800026de:	e0 83 01 64 	brlo	800029a6 <et024006_Init+0x45e>
800026e2:	cf 5b       	rjmp	800026cc <et024006_Init+0x184>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800026e4:	12 38       	cp.w	r8,r9
800026e6:	e0 8b 01 60 	brhi	800029a6 <et024006_Init+0x45e>
800026ea:	12 3a       	cp.w	r10,r9
800026ec:	e0 83 01 5d 	brlo	800029a6 <et024006_Init+0x45e>
800026f0:	ce eb       	rjmp	800026cc <et024006_Init+0x184>
  // 50us delay
  cpu_delay_us( 50, tft_data.cpu_hz );

  gpio_set_gpio_pin(ET024006DHU_RESET_PIN);
800026f2:	35 2c       	mov	r12,82
800026f4:	f0 1f 00 ba 	mcall	800029dc <et024006_Init+0x494>
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800026f8:	fe f8 02 d4 	ld.w	r8,pc[724]
800026fc:	70 07       	ld.w	r7,r8[0x0]
800026fe:	30 58       	mov	r8,5
80002700:	ee 08 06 46 	mulu.d	r6,r7,r8
80002704:	e0 68 03 e8 	mov	r8,1000
80002708:	30 09       	mov	r9,0
8000270a:	e0 6a 03 e7 	mov	r10,999
8000270e:	30 0b       	mov	r11,0
80002710:	ec 0a 00 0a 	add	r10,r6,r10
80002714:	ee 0b 00 4b 	adc	r11,r7,r11
80002718:	f0 1f 00 b3 	mcall	800029e4 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000271c:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002720:	f0 0a 00 0a 	add	r10,r8,r10
80002724:	c4 fb       	rjmp	800025c2 <et024006_Init+0x7a>
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
  smc_init(tft_data.hsb_hz);
#endif
  et024006_SetupInterface();
  et024006_ResetDisplay();
  et024006_AdjustGamma();
80002726:	f0 1f 00 b1 	mcall	800029e8 <et024006_Init+0x4a0>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000272a:	fc 19 c0 00 	movh	r9,0xc000
8000272e:	30 1a       	mov	r10,1
80002730:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002732:	fc 18 c0 20 	movh	r8,0xc020
80002736:	30 6b       	mov	r11,6
80002738:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000273a:	33 ab       	mov	r11,58
8000273c:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000273e:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002740:	33 bb       	mov	r11,59
80002742:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002744:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002746:	33 ca       	mov	r10,60
80002748:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000274a:	e0 6a 00 f0 	mov	r10,240
8000274e:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002750:	33 db       	mov	r11,61
80002752:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002754:	30 07       	mov	r7,0
80002756:	b0 07       	st.h	r8[0x0],r7

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002758:	33 eb       	mov	r11,62
8000275a:	b2 0b       	st.h	r9[0x0],r11
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000275c:	33 8b       	mov	r11,56
8000275e:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002760:	34 0c       	mov	r12,64
80002762:	b2 0c       	st.h	r9[0x0],r12
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002764:	30 fe       	mov	lr,15
80002766:	b0 0e       	st.h	r8[0x0],lr

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002768:	34 1e       	mov	lr,65
8000276a:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000276c:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000276e:	32 7a       	mov	r10,39
80002770:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002772:	30 2a       	mov	r10,2
80002774:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002776:	32 8e       	mov	lr,40
80002778:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000277a:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000277c:	32 9e       	mov	lr,41
8000277e:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002780:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002782:	32 ae       	mov	lr,42
80002784:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002786:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002788:	32 ce       	mov	lr,44
8000278a:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000278c:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000278e:	32 de       	mov	lr,45
80002790:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002792:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002794:	31 9a       	mov	r10,25
80002796:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002798:	34 9a       	mov	r10,73
8000279a:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
8000279c:	e0 6a 00 93 	mov	r10,147
800027a0:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800027a2:	30 8a       	mov	r10,8
800027a4:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800027a6:	31 6a       	mov	r10,22
800027a8:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800027aa:	36 8a       	mov	r10,104
800027ac:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800027ae:	32 3a       	mov	r10,35
800027b0:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800027b2:	e0 6a 00 95 	mov	r10,149
800027b6:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800027b8:	32 4e       	mov	lr,36
800027ba:	b2 0e       	st.h	r9[0x0],lr
  *ET024006_PARAM_ADDR = (uint16_t) value;
800027bc:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800027be:	32 5a       	mov	r10,37
800027c0:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800027c2:	e0 6a 00 ff 	mov	r10,255
800027c6:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800027c8:	e0 6a 00 90 	mov	r10,144
800027cc:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800027ce:	37 fa       	mov	r10,127
800027d0:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800027d2:	33 5a       	mov	r10,53
800027d4:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800027d6:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800027d8:	33 6a       	mov	r10,54
800027da:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800027dc:	37 8a       	mov	r10,120
800027de:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800027e0:	31 da       	mov	r10,29
800027e2:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800027e4:	30 7a       	mov	r10,7
800027e6:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800027e8:	31 ea       	mov	r10,30
800027ea:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800027ec:	b0 07       	st.h	r8[0x0],r7

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800027ee:	31 fa       	mov	r10,31
800027f0:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800027f2:	30 4a       	mov	r10,4
800027f4:	b0 0a       	st.h	r8[0x0],r10

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800027f6:	32 0a       	mov	r10,32
800027f8:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800027fa:	b0 0c       	st.h	r8[0x0],r12

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800027fc:	34 4a       	mov	r10,68
800027fe:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002800:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002802:	34 5a       	mov	r10,69
80002804:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002806:	31 29       	mov	r9,18
80002808:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000280a:	4f 18       	lddpc	r8,800029cc <et024006_Init+0x484>
8000280c:	70 07       	ld.w	r7,r8[0x0]
8000280e:	30 a8       	mov	r8,10
80002810:	ee 08 06 46 	mulu.d	r6,r7,r8
80002814:	e0 68 03 e8 	mov	r8,1000
80002818:	30 09       	mov	r9,0
8000281a:	e0 6a 03 e7 	mov	r10,999
8000281e:	30 0b       	mov	r11,0
80002820:	ec 0a 00 0a 	add	r10,r6,r10
80002824:	ee 0b 00 4b 	adc	r11,r7,r11
80002828:	f0 1f 00 6f 	mcall	800029e4 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000282c:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002830:	f0 0a 00 0a 	add	r10,r8,r10
80002834:	cd aa       	rjmp	800025e8 <et024006_Init+0xa0>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002836:	31 c9       	mov	r9,28
80002838:	fc 18 c0 00 	movh	r8,0xc000
8000283c:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000283e:	30 49       	mov	r9,4
80002840:	fc 18 c0 20 	movh	r8,0xc020
80002844:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002846:	4e 28       	lddpc	r8,800029cc <et024006_Init+0x484>
80002848:	70 07       	ld.w	r7,r8[0x0]
8000284a:	31 48       	mov	r8,20
8000284c:	ee 08 06 46 	mulu.d	r6,r7,r8
80002850:	e0 68 03 e8 	mov	r8,1000
80002854:	30 09       	mov	r9,0
80002856:	e0 6a 03 e7 	mov	r10,999
8000285a:	30 0b       	mov	r11,0
8000285c:	ec 0a 00 0a 	add	r10,r6,r10
80002860:	ee 0b 00 4b 	adc	r11,r7,r11
80002864:	f0 1f 00 60 	mcall	800029e4 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80002868:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000286c:	f0 0a 00 0a 	add	r10,r8,r10
80002870:	cc fa       	rjmp	8000260e <et024006_Init+0xc6>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002872:	34 39       	mov	r9,67
80002874:	fc 18 c0 00 	movh	r8,0xc000
80002878:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000287a:	e0 69 00 80 	mov	r9,128
8000287e:	fc 18 c0 20 	movh	r8,0xc020
80002882:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002884:	4d 28       	lddpc	r8,800029cc <et024006_Init+0x484>
80002886:	70 07       	ld.w	r7,r8[0x0]
80002888:	30 58       	mov	r8,5
8000288a:	ee 08 06 46 	mulu.d	r6,r7,r8
8000288e:	e0 68 03 e8 	mov	r8,1000
80002892:	30 09       	mov	r9,0
80002894:	e0 6a 03 e7 	mov	r10,999
80002898:	30 0b       	mov	r11,0
8000289a:	ec 0a 00 0a 	add	r10,r6,r10
8000289e:	ee 0b 00 4b 	adc	r11,r7,r11
800028a2:	f0 1f 00 51 	mcall	800029e4 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800028a6:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800028aa:	f0 0a 00 0a 	add	r10,r8,r10
800028ae:	cc 3a       	rjmp	80002634 <et024006_Init+0xec>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800028b0:	31 b9       	mov	r9,27
800028b2:	fc 18 c0 00 	movh	r8,0xc000
800028b6:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
800028b8:	30 89       	mov	r9,8
800028ba:	fc 18 c0 20 	movh	r8,0xc020
800028be:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800028c0:	4c 38       	lddpc	r8,800029cc <et024006_Init+0x484>
800028c2:	70 07       	ld.w	r7,r8[0x0]
800028c4:	32 88       	mov	r8,40
800028c6:	ee 08 06 46 	mulu.d	r6,r7,r8
800028ca:	e0 68 03 e8 	mov	r8,1000
800028ce:	30 09       	mov	r9,0
800028d0:	e0 6a 03 e7 	mov	r10,999
800028d4:	30 0b       	mov	r11,0
800028d6:	ec 0a 00 0a 	add	r10,r6,r10
800028da:	ee 0b 00 4b 	adc	r11,r7,r11
800028de:	f0 1f 00 42 	mcall	800029e4 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800028e2:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800028e6:	f0 0a 00 0a 	add	r10,r8,r10
800028ea:	cb 8a       	rjmp	8000265a <et024006_Init+0x112>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800028ec:	31 b9       	mov	r9,27
800028ee:	fc 18 c0 00 	movh	r8,0xc000
800028f2:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
800028f4:	31 09       	mov	r9,16
800028f6:	fc 18 c0 20 	movh	r8,0xc020
800028fa:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
800028fc:	4b 48       	lddpc	r8,800029cc <et024006_Init+0x484>
800028fe:	70 07       	ld.w	r7,r8[0x0]
80002900:	32 88       	mov	r8,40
80002902:	ee 08 06 46 	mulu.d	r6,r7,r8
80002906:	e0 68 03 e8 	mov	r8,1000
8000290a:	30 09       	mov	r9,0
8000290c:	e0 6a 03 e7 	mov	r10,999
80002910:	30 0b       	mov	r11,0
80002912:	ec 0a 00 0a 	add	r10,r6,r10
80002916:	ee 0b 00 4b 	adc	r11,r7,r11
8000291a:	f0 1f 00 33 	mcall	800029e4 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000291e:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80002922:	f0 0a 00 0a 	add	r10,r8,r10
80002926:	ca da       	rjmp	80002680 <et024006_Init+0x138>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002928:	32 69       	mov	r9,38
8000292a:	fc 18 c0 00 	movh	r8,0xc000
8000292e:	b0 09       	st.h	r8[0x0],r9
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002930:	30 49       	mov	r9,4
80002932:	fc 18 c0 20 	movh	r8,0xc020
80002936:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
80002938:	4a 58       	lddpc	r8,800029cc <et024006_Init+0x484>
8000293a:	70 07       	ld.w	r7,r8[0x0]
8000293c:	32 88       	mov	r8,40
8000293e:	ee 08 06 46 	mulu.d	r6,r7,r8
80002942:	e0 68 03 e8 	mov	r8,1000
80002946:	30 09       	mov	r9,0
80002948:	e0 6a 03 e7 	mov	r10,999
8000294c:	30 0b       	mov	r11,0
8000294e:	ec 0a 00 0a 	add	r10,r6,r10
80002952:	ee 0b 00 4b 	adc	r11,r7,r11
80002956:	f0 1f 00 24 	mcall	800029e4 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000295a:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000295e:	f0 0a 00 0a 	add	r10,r8,r10
80002962:	ca 2a       	rjmp	800026a6 <et024006_Init+0x15e>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002964:	fc 19 c0 00 	movh	r9,0xc000
80002968:	32 6a       	mov	r10,38
8000296a:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
8000296c:	fc 18 c0 20 	movh	r8,0xc020
80002970:	32 4b       	mov	r11,36
80002972:	b0 0b       	st.h	r8[0x0],r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
80002974:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
80002976:	32 c9       	mov	r9,44
80002978:	b0 09       	st.h	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_ms_2_cy(unsigned long ms, unsigned long fcpu_hz)
{
  return ((unsigned long long)ms * fcpu_hz + 999) / 1000;
8000297a:	49 58       	lddpc	r8,800029cc <et024006_Init+0x484>
8000297c:	70 07       	ld.w	r7,r8[0x0]
8000297e:	32 88       	mov	r8,40
80002980:	ee 08 06 46 	mulu.d	r6,r7,r8
80002984:	e0 68 03 e8 	mov	r8,1000
80002988:	30 09       	mov	r9,0
8000298a:	e0 6a 03 e7 	mov	r10,999
8000298e:	30 0b       	mov	r11,0
80002990:	ec 0a 00 0a 	add	r10,r6,r10
80002994:	ee 0b 00 4b 	adc	r11,r7,r11
80002998:	f0 1f 00 13 	mcall	800029e4 <et024006_Init+0x49c>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
8000299c:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800029a0:	f0 0a 00 0a 	add	r10,r8,r10
800029a4:	c9 4a       	rjmp	800026cc <et024006_Init+0x184>

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800029a6:	fc 19 c0 00 	movh	r9,0xc000
800029aa:	32 68       	mov	r8,38
800029ac:	b2 08       	st.h	r9[0x0],r8
  *ET024006_PARAM_ADDR = (uint16_t) value;
800029ae:	fc 18 c0 20 	movh	r8,0xc020
800029b2:	33 ca       	mov	r10,60
800029b4:	b0 0a       	st.h	r8[0x0],r10
}

__always_inline static uint8_t et024006_ReadRegister( uint8_t address )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800029b6:	37 0a       	mov	r10,112
800029b8:	b2 0a       	st.h	r9[0x0],r10
  return *ET024006_PARAM_ADDR;
800029ba:	90 0b       	ld.sh	r11,r8[0x0]
800029bc:	5c 5b       	castu.b	r11

/* --- Register manipulation functions --- */
#if(ET024006_IFACE_MODE == ET024006_IFACE_MODE_EBI)
__always_inline static void et024006_WriteRegister( uint8_t address, uint8_t value )
{
  *ET024006_CMD_ADDR = (uint16_t) address;
800029be:	b2 0a       	st.h	r9[0x0],r10
  *ET024006_PARAM_ADDR = (uint16_t) value;
800029c0:	16 99       	mov	r9,r11
800029c2:	a3 b9       	sbr	r9,0x3
800029c4:	b0 09       	st.h	r8[0x0],r9
  et024006_GeneralSettings();
  et024006_InterfaceSettings();
  et024006_PowerSettings();
  et024006_PowerUp();
  et024006_PowerOn();
}
800029c6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800029ca:	00 00       	add	r0,r0
800029cc:	00 00       	add	r0,r0
800029ce:	01 20       	ld.uh	r0,r0++
800029d0:	80 00       	ld.sh	r0,r0[0x0]
800029d2:	29 ec       	sub	r12,-98
800029d4:	80 00       	ld.sh	r0,r0[0x0]
800029d6:	2b 8c       	sub	r12,-72
800029d8:	80 00       	ld.sh	r0,r0[0x0]
800029da:	2b 08       	sub	r8,-80
800029dc:	80 00       	ld.sh	r0,r0[0x0]
800029de:	2b a4       	sub	r4,-70
800029e0:	80 00       	ld.sh	r0,r0[0x0]
800029e2:	2b c0       	sub	r0,-68
800029e4:	80 00       	ld.sh	r0,r0[0x0]
800029e6:	59 36       	cp.w	r6,19
800029e8:	80 00       	ld.sh	r0,r0[0x0]
800029ea:	24 d8       	sub	r8,77

800029ec <smc_init>:

static void smc_enable_muxed_pins(void);


void smc_init(unsigned long hsb_hz)
{
800029ec:	eb cd 40 fc 	pushm	r2-r7,lr
  unsigned long hsb_mhz_up = (hsb_hz + 999999) / 1000000;
800029f0:	ee 78 42 3f 	mov	r8,999999
800029f4:	f8 08 00 09 	add	r9,r12,r8
800029f8:	e0 68 de 83 	mov	r8,56963
800029fc:	ea 18 43 1b 	orh	r8,0x431b
80002a00:	f2 08 06 48 	mulu.d	r8,r9,r8
80002a04:	f2 08 16 12 	lsr	r8,r9,0x12
//! Whether to use the NCS0 pin
#ifdef SMC_USE_NCS0
  #include SMC_COMPONENT_CS0

  // Setup SMC for NCS0
  SMC_CS_SETUP(0)
80002a08:	f0 08 00 25 	add	r5,r8,r8<<0x2
80002a0c:	a3 65       	lsl	r5,0x2
80002a0e:	ea c5 fc 19 	sub	r5,r5,-999
80002a12:	e0 69 4d d3 	mov	r9,19923
80002a16:	ea 19 10 62 	orh	r9,0x1062
80002a1a:	ea 09 06 44 	mulu.d	r4,r5,r9
80002a1e:	a7 85       	lsr	r5,0x6
80002a20:	f0 0a 15 04 	lsl	r10,r8,0x4
80002a24:	f4 08 01 07 	sub	r7,r10,r8
80002a28:	a1 77       	lsl	r7,0x1
80002a2a:	ee c7 fc 19 	sub	r7,r7,-999
80002a2e:	ee 09 06 46 	mulu.d	r6,r7,r9
80002a32:	0e 94       	mov	r4,r7
80002a34:	a7 84       	lsr	r4,0x6
80002a36:	f4 08 01 07 	sub	r7,r10,r8
80002a3a:	a3 67       	lsl	r7,0x2
80002a3c:	ee c7 fc 19 	sub	r7,r7,-999
80002a40:	ee 09 06 46 	mulu.d	r6,r7,r9
80002a44:	a7 87       	lsr	r7,0x6
80002a46:	f0 03 10 5a 	mul	r3,r8,90
80002a4a:	e6 c3 fc 19 	sub	r3,r3,-999
80002a4e:	e6 09 06 42 	mulu.d	r2,r3,r9
80002a52:	e6 0c 16 06 	lsr	r12,r3,0x6
80002a56:	e0 63 00 d2 	mov	r3,210
80002a5a:	f0 03 02 43 	mul	r3,r8,r3
80002a5e:	e6 c3 fc 19 	sub	r3,r3,-999
80002a62:	e6 09 06 42 	mulu.d	r2,r3,r9
80002a66:	e6 06 16 06 	lsr	r6,r3,0x6
80002a6a:	f4 08 01 0b 	sub	r11,r10,r8
80002a6e:	a5 6b       	lsl	r11,0x4
80002a70:	f6 cb fc 19 	sub	r11,r11,-999
80002a74:	f6 09 06 4a 	mulu.d	r10,r11,r9
80002a78:	f6 0e 16 06 	lsr	lr,r11,0x6
80002a7c:	f0 03 10 64 	mul	r3,r8,100
80002a80:	e6 c3 fc 19 	sub	r3,r3,-999
80002a84:	e6 09 06 42 	mulu.d	r2,r3,r9
80002a88:	a7 83       	lsr	r3,0x6
80002a8a:	e0 6a 01 0e 	mov	r10,270
80002a8e:	b5 38       	mul	r8,r10
80002a90:	f0 c8 fc 19 	sub	r8,r8,-999
80002a94:	f0 09 06 48 	mulu.d	r8,r8,r9
80002a98:	a7 89       	lsr	r9,0x6
80002a9a:	ec 04 00 0a 	add	r10,r6,r4
80002a9e:	1c 3a       	cp.w	r10,lr
80002aa0:	f4 0e 17 20 	movhs	lr,r10
80002aa4:	ee 05 00 0b 	add	r11,r7,r5
80002aa8:	18 3b       	cp.w	r11,r12
80002aaa:	f6 0c 17 20 	movhs	r12,r11
80002aae:	06 3b       	cp.w	r11,r3
80002ab0:	e6 0b 17 30 	movlo	r11,r3
80002ab4:	12 3a       	cp.w	r10,r9
80002ab6:	f4 09 17 20 	movhs	r9,r10
80002aba:	eb e4 11 05 	or	r5,r5,r4<<0x10
80002abe:	fe 6a 1c 00 	mov	r10,-123904
80002ac2:	95 05       	st.w	r10[0x0],r5
80002ac4:	ef e6 11 07 	or	r7,r7,r6<<0x10
80002ac8:	ef ec 10 87 	or	r7,r7,r12<<0x8
80002acc:	ef ee 11 87 	or	r7,r7,lr<<0x18
80002ad0:	95 17       	st.w	r10[0x4],r7
80002ad2:	1c 39       	cp.w	r9,lr
80002ad4:	f2 0e 17 20 	movhs	lr,r9
80002ad8:	18 3b       	cp.w	r11,r12
80002ada:	f8 0b 17 30 	movlo	r11,r12
80002ade:	f7 ee 11 0b 	or	r11,r11,lr<<0x10
80002ae2:	95 2b       	st.w	r10[0x8],r11
80002ae4:	e0 68 10 03 	mov	r8,4099
80002ae8:	95 38       	st.w	r10[0xc],r8
80002aea:	30 19       	mov	r9,1
80002aec:	48 48       	lddpc	r8,80002afc <smc_init+0x110>
80002aee:	b0 89       	st.b	r8[0x0],r9
        {ATPASTE2(EBI_NCS_5,_PIN),ATPASTE2(EBI_NCS_5,_FUNCTION)},
    #endif
#endif
 };

  gpio_enable_module(SMC_EBI_GPIO_MAP, sizeof(SMC_EBI_GPIO_MAP) / sizeof(SMC_EBI_GPIO_MAP[0]));
80002af0:	31 4b       	mov	r11,20
80002af2:	48 4c       	lddpc	r12,80002b00 <smc_init+0x114>
80002af4:	f0 1f 00 04 	mcall	80002b04 <smc_init+0x118>
  #undef NCS_CONTROLLED_WRITE
  #undef NWAIT_MODE
#endif
  // Put the multiplexed MCU pins used for the SM under control of the SMC.
  smc_enable_muxed_pins();
}
80002af8:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002afc:	00 00       	add	r0,r0
80002afe:	01 28       	ld.uh	r8,r0++
80002b00:	80 00       	ld.sh	r0,r0[0x0]
80002b02:	61 08       	ld.w	r8,r0[0x40]
80002b04:	80 00       	ld.sh	r0,r0[0x0]
80002b06:	2b 5c       	sub	r12,-75

80002b08 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80002b08:	f8 08 16 05 	lsr	r8,r12,0x5
80002b0c:	a9 68       	lsl	r8,0x8
80002b0e:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80002b12:	58 1b       	cp.w	r11,1
80002b14:	c0 d0       	breq	80002b2e <gpio_enable_module_pin+0x26>
80002b16:	c0 63       	brcs	80002b22 <gpio_enable_module_pin+0x1a>
80002b18:	58 2b       	cp.w	r11,2
80002b1a:	c1 00       	breq	80002b3a <gpio_enable_module_pin+0x32>
80002b1c:	58 3b       	cp.w	r11,3
80002b1e:	c1 40       	breq	80002b46 <gpio_enable_module_pin+0x3e>
80002b20:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80002b22:	30 19       	mov	r9,1
80002b24:	f2 0c 09 49 	lsl	r9,r9,r12
80002b28:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80002b2a:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80002b2c:	c1 28       	rjmp	80002b50 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80002b2e:	30 19       	mov	r9,1
80002b30:	f2 0c 09 49 	lsl	r9,r9,r12
80002b34:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80002b36:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80002b38:	c0 c8       	rjmp	80002b50 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80002b3a:	30 19       	mov	r9,1
80002b3c:	f2 0c 09 49 	lsl	r9,r9,r12
80002b40:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80002b42:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80002b44:	c0 68       	rjmp	80002b50 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80002b46:	30 19       	mov	r9,1
80002b48:	f2 0c 09 49 	lsl	r9,r9,r12
80002b4c:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80002b4e:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80002b50:	30 19       	mov	r9,1
80002b52:	f2 0c 09 4c 	lsl	r12,r9,r12
80002b56:	91 2c       	st.w	r8[0x8],r12
80002b58:	5e fd       	retal	0
80002b5a:	d7 03       	nop

80002b5c <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80002b5c:	d4 21       	pushm	r4-r7,lr
80002b5e:	18 97       	mov	r7,r12
80002b60:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80002b62:	58 0b       	cp.w	r11,0
80002b64:	c0 31       	brne	80002b6a <gpio_enable_module+0xe>
80002b66:	30 05       	mov	r5,0
80002b68:	c0 d8       	rjmp	80002b82 <gpio_enable_module+0x26>
80002b6a:	30 06       	mov	r6,0
80002b6c:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80002b6e:	6e 1b       	ld.w	r11,r7[0x4]
80002b70:	6e 0c       	ld.w	r12,r7[0x0]
80002b72:	f0 1f 00 06 	mcall	80002b88 <gpio_enable_module+0x2c>
80002b76:	18 45       	or	r5,r12
		gpiomap++;
80002b78:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80002b7a:	2f f6       	sub	r6,-1
80002b7c:	0c 34       	cp.w	r4,r6
80002b7e:	fe 9b ff f8 	brhi	80002b6e <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80002b82:	0a 9c       	mov	r12,r5
80002b84:	d8 22       	popm	r4-r7,pc
80002b86:	00 00       	add	r0,r0
80002b88:	80 00       	ld.sh	r0,r0[0x0]
80002b8a:	2b 08       	sub	r8,-80

80002b8c <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80002b8c:	f8 08 16 05 	lsr	r8,r12,0x5
80002b90:	a9 68       	lsl	r8,0x8
80002b92:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80002b96:	30 19       	mov	r9,1
80002b98:	f2 0c 09 4c 	lsl	r12,r9,r12
80002b9c:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80002ba0:	91 1c       	st.w	r8[0x4],r12
}
80002ba2:	5e fc       	retal	r12

80002ba4 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80002ba4:	f8 08 16 05 	lsr	r8,r12,0x5
80002ba8:	a9 68       	lsl	r8,0x8
80002baa:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80002bae:	30 19       	mov	r9,1
80002bb0:	f2 0c 09 4c 	lsl	r12,r9,r12
80002bb4:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80002bb8:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80002bbc:	91 1c       	st.w	r8[0x4],r12
}
80002bbe:	5e fc       	retal	r12

80002bc0 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80002bc0:	f8 08 16 05 	lsr	r8,r12,0x5
80002bc4:	a9 68       	lsl	r8,0x8
80002bc6:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80002bca:	30 19       	mov	r9,1
80002bcc:	f2 0c 09 4c 	lsl	r12,r9,r12
80002bd0:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80002bd4:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80002bd8:	91 1c       	st.w	r8[0x4],r12
}
80002bda:	5e fc       	retal	r12

80002bdc <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80002bdc:	fe 78 08 00 	mov	r8,-63488
80002be0:	e0 69 00 83 	mov	r9,131
80002be4:	f2 0c 01 0c 	sub	r12,r9,r12
80002be8:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80002bec:	f2 ca ff c0 	sub	r10,r9,-64
80002bf0:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80002bf4:	58 08       	cp.w	r8,0
80002bf6:	c0 21       	brne	80002bfa <_get_interrupt_handler+0x1e>
80002bf8:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80002bfa:	f0 08 12 00 	clz	r8,r8
80002bfe:	48 5a       	lddpc	r10,80002c10 <_get_interrupt_handler+0x34>
80002c00:	f4 09 00 39 	add	r9,r10,r9<<0x3
80002c04:	f0 08 11 1f 	rsub	r8,r8,31
80002c08:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80002c0a:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80002c0e:	5e fc       	retal	r12
80002c10:	80 00       	ld.sh	r0,r0[0x0]
80002c12:	61 a8       	ld.w	r8,r0[0x68]

80002c14 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80002c14:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
80002c16:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80002c1a:	99 a8       	st.w	r12[0x28],r8
}
80002c1c:	5e fc       	retal	r12
80002c1e:	d7 03       	nop

80002c20 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80002c20:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80002c22:	ec 5b bb 9f 	cp.w	r11,899999
80002c26:	e0 8b 00 04 	brhi	80002c2e <pm_enable_osc0_crystal+0xe>
80002c2a:	30 4b       	mov	r11,4
80002c2c:	c1 38       	rjmp	80002c52 <pm_enable_osc0_crystal+0x32>
80002c2e:	e0 68 c6 bf 	mov	r8,50879
80002c32:	ea 18 00 2d 	orh	r8,0x2d
80002c36:	10 3b       	cp.w	r11,r8
80002c38:	e0 8b 00 04 	brhi	80002c40 <pm_enable_osc0_crystal+0x20>
80002c3c:	30 5b       	mov	r11,5
80002c3e:	c0 a8       	rjmp	80002c52 <pm_enable_osc0_crystal+0x32>
80002c40:	e0 68 12 00 	mov	r8,4608
80002c44:	ea 18 00 7a 	orh	r8,0x7a
80002c48:	10 3b       	cp.w	r11,r8
80002c4a:	f9 bb 03 06 	movlo	r11,6
80002c4e:	f9 bb 02 07 	movhs	r11,7
80002c52:	f0 1f 00 02 	mcall	80002c58 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
80002c56:	d8 02       	popm	pc
80002c58:	80 00       	ld.sh	r0,r0[0x0]
80002c5a:	2c 14       	sub	r4,-63

80002c5c <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80002c5c:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80002c5e:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80002c62:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80002c64:	78 08       	ld.w	r8,r12[0x0]
80002c66:	a3 a8       	sbr	r8,0x2
80002c68:	99 08       	st.w	r12[0x0],r8
}
80002c6a:	5e fc       	retal	r12

80002c6c <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80002c6c:	79 58       	ld.w	r8,r12[0x54]
80002c6e:	e2 18 00 80 	andl	r8,0x80,COH
80002c72:	cf d0       	breq	80002c6c <pm_wait_for_clk0_ready>
}
80002c74:	5e fc       	retal	r12
80002c76:	d7 03       	nop

80002c78 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80002c78:	eb cd 40 80 	pushm	r7,lr
80002c7c:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
80002c7e:	f0 1f 00 04 	mcall	80002c8c <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
80002c82:	0e 9c       	mov	r12,r7
80002c84:	f0 1f 00 03 	mcall	80002c90 <pm_enable_clk0+0x18>
}
80002c88:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c8c:	80 00       	ld.sh	r0,r0[0x0]
80002c8e:	2c 5c       	sub	r12,-59
80002c90:	80 00       	ld.sh	r0,r0[0x0]
80002c92:	2c 6c       	sub	r12,-58

80002c94 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80002c94:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80002c96:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
80002c9a:	99 08       	st.w	r12[0x0],r8
}
80002c9c:	5e fc       	retal	r12
80002c9e:	d7 03       	nop

80002ca0 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80002ca0:	eb cd 40 c0 	pushm	r6-r7,lr
80002ca4:	18 97       	mov	r7,r12
80002ca6:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80002ca8:	f0 1f 00 06 	mcall	80002cc0 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80002cac:	0c 9b       	mov	r11,r6
80002cae:	0e 9c       	mov	r12,r7
80002cb0:	f0 1f 00 05 	mcall	80002cc4 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80002cb4:	30 1b       	mov	r11,1
80002cb6:	0e 9c       	mov	r12,r7
80002cb8:	f0 1f 00 04 	mcall	80002cc8 <pm_switch_to_osc0+0x28>
}
80002cbc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002cc0:	80 00       	ld.sh	r0,r0[0x0]
80002cc2:	2c 20       	sub	r0,-62
80002cc4:	80 00       	ld.sh	r0,r0[0x0]
80002cc6:	2c 78       	sub	r8,-57
80002cc8:	80 00       	ld.sh	r0,r0[0x0]
80002cca:	2c 94       	sub	r4,-55

80002ccc <pcl_switch_to_osc>:
        return PASS;
}
#endif // UC3D device-specific implementation

long int pcl_switch_to_osc(pcl_osc_t osc, unsigned int fcrystal, unsigned int startup)
{
80002ccc:	d4 01       	pushm	lr
#ifndef AVR32_PM_VERSION_RESETVALUE
// Implementation for UC3A, UC3A3, UC3B parts.
  if(PCL_OSC0 == osc)
80002cce:	58 0c       	cp.w	r12,0
80002cd0:	c0 40       	breq	80002cd8 <pcl_switch_to_osc+0xc>
80002cd2:	fe 7c d8 f0 	mov	r12,-10000
80002cd6:	d8 02       	popm	pc
  {
    // Configure OSC0 in crystal mode, external crystal with a FOSC0 Hz frequency,
    // enable the OSC0, set the main clock source as being OSC0.
    pm_switch_to_osc0(&AVR32_PM, fcrystal, startup);
80002cd8:	fe 7c 0c 00 	mov	r12,-62464
80002cdc:	f0 1f 00 02 	mcall	80002ce4 <pcl_switch_to_osc+0x18>
80002ce0:	d8 0a       	popm	pc,r12=0
80002ce2:	00 00       	add	r0,r0
80002ce4:	80 00       	ld.sh	r0,r0[0x0]
80002ce6:	2c a0       	sub	r0,-54

80002ce8 <pwm_channel_init>:

int pwm_channel_init( unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;

  if (pwm_channel == 0) // Null pointer.
80002ce8:	58 0b       	cp.w	r11,0
80002cea:	c1 90       	breq	80002d1c <pwm_channel_init+0x34>
    return PWM_INVALID_ARGUMENT;
  if (channel_id > AVR32_PWM_LINES_MSB) // Control input values.
80002cec:	58 6c       	cp.w	r12,6
80002cee:	e0 8b 00 17 	brhi	80002d1c <pwm_channel_init+0x34>
    return PWM_INVALID_INPUT;

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode.
80002cf2:	76 0a       	ld.w	r10,r11[0x0]
80002cf4:	fe 78 30 00 	mov	r8,-53248
80002cf8:	f8 c9 ff f0 	sub	r9,r12,-16
80002cfc:	a5 79       	lsl	r9,0x5
80002cfe:	f0 09 00 09 	add	r9,r8,r9
80002d02:	93 0a       	st.w	r9[0x0],r10
  pwm->channel[channel_id].cdty= pwm_channel->cdty; // Duty cycle, should be < CPRD.
80002d04:	76 19       	ld.w	r9,r11[0x4]
80002d06:	a5 7c       	lsl	r12,0x5
80002d08:	f0 0c 00 0c 	add	r12,r8,r12
80002d0c:	f8 c8 fd fc 	sub	r8,r12,-516
80002d10:	91 09       	st.w	r8[0x0],r9
  pwm->channel[channel_id].cprd= pwm_channel->cprd; // Channel period.
80002d12:	76 28       	ld.w	r8,r11[0x8]
80002d14:	f8 cc fd f8 	sub	r12,r12,-520
80002d18:	99 08       	st.w	r12[0x0],r8
80002d1a:	5e fd       	retal	0

  return PWM_SUCCESS;
80002d1c:	5e ff       	retal	1

80002d1e <pwm_start_channels>:
}


int pwm_start_channels(unsigned long channels_bitmask)
{
  if (channels_bitmask & ~((1 << (AVR32_PWM_LINES_MSB + 1)) - 1))
80002d1e:	18 98       	mov	r8,r12
80002d20:	e0 18 ff 80 	andl	r8,0xff80
80002d24:	c0 20       	breq	80002d28 <pwm_start_channels+0xa>
80002d26:	5e ff       	retal	1
    return PWM_INVALID_INPUT;

  AVR32_PWM.ena = channels_bitmask; // Enable channels.
80002d28:	fe 78 30 00 	mov	r8,-53248
80002d2c:	91 1c       	st.w	r8[0x4],r12
80002d2e:	5e fd       	retal	0

80002d30 <pwm_async_update_channel>:

int pwm_async_update_channel(unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;

  if (channel_id > AVR32_PWM_LINES_MSB)
80002d30:	58 6c       	cp.w	r12,6
80002d32:	e0 88 00 03 	brls	80002d38 <pwm_async_update_channel+0x8>
80002d36:	5e ff       	retal	1
     return PWM_INVALID_INPUT;

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode register: update of the period or duty cycle.
80002d38:	76 0a       	ld.w	r10,r11[0x0]
80002d3a:	fe 78 30 00 	mov	r8,-53248
80002d3e:	f8 c9 ff f0 	sub	r9,r12,-16
80002d42:	a5 79       	lsl	r9,0x5
80002d44:	f0 09 00 09 	add	r9,r8,r9
80002d48:	93 0a       	st.w	r9[0x0],r10
  pwm->channel[channel_id].cupd= pwm_channel->cupd; // Channel update CPRDx or CDTYx according to CPD value in CMRx.
80002d4a:	76 49       	ld.w	r9,r11[0x10]
80002d4c:	a5 7c       	lsl	r12,0x5
80002d4e:	18 08       	add	r8,r12
80002d50:	f0 c8 fd f0 	sub	r8,r8,-528
80002d54:	91 09       	st.w	r8[0x0],r9
80002d56:	5e fd       	retal	0

80002d58 <pwm_init>:


int pwm_init(const pwm_opt_t *opt)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80002d58:	e1 b8 00 00 	mfsr	r8,0x0

  if (opt == 0 ) // Null pointer.
80002d5c:	58 0c       	cp.w	r12,0
80002d5e:	c0 21       	brne	80002d62 <pwm_init+0xa>
80002d60:	5e ff       	retal	1
    return PWM_INVALID_INPUT;

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
80002d62:	e6 18 00 01 	andh	r8,0x1,COH
80002d66:	c0 91       	brne	80002d78 <pwm_init+0x20>
80002d68:	d3 03       	ssrf	0x10
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
80002d6a:	fe 78 30 00 	mov	r8,-53248
80002d6e:	37 f9       	mov	r9,127
80002d70:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
80002d72:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();
80002d74:	d5 03       	csrf	0x10
80002d76:	c0 68       	rjmp	80002d82 <pwm_init+0x2a>
  if (opt == 0 ) // Null pointer.
    return PWM_INVALID_INPUT;

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
80002d78:	fe 78 30 00 	mov	r8,-53248
80002d7c:	37 f9       	mov	r9,127
80002d7e:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
80002d80:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
    ((opt->diva)<<AVR32_PWM_DIVA_OFFSET) |
80002d82:	78 08       	ld.w	r8,r12[0x0]
80002d84:	78 39       	ld.w	r9,r12[0xc]
80002d86:	a9 69       	lsl	r9,0x8
80002d88:	f3 e8 11 09 	or	r9,r9,r8<<0x10
80002d8c:	78 18       	ld.w	r8,r12[0x4]
80002d8e:	10 49       	or	r9,r8
80002d90:	78 28       	ld.w	r8,r12[0x8]
80002d92:	f3 e8 11 89 	or	r9,r9,r8<<0x18
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
  pwm->isr;
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
80002d96:	fe 78 30 00 	mov	r8,-53248
80002d9a:	91 09       	st.w	r8[0x0],r9
80002d9c:	5e fd       	retal	0
80002d9e:	d7 03       	nop

80002da0 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80002da0:	e0 7d 00 00 	mov	sp,65536

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80002da4:	fe c0 d1 a4 	sub	r0,pc,-11868

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80002da8:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80002dac:	d5 53       	csrf	0x15
  cp      r0, r1
80002dae:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
80002db0:	e0 61 01 20 	mov	r1,288
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80002db4:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80002db6:	c0 72       	brcc	80002dc4 <idata_load_loop_end>
  cp      r0, r1
80002db8:	fe c2 c9 08 	sub	r2,pc,-14072

80002dbc <idata_load_loop>:
  brlo    idata_load_loop
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80002dbc:	a5 05       	ld.d	r4,r2++
  lda.w   r1, _end
80002dbe:	a1 24       	st.d	r0++,r4
  cp      r0, r1
80002dc0:	02 30       	cp.w	r0,r1
  brhs    udata_clear_loop_end
80002dc2:	cf d3       	brcs	80002dbc <idata_load_loop>

80002dc4 <idata_load_loop_end>:
  mov     r2, 0
80002dc4:	e0 60 01 20 	mov	r0,288
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
80002dc8:	e0 61 02 20 	mov	r1,544
  cp      r0, r1
  brlo    udata_clear_loop
80002dcc:	02 30       	cp.w	r0,r1
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80002dce:	c0 62       	brcc	80002dda <udata_clear_loop_end>
80002dd0:	30 02       	mov	r2,0
80002dd2:	30 03       	mov	r3,0

80002dd4 <udata_clear_loop>:
80002dd4:	a1 22       	st.d	r0++,r2
80002dd6:	02 30       	cp.w	r0,r1
80002dd8:	cf e3       	brcs	80002dd4 <udata_clear_loop>

80002dda <udata_clear_loop_end>:
80002dda:	fe cf f8 8a 	sub	pc,pc,-1910
80002dde:	d7 03       	nop

80002de0 <color16>:
// Function names and descriptions
uint16_t color16(uint8_t r, uint8_t g, uint8_t b);
void draw_gradient_rectangle( uint16_t x, uint16_t y, uint16_t width, uint16_t height, uint16_t color1, uint16_t color2, uint8_t vertical);

// Functions
uint16_t color16(uint8_t r, uint8_t g, uint8_t b){
80002de0:	f5 ec 10 bc 	or	r12,r10,r12<<0xb
80002de4:	f9 eb 10 5c 	or	r12,r12,r11<<0x5
  uint16_t color = (b)|((g)<<5)|((r)<<11);
  return(color);
}
80002de8:	5c 8c       	casts.h	r12
80002dea:	5e fc       	retal	r12

80002dec <to_rad>:
  return ( sqrt(pow(p1->x - p2->x,2) + pow(p1->y - p2->y,2)) );
}
float to_deg(float radians) {
    return (radians * (180.0 / M_PI));
}
float to_rad(float degrees) {
80002dec:	d4 01       	pushm	lr
80002dee:	f0 1f 00 0c 	mcall	80002e1c <to_rad+0x30>
80002df2:	e0 68 2d 18 	mov	r8,11544
80002df6:	ea 18 54 44 	orh	r8,0x5444
80002dfa:	e0 69 21 fb 	mov	r9,8699
80002dfe:	ea 19 40 09 	orh	r9,0x4009
80002e02:	f0 1f 00 08 	mcall	80002e20 <to_rad+0x34>
80002e06:	30 08       	mov	r8,0
80002e08:	e0 69 80 00 	mov	r9,32768
80002e0c:	ea 19 40 66 	orh	r9,0x4066
80002e10:	f0 1f 00 05 	mcall	80002e24 <to_rad+0x38>
80002e14:	f0 1f 00 05 	mcall	80002e28 <to_rad+0x3c>
    return ( (degrees * M_PI) / 180.0);
}
80002e18:	d8 02       	popm	pc
80002e1a:	00 00       	add	r0,r0
80002e1c:	80 00       	ld.sh	r0,r0[0x0]
80002e1e:	58 4c       	cp.w	r12,4
80002e20:	80 00       	ld.sh	r0,r0[0x0]
80002e22:	4b 84       	lddpc	r4,80002f00 <draw_line2D+0x74>
80002e24:	80 00       	ld.sh	r0,r0[0x0]
80002e26:	52 44       	stdsp	sp[0x90],r4
80002e28:	80 00       	ld.sh	r0,r0[0x0]
80002e2a:	58 ac       	cp.w	r12,10

80002e2c <euclidian_distance>:
    if (p2->x >= 0.0 && p2->x <= 320.4 && p2->y >= 0.0 && p2->y <= 240.4){
      et024006_DrawLine(round(p1->x), round(p1->y), round(p2->x), round(p2->y), BLACK);
    }
  }
}
float euclidian_distance(point2D * p1, point2D * p2){
80002e2c:	d4 21       	pushm	r4-r7,lr
80002e2e:	18 97       	mov	r7,r12
80002e30:	16 96       	mov	r6,r11
  return ( sqrt(pow(p1->x - p2->x,2) + pow(p1->y - p2->y,2)) );
80002e32:	76 0b       	ld.w	r11,r11[0x0]
80002e34:	78 0c       	ld.w	r12,r12[0x0]
80002e36:	f0 1f 00 10 	mcall	80002e74 <euclidian_distance+0x48>
80002e3a:	f0 1f 00 10 	mcall	80002e78 <euclidian_distance+0x4c>
80002e3e:	14 98       	mov	r8,r10
80002e40:	16 99       	mov	r9,r11
80002e42:	f0 1f 00 0f 	mcall	80002e7c <euclidian_distance+0x50>
80002e46:	14 94       	mov	r4,r10
80002e48:	16 95       	mov	r5,r11
80002e4a:	6c 1b       	ld.w	r11,r6[0x4]
80002e4c:	6e 1c       	ld.w	r12,r7[0x4]
80002e4e:	f0 1f 00 0a 	mcall	80002e74 <euclidian_distance+0x48>
80002e52:	f0 1f 00 0a 	mcall	80002e78 <euclidian_distance+0x4c>
80002e56:	14 98       	mov	r8,r10
80002e58:	16 99       	mov	r9,r11
80002e5a:	f0 1f 00 09 	mcall	80002e7c <euclidian_distance+0x50>
80002e5e:	14 98       	mov	r8,r10
80002e60:	16 99       	mov	r9,r11
80002e62:	08 9a       	mov	r10,r4
80002e64:	0a 9b       	mov	r11,r5
80002e66:	f0 1f 00 07 	mcall	80002e80 <euclidian_distance+0x54>
80002e6a:	f0 1f 00 07 	mcall	80002e84 <euclidian_distance+0x58>
80002e6e:	f0 1f 00 07 	mcall	80002e88 <euclidian_distance+0x5c>
}
80002e72:	d8 22       	popm	r4-r7,pc
80002e74:	80 00       	ld.sh	r0,r0[0x0]
80002e76:	55 60       	stdsp	sp[0x158],r0
80002e78:	80 00       	ld.sh	r0,r0[0x0]
80002e7a:	58 4c       	cp.w	r12,4
80002e7c:	80 00       	ld.sh	r0,r0[0x0]
80002e7e:	4b 84       	lddpc	r4,80002f5c <draw_line2D+0xd0>
80002e80:	80 00       	ld.sh	r0,r0[0x0]
80002e82:	4e f8       	lddpc	r8,8000303c <draw_point2D+0x60>
80002e84:	80 00       	ld.sh	r0,r0[0x0]
80002e86:	38 7c       	mov	r12,-121
80002e88:	80 00       	ld.sh	r0,r0[0x0]
80002e8a:	58 ac       	cp.w	r12,10

80002e8c <draw_line2D>:
void draw_point2D(point2D * p){
  if (p->x >= 0.0 && p->x <= 320.4 && p->y >= 0.0 && p->y <= 240.4){
    et024006_DrawPixel( round(p->x), round(p->y), color16(63,000,63));
  }
}
void draw_line2D(point2D * p1, point2D * p2){
80002e8c:	d4 31       	pushm	r0-r7,lr
80002e8e:	20 2d       	sub	sp,8
80002e90:	18 96       	mov	r6,r12
80002e92:	16 95       	mov	r5,r11
  if (p1->x >= 0.0 && p1->x <= 320.4 && p1->y >= 0.0 && p1->y <= 240.4){
80002e94:	78 07       	ld.w	r7,r12[0x0]
80002e96:	30 0b       	mov	r11,0
80002e98:	0e 9c       	mov	r12,r7
80002e9a:	f0 1f 00 4b 	mcall	80002fc4 <draw_line2D+0x138>
80002e9e:	e0 80 00 91 	breq	80002fc0 <draw_line2D+0x134>
80002ea2:	0e 9c       	mov	r12,r7
80002ea4:	f0 1f 00 49 	mcall	80002fc8 <draw_line2D+0x13c>
80002ea8:	14 92       	mov	r2,r10
80002eaa:	16 93       	mov	r3,r11
80002eac:	14 98       	mov	r8,r10
80002eae:	06 99       	mov	r9,r3
80002eb0:	e0 6a 66 66 	mov	r10,26214
80002eb4:	ea 1a 66 66 	orh	r10,0x6666
80002eb8:	e0 6b 06 66 	mov	r11,1638
80002ebc:	ea 1b 40 74 	orh	r11,0x4074
80002ec0:	f0 1f 00 43 	mcall	80002fcc <draw_line2D+0x140>
80002ec4:	c7 e0       	breq	80002fc0 <draw_line2D+0x134>
80002ec6:	6c 17       	ld.w	r7,r6[0x4]
80002ec8:	30 0b       	mov	r11,0
80002eca:	0e 9c       	mov	r12,r7
80002ecc:	f0 1f 00 3e 	mcall	80002fc4 <draw_line2D+0x138>
80002ed0:	c7 80       	breq	80002fc0 <draw_line2D+0x134>
80002ed2:	0e 9c       	mov	r12,r7
80002ed4:	f0 1f 00 3d 	mcall	80002fc8 <draw_line2D+0x13c>
80002ed8:	14 90       	mov	r0,r10
80002eda:	16 91       	mov	r1,r11
80002edc:	14 98       	mov	r8,r10
80002ede:	02 99       	mov	r9,r1
80002ee0:	e0 6a cc cd 	mov	r10,52429
80002ee4:	ea 1a cc cc 	orh	r10,0xcccc
80002ee8:	e0 6b 0c cc 	mov	r11,3276
80002eec:	ea 1b 40 6e 	orh	r11,0x406e
80002ef0:	f0 1f 00 37 	mcall	80002fcc <draw_line2D+0x140>
80002ef4:	c6 60       	breq	80002fc0 <draw_line2D+0x134>
    if (p2->x >= 0.0 && p2->x <= 320.4 && p2->y >= 0.0 && p2->y <= 240.4){
80002ef6:	6a 07       	ld.w	r7,r5[0x0]
80002ef8:	30 0b       	mov	r11,0
80002efa:	0e 9c       	mov	r12,r7
80002efc:	f0 1f 00 32 	mcall	80002fc4 <draw_line2D+0x138>
80002f00:	c6 00       	breq	80002fc0 <draw_line2D+0x134>
80002f02:	0e 9c       	mov	r12,r7
80002f04:	f0 1f 00 31 	mcall	80002fc8 <draw_line2D+0x13c>
80002f08:	fa eb 00 00 	st.d	sp[0],r10
80002f0c:	14 98       	mov	r8,r10
80002f0e:	16 99       	mov	r9,r11
80002f10:	e0 6a 66 66 	mov	r10,26214
80002f14:	ea 1a 66 66 	orh	r10,0x6666
80002f18:	e0 6b 06 66 	mov	r11,1638
80002f1c:	ea 1b 40 74 	orh	r11,0x4074
80002f20:	f0 1f 00 2b 	mcall	80002fcc <draw_line2D+0x140>
80002f24:	c4 e0       	breq	80002fc0 <draw_line2D+0x134>
80002f26:	6a 17       	ld.w	r7,r5[0x4]
80002f28:	30 0b       	mov	r11,0
80002f2a:	0e 9c       	mov	r12,r7
80002f2c:	f0 1f 00 26 	mcall	80002fc4 <draw_line2D+0x138>
80002f30:	c4 80       	breq	80002fc0 <draw_line2D+0x134>
80002f32:	0e 9c       	mov	r12,r7
80002f34:	f0 1f 00 25 	mcall	80002fc8 <draw_line2D+0x13c>
80002f38:	14 96       	mov	r6,r10
80002f3a:	16 97       	mov	r7,r11
80002f3c:	14 98       	mov	r8,r10
80002f3e:	0e 99       	mov	r9,r7
80002f40:	e0 6a cc cd 	mov	r10,52429
80002f44:	ea 1a cc cc 	orh	r10,0xcccc
80002f48:	e0 6b 0c cc 	mov	r11,3276
80002f4c:	ea 1b 40 6e 	orh	r11,0x406e
80002f50:	f0 1f 00 1f 	mcall	80002fcc <draw_line2D+0x140>
80002f54:	c3 60       	breq	80002fc0 <draw_line2D+0x134>
      et024006_DrawLine(round(p1->x), round(p1->y), round(p2->x), round(p2->y), BLACK);
80002f56:	0c 9a       	mov	r10,r6
80002f58:	0e 9b       	mov	r11,r7
80002f5a:	f0 1f 00 1e 	mcall	80002fd0 <draw_line2D+0x144>
80002f5e:	14 96       	mov	r6,r10
80002f60:	16 97       	mov	r7,r11
80002f62:	fa ea 00 00 	ld.d	r10,sp[0]
80002f66:	f0 1f 00 1b 	mcall	80002fd0 <draw_line2D+0x144>
80002f6a:	14 94       	mov	r4,r10
80002f6c:	16 95       	mov	r5,r11
80002f6e:	00 9a       	mov	r10,r0
80002f70:	02 9b       	mov	r11,r1
80002f72:	f0 1f 00 18 	mcall	80002fd0 <draw_line2D+0x144>
80002f76:	14 90       	mov	r0,r10
80002f78:	16 91       	mov	r1,r11
80002f7a:	04 9a       	mov	r10,r2
80002f7c:	06 9b       	mov	r11,r3
80002f7e:	f0 1f 00 15 	mcall	80002fd0 <draw_line2D+0x144>
80002f82:	14 92       	mov	r2,r10
80002f84:	16 93       	mov	r3,r11
80002f86:	0c 9a       	mov	r10,r6
80002f88:	0e 9b       	mov	r11,r7
80002f8a:	f0 1f 00 13 	mcall	80002fd4 <draw_line2D+0x148>
80002f8e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
80002f92:	08 9a       	mov	r10,r4
80002f94:	0a 9b       	mov	r11,r5
80002f96:	f0 1f 00 10 	mcall	80002fd4 <draw_line2D+0x148>
80002f9a:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
80002f9e:	00 9a       	mov	r10,r0
80002fa0:	02 9b       	mov	r11,r1
80002fa2:	f0 1f 00 0d 	mcall	80002fd4 <draw_line2D+0x148>
80002fa6:	ef dc c0 10 	bfextu	r7,r12,0x0,0x10
80002faa:	04 9a       	mov	r10,r2
80002fac:	06 9b       	mov	r11,r3
80002fae:	f0 1f 00 0a 	mcall	80002fd4 <draw_line2D+0x148>
80002fb2:	30 08       	mov	r8,0
80002fb4:	0c 99       	mov	r9,r6
80002fb6:	0a 9a       	mov	r10,r5
80002fb8:	0e 9b       	mov	r11,r7
80002fba:	5c 7c       	castu.h	r12
80002fbc:	f0 1f 00 07 	mcall	80002fd8 <draw_line2D+0x14c>
    }
  }
}
80002fc0:	2f ed       	sub	sp,-8
80002fc2:	d8 32       	popm	r0-r7,pc
80002fc4:	80 00       	ld.sh	r0,r0[0x0]
80002fc6:	52 10       	stdsp	sp[0x84],r0
80002fc8:	80 00       	ld.sh	r0,r0[0x0]
80002fca:	58 4c       	cp.w	r12,4
80002fcc:	80 00       	ld.sh	r0,r0[0x0]
80002fce:	51 40       	stdsp	sp[0x50],r0
80002fd0:	80 00       	ld.sh	r0,r0[0x0]
80002fd2:	37 40       	mov	r0,116
80002fd4:	80 00       	ld.sh	r0,r0[0x0]
80002fd6:	50 08       	stdsp	sp[0x0],r8
80002fd8:	80 00       	ld.sh	r0,r0[0x0]
80002fda:	23 0c       	sub	r12,48

80002fdc <draw_point2D>:
  //   draw_line2D(&p[i][0], &p[i][1]);
  //   draw_point2D(&p[i][1]);
  //   delay_ms(100);
  // }
}
void draw_point2D(point2D * p){
80002fdc:	eb cd 40 f8 	pushm	r3-r7,lr
80002fe0:	18 97       	mov	r7,r12
  if (p->x >= 0.0 && p->x <= 320.4 && p->y >= 0.0 && p->y <= 240.4){
80002fe2:	78 05       	ld.w	r5,r12[0x0]
80002fe4:	30 0b       	mov	r11,0
80002fe6:	0a 9c       	mov	r12,r5
80002fe8:	f0 1f 00 29 	mcall	8000308c <draw_point2D+0xb0>
80002fec:	c4 e0       	breq	80003088 <draw_point2D+0xac>
80002fee:	0a 9c       	mov	r12,r5
80002ff0:	f0 1f 00 28 	mcall	80003090 <draw_point2D+0xb4>
80002ff4:	14 94       	mov	r4,r10
80002ff6:	16 95       	mov	r5,r11
80002ff8:	14 98       	mov	r8,r10
80002ffa:	0a 99       	mov	r9,r5
80002ffc:	e0 6a 66 66 	mov	r10,26214
80003000:	ea 1a 66 66 	orh	r10,0x6666
80003004:	e0 6b 06 66 	mov	r11,1638
80003008:	ea 1b 40 74 	orh	r11,0x4074
8000300c:	f0 1f 00 22 	mcall	80003094 <draw_point2D+0xb8>
80003010:	c3 c0       	breq	80003088 <draw_point2D+0xac>
80003012:	6e 17       	ld.w	r7,r7[0x4]
80003014:	30 0b       	mov	r11,0
80003016:	0e 9c       	mov	r12,r7
80003018:	f0 1f 00 1d 	mcall	8000308c <draw_point2D+0xb0>
8000301c:	c3 60       	breq	80003088 <draw_point2D+0xac>
8000301e:	0e 9c       	mov	r12,r7
80003020:	f0 1f 00 1c 	mcall	80003090 <draw_point2D+0xb4>
80003024:	14 96       	mov	r6,r10
80003026:	16 97       	mov	r7,r11
80003028:	14 98       	mov	r8,r10
8000302a:	0e 99       	mov	r9,r7
8000302c:	e0 6a cc cd 	mov	r10,52429
80003030:	ea 1a cc cc 	orh	r10,0xcccc
80003034:	e0 6b 0c cc 	mov	r11,3276
80003038:	ea 1b 40 6e 	orh	r11,0x406e
8000303c:	f0 1f 00 16 	mcall	80003094 <draw_point2D+0xb8>
80003040:	c2 40       	breq	80003088 <draw_point2D+0xac>
    et024006_DrawPixel( round(p->x), round(p->y), color16(63,000,63));
80003042:	33 fa       	mov	r10,63
80003044:	30 0b       	mov	r11,0
80003046:	14 9c       	mov	r12,r10
80003048:	f0 1f 00 14 	mcall	80003098 <draw_point2D+0xbc>
8000304c:	e7 dc b0 10 	bfexts	r3,r12,0x0,0x10
80003050:	0c 9a       	mov	r10,r6
80003052:	0e 9b       	mov	r11,r7
80003054:	f0 1f 00 12 	mcall	8000309c <draw_point2D+0xc0>
80003058:	14 96       	mov	r6,r10
8000305a:	16 97       	mov	r7,r11
8000305c:	08 9a       	mov	r10,r4
8000305e:	0a 9b       	mov	r11,r5
80003060:	f0 1f 00 0f 	mcall	8000309c <draw_point2D+0xc0>
80003064:	14 94       	mov	r4,r10
80003066:	16 95       	mov	r5,r11
80003068:	5c 73       	castu.h	r3
8000306a:	0c 9a       	mov	r10,r6
8000306c:	0e 9b       	mov	r11,r7
8000306e:	f0 1f 00 0d 	mcall	800030a0 <draw_point2D+0xc4>
80003072:	ef dc c0 10 	bfextu	r7,r12,0x0,0x10
80003076:	08 9a       	mov	r10,r4
80003078:	0a 9b       	mov	r11,r5
8000307a:	f0 1f 00 0a 	mcall	800030a0 <draw_point2D+0xc4>
8000307e:	06 9a       	mov	r10,r3
80003080:	0e 9b       	mov	r11,r7
80003082:	5c 7c       	castu.h	r12
80003084:	f0 1f 00 08 	mcall	800030a4 <draw_point2D+0xc8>
80003088:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000308c:	80 00       	ld.sh	r0,r0[0x0]
8000308e:	52 10       	stdsp	sp[0x84],r0
80003090:	80 00       	ld.sh	r0,r0[0x0]
80003092:	58 4c       	cp.w	r12,4
80003094:	80 00       	ld.sh	r0,r0[0x0]
80003096:	51 40       	stdsp	sp[0x50],r0
80003098:	80 00       	ld.sh	r0,r0[0x0]
8000309a:	2d e0       	sub	r0,-34
8000309c:	80 00       	ld.sh	r0,r0[0x0]
8000309e:	37 40       	mov	r0,116
800030a0:	80 00       	ld.sh	r0,r0[0x0]
800030a2:	50 08       	stdsp	sp[0x0],r8
800030a4:	80 00       	ld.sh	r0,r0[0x0]
800030a6:	20 58       	sub	r8,5

800030a8 <draw_impossible_polygon>:
    rotation += 1;
    delay_ms(33);
  }
}

void draw_impossible_polygon(uint8_t n, point2D * center, float radius, float rotation){
800030a8:	d4 31       	pushm	r0-r7,lr
800030aa:	1a 97       	mov	r7,sp
800030ac:	21 6d       	sub	sp,88
800030ae:	16 93       	mov	r3,r11
800030b0:	ef 4a ff c8 	st.w	r7[-56],r10
800030b4:	ef 49 ff d4 	st.w	r7[-44],r9
  //   p[i][2].y = p[i][1].y + 2.5*radius * cos(to_rad(angle));
  //   draw_line2D(&p[i][0], &p[i][1]);
  //   draw_point2D(&p[i][1]);
  //   delay_ms(100);
  // }
}
800030b8:	ef 4d ff fc 	st.w	r7[-4],sp
    delay_ms(33);
  }
}

void draw_impossible_polygon(uint8_t n, point2D * center, float radius, float rotation){
  float center_angle = 360.0/n;
800030bc:	18 94       	mov	r4,r12
800030be:	f0 1f 00 dc 	mcall	8000342c <draw_impossible_polygon+0x384>
800030c2:	ee eb ff b4 	st.d	r7[-76],r10
800030c6:	14 98       	mov	r8,r10
800030c8:	16 99       	mov	r9,r11
800030ca:	30 0a       	mov	r10,0
800030cc:	e0 6b 80 00 	mov	r11,32768
800030d0:	ea 1b 40 76 	orh	r11,0x4076
800030d4:	f0 1f 00 d7 	mcall	80003430 <draw_impossible_polygon+0x388>
800030d8:	f0 1f 00 d7 	mcall	80003434 <draw_impossible_polygon+0x38c>
800030dc:	ef 4c ff e4 	st.w	r7[-28],r12
  float corner_angle = (180.0 - center_angle)/2;
800030e0:	f0 1f 00 d6 	mcall	80003438 <draw_impossible_polygon+0x390>
800030e4:	14 98       	mov	r8,r10
800030e6:	16 99       	mov	r9,r11
800030e8:	30 0a       	mov	r10,0
800030ea:	e0 6b 80 00 	mov	r11,32768
800030ee:	ea 1b 40 66 	orh	r11,0x4066
800030f2:	f0 1f 00 d3 	mcall	8000343c <draw_impossible_polygon+0x394>
800030f6:	30 08       	mov	r8,0
800030f8:	fc 19 3f e0 	movh	r9,0x3fe0
800030fc:	f0 1f 00 d1 	mcall	80003440 <draw_impossible_polygon+0x398>
80003100:	f0 1f 00 cd 	mcall	80003434 <draw_impossible_polygon+0x38c>
80003104:	ef 4c ff e0 	st.w	r7[-32],r12
  //initial points
  point2D p[n][4];
80003108:	e8 08 15 05 	lsl	r8,r4,0x5
8000310c:	2f c8       	sub	r8,-4
8000310e:	10 1d       	sub	sp,r8
80003110:	ef 4d ff f8 	st.w	r7[-8],sp
80003114:	ef 4d ff dc 	st.w	r7[-36],sp
  for (int i=0; i<n; i++){
80003118:	58 04       	cp.w	r4,0
8000311a:	e0 8a 00 77 	brle	80003208 <draw_impossible_polygon+0x160>
8000311e:	1a 95       	mov	r5,sp
80003120:	30 06       	mov	r6,0
    p[i][0].x = center->x + radius * sin(to_rad((i*360.0)/n + rotation));
80003122:	ef 4d ff d0 	st.w	r7[-48],sp
80003126:	ef 44 ff c4 	st.w	r7[-60],r4
8000312a:	06 94       	mov	r4,r3
8000312c:	ee fc ff c8 	ld.w	r12,r7[-56]
80003130:	f0 1f 00 c2 	mcall	80003438 <draw_impossible_polygon+0x390>
80003134:	ee eb ff bc 	st.d	r7[-68],r10
80003138:	0c 9c       	mov	r12,r6
8000313a:	f0 1f 00 bd 	mcall	8000342c <draw_impossible_polygon+0x384>
8000313e:	30 08       	mov	r8,0
80003140:	e0 69 80 00 	mov	r9,32768
80003144:	ea 19 40 76 	orh	r9,0x4076
80003148:	f0 1f 00 be 	mcall	80003440 <draw_impossible_polygon+0x398>
8000314c:	ee e8 ff b4 	ld.d	r8,r7[-76]
80003150:	f0 1f 00 b8 	mcall	80003430 <draw_impossible_polygon+0x388>
80003154:	14 92       	mov	r2,r10
80003156:	16 93       	mov	r3,r11
80003158:	ee fc ff d4 	ld.w	r12,r7[-44]
8000315c:	f0 1f 00 b7 	mcall	80003438 <draw_impossible_polygon+0x390>
80003160:	14 98       	mov	r8,r10
80003162:	16 99       	mov	r9,r11
80003164:	04 9a       	mov	r10,r2
80003166:	06 9b       	mov	r11,r3
80003168:	f0 1f 00 b7 	mcall	80003444 <draw_impossible_polygon+0x39c>
8000316c:	f0 1f 00 b2 	mcall	80003434 <draw_impossible_polygon+0x38c>
80003170:	f0 1f 00 b6 	mcall	80003448 <draw_impossible_polygon+0x3a0>
80003174:	f0 1f 00 b1 	mcall	80003438 <draw_impossible_polygon+0x390>
80003178:	14 90       	mov	r0,r10
8000317a:	16 91       	mov	r1,r11
8000317c:	f0 1f 00 b4 	mcall	8000344c <draw_impossible_polygon+0x3a4>
80003180:	ee eb ff ac 	st.d	r7[-84],r10
80003184:	68 0c       	ld.w	r12,r4[0x0]
80003186:	f0 1f 00 ad 	mcall	80003438 <draw_impossible_polygon+0x390>
8000318a:	14 92       	mov	r2,r10
8000318c:	16 93       	mov	r3,r11
8000318e:	ee e8 ff ac 	ld.d	r8,r7[-84]
80003192:	ee ea ff bc 	ld.d	r10,r7[-68]
80003196:	f0 1f 00 ab 	mcall	80003440 <draw_impossible_polygon+0x398>
8000319a:	14 98       	mov	r8,r10
8000319c:	16 99       	mov	r9,r11
8000319e:	04 9a       	mov	r10,r2
800031a0:	06 9b       	mov	r11,r3
800031a2:	f0 1f 00 a9 	mcall	80003444 <draw_impossible_polygon+0x39c>
800031a6:	f0 1f 00 a4 	mcall	80003434 <draw_impossible_polygon+0x38c>
800031aa:	ee f9 ff d0 	ld.w	r9,r7[-48]
800031ae:	93 0c       	st.w	r9[0x0],r12
    p[i][0].y = center->y + radius * cos(to_rad((i*360.0)/n + rotation));
800031b0:	00 9a       	mov	r10,r0
800031b2:	02 9b       	mov	r11,r1
800031b4:	f0 1f 00 a7 	mcall	80003450 <draw_impossible_polygon+0x3a8>
800031b8:	14 90       	mov	r0,r10
800031ba:	16 91       	mov	r1,r11
800031bc:	68 1c       	ld.w	r12,r4[0x4]
800031be:	f0 1f 00 9f 	mcall	80003438 <draw_impossible_polygon+0x390>
800031c2:	14 92       	mov	r2,r10
800031c4:	16 93       	mov	r3,r11
800031c6:	00 98       	mov	r8,r0
800031c8:	02 99       	mov	r9,r1
800031ca:	ee ea ff bc 	ld.d	r10,r7[-68]
800031ce:	f0 1f 00 9d 	mcall	80003440 <draw_impossible_polygon+0x398>
800031d2:	14 98       	mov	r8,r10
800031d4:	16 99       	mov	r9,r11
800031d6:	04 9a       	mov	r10,r2
800031d8:	06 9b       	mov	r11,r3
800031da:	f0 1f 00 9b 	mcall	80003444 <draw_impossible_polygon+0x39c>
800031de:	f0 1f 00 96 	mcall	80003434 <draw_impossible_polygon+0x38c>
800031e2:	ee f8 ff d0 	ld.w	r8,r7[-48]
800031e6:	91 1c       	st.w	r8[0x4],r12
    draw_point2D(&p[i][0]);
800031e8:	0a 9c       	mov	r12,r5
800031ea:	f0 1f 00 9b 	mcall	80003454 <draw_impossible_polygon+0x3ac>
void draw_impossible_polygon(uint8_t n, point2D * center, float radius, float rotation){
  float center_angle = 360.0/n;
  float corner_angle = (180.0 - center_angle)/2;
  //initial points
  point2D p[n][4];
  for (int i=0; i<n; i++){
800031ee:	2f f6       	sub	r6,-1
800031f0:	ee f9 ff d0 	ld.w	r9,r7[-48]
800031f4:	2e 09       	sub	r9,-32
800031f6:	ef 49 ff d0 	st.w	r7[-48],r9
800031fa:	2e 05       	sub	r5,-32
800031fc:	ee f8 ff c4 	ld.w	r8,r7[-60]
80003200:	0c 38       	cp.w	r8,r6
80003202:	fe 99 ff 95 	brgt	8000312c <draw_impossible_polygon+0x84>
80003206:	10 94       	mov	r4,r8
80003208:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000320c:	ef 49 ff e8 	st.w	r7[-24],r9
80003210:	30 08       	mov	r8,0
80003212:	ef 48 ff d8 	st.w	r7[-40],r8
80003216:	30 19       	mov	r9,1
80003218:	ef 49 ff d0 	st.w	r7[-48],r9
  }

  for (int j=1; j<4; j++){
    for (int i=0; i<n; i++){
      float angle = (center_angle * (i + j) + corner_angle) ;
      float dp = euclidian_distance(&p[i][j-1], &p[(i+1)%n][j-1]);
8000321c:	ee f8 ff dc 	ld.w	r8,r7[-36]
80003220:	ef 48 ff f0 	st.w	r7[-16],r8
      if (j==3)
        dp = euclidian_distance(&p[i][j-2], &p[(i+1)%n][j-2]) *0.83/(1+(n-2)/15.0);
80003224:	e8 c9 00 02 	sub	r9,r4,2
80003228:	ef 49 ff f4 	st.w	r7[-12],r9
8000322c:	08 91       	mov	r1,r4
8000322e:	cc 88       	rjmp	800033be <draw_impossible_polygon+0x316>
  }

  for (int j=1; j<4; j++){
    for (int i=0; i<n; i++){
      float angle = (center_angle * (i + j) + corner_angle) ;
      float dp = euclidian_distance(&p[i][j-1], &p[(i+1)%n][j-1]);
80003230:	2f f5       	sub	r5,-1
80003232:	ea 01 0c 08 	divs	r8,r5,r1
80003236:	12 90       	mov	r0,r9
80003238:	ef 46 ff c4 	st.w	r7[-60],r6
8000323c:	ee f8 ff d8 	ld.w	r8,r7[-40]
80003240:	f0 00 00 2b 	add	r11,r8,r0<<0x2
80003244:	ee f9 ff dc 	ld.w	r9,r7[-36]
80003248:	f2 0b 00 3b 	add	r11,r9,r11<<0x3
8000324c:	0c 9c       	mov	r12,r6
8000324e:	f0 1f 00 83 	mcall	80003458 <draw_impossible_polygon+0x3b0>
      if (j==3)
80003252:	ee f8 ff d0 	ld.w	r8,r7[-48]
80003256:	58 38       	cp.w	r8,3
80003258:	c3 21       	brne	800032bc <draw_impossible_polygon+0x214>
        dp = euclidian_distance(&p[i][j-2], &p[(i+1)%n][j-2]) *0.83/(1+(n-2)/15.0);
8000325a:	e0 0b 15 02 	lsl	r11,r0,0x2
8000325e:	20 2b       	sub	r11,2
80003260:	ee f9 ff ec 	ld.w	r9,r7[-20]
80003264:	12 0b       	add	r11,r9
80003266:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000326a:	f0 0b 00 3b 	add	r11,r8,r11<<0x3
8000326e:	04 9c       	mov	r12,r2
80003270:	f0 1f 00 7a 	mcall	80003458 <draw_impossible_polygon+0x3b0>
80003274:	f0 1f 00 71 	mcall	80003438 <draw_impossible_polygon+0x390>
80003278:	e0 68 c2 8f 	mov	r8,49807
8000327c:	ea 18 28 f5 	orh	r8,0x28f5
80003280:	e0 69 8f 5c 	mov	r9,36700
80003284:	ea 19 3f ea 	orh	r9,0x3fea
80003288:	f0 1f 00 6e 	mcall	80003440 <draw_impossible_polygon+0x398>
8000328c:	ee eb ff bc 	st.d	r7[-68],r10
80003290:	ee fc ff f4 	ld.w	r12,r7[-12]
80003294:	f0 1f 00 66 	mcall	8000342c <draw_impossible_polygon+0x384>
80003298:	30 08       	mov	r8,0
8000329a:	fc 19 40 2e 	movh	r9,0x402e
8000329e:	f0 1f 00 65 	mcall	80003430 <draw_impossible_polygon+0x388>
800032a2:	30 08       	mov	r8,0
800032a4:	fc 19 3f f0 	movh	r9,0x3ff0
800032a8:	f0 1f 00 67 	mcall	80003444 <draw_impossible_polygon+0x39c>
800032ac:	14 98       	mov	r8,r10
800032ae:	16 99       	mov	r9,r11
800032b0:	ee ea ff bc 	ld.d	r10,r7[-68]
800032b4:	f0 1f 00 5f 	mcall	80003430 <draw_impossible_polygon+0x388>
800032b8:	f0 1f 00 5f 	mcall	80003434 <draw_impossible_polygon+0x38c>
      p[i][j].x = p[i][j-1].x + 1.2*dp * sin(to_rad(angle + rotation));
800032bc:	f0 1f 00 5f 	mcall	80003438 <draw_impossible_polygon+0x390>
800032c0:	e0 68 33 33 	mov	r8,13107
800032c4:	ea 18 33 33 	orh	r8,0x3333
800032c8:	e0 69 33 33 	mov	r9,13107
800032cc:	ea 19 3f f3 	orh	r9,0x3ff3
800032d0:	f0 1f 00 5c 	mcall	80003440 <draw_impossible_polygon+0x398>
800032d4:	ee eb ff bc 	st.d	r7[-68],r10
800032d8:	06 9c       	mov	r12,r3
800032da:	f0 1f 00 61 	mcall	8000345c <draw_impossible_polygon+0x3b4>
800032de:	ee fb ff e4 	ld.w	r11,r7[-28]
800032e2:	f0 1f 00 60 	mcall	80003460 <draw_impossible_polygon+0x3b8>
800032e6:	ee fb ff e0 	ld.w	r11,r7[-32]
800032ea:	f0 1f 00 5f 	mcall	80003464 <draw_impossible_polygon+0x3bc>
800032ee:	ee fb ff d4 	ld.w	r11,r7[-44]
800032f2:	f0 1f 00 5d 	mcall	80003464 <draw_impossible_polygon+0x3bc>
800032f6:	f0 1f 00 55 	mcall	80003448 <draw_impossible_polygon+0x3a0>
800032fa:	f0 1f 00 50 	mcall	80003438 <draw_impossible_polygon+0x390>
800032fe:	ee eb ff b4 	st.d	r7[-76],r10
80003302:	f0 1f 00 53 	mcall	8000344c <draw_impossible_polygon+0x3a4>
80003306:	ee eb ff ac 	st.d	r7[-84],r10
8000330a:	ee f9 ff a8 	ld.w	r9,r7[-88]
8000330e:	72 0c       	ld.w	r12,r9[0x0]
80003310:	f0 1f 00 4a 	mcall	80003438 <draw_impossible_polygon+0x390>
80003314:	ee eb ff c8 	st.d	r7[-56],r10
80003318:	ee e8 ff ac 	ld.d	r8,r7[-84]
8000331c:	ee ea ff bc 	ld.d	r10,r7[-68]
80003320:	f0 1f 00 48 	mcall	80003440 <draw_impossible_polygon+0x398>
80003324:	14 98       	mov	r8,r10
80003326:	16 99       	mov	r9,r11
80003328:	ee ea ff c8 	ld.d	r10,r7[-56]
8000332c:	f0 1f 00 46 	mcall	80003444 <draw_impossible_polygon+0x39c>
80003330:	f0 1f 00 41 	mcall	80003434 <draw_impossible_polygon+0x38c>
80003334:	ee f8 ff a8 	ld.w	r8,r7[-88]
80003338:	91 2c       	st.w	r8[0x8],r12
      p[i][j].y = p[i][j-1].y + 1.2*dp * cos(to_rad(angle + rotation));
8000333a:	ee ea ff b4 	ld.d	r10,r7[-76]
8000333e:	f0 1f 00 45 	mcall	80003450 <draw_impossible_polygon+0x3a8>
80003342:	ee eb ff ac 	st.d	r7[-84],r10
80003346:	ee f9 ff a8 	ld.w	r9,r7[-88]
8000334a:	72 1c       	ld.w	r12,r9[0x4]
8000334c:	f0 1f 00 3b 	mcall	80003438 <draw_impossible_polygon+0x390>
80003350:	ee eb ff b4 	st.d	r7[-76],r10
80003354:	ee e8 ff ac 	ld.d	r8,r7[-84]
80003358:	ee ea ff bc 	ld.d	r10,r7[-68]
8000335c:	f0 1f 00 39 	mcall	80003440 <draw_impossible_polygon+0x398>
80003360:	14 98       	mov	r8,r10
80003362:	16 99       	mov	r9,r11
80003364:	ee ea ff b4 	ld.d	r10,r7[-76]
80003368:	f0 1f 00 37 	mcall	80003444 <draw_impossible_polygon+0x39c>
8000336c:	f0 1f 00 32 	mcall	80003434 <draw_impossible_polygon+0x38c>
80003370:	ee f8 ff a8 	ld.w	r8,r7[-88]
80003374:	91 3c       	st.w	r8[0xc],r12
      draw_line2D(&p[i][j-1], &p[i][j]);
80003376:	08 9b       	mov	r11,r4
80003378:	ee fc ff c4 	ld.w	r12,r7[-60]
8000337c:	f0 1f 00 3b 	mcall	80003468 <draw_impossible_polygon+0x3c0>
80003380:	2e 06       	sub	r6,-32
80003382:	ee f9 ff a8 	ld.w	r9,r7[-88]
80003386:	2e 09       	sub	r9,-32
80003388:	ef 49 ff a8 	st.w	r7[-88],r9
8000338c:	2f f3       	sub	r3,-1
8000338e:	2e 04       	sub	r4,-32
80003390:	2e 02       	sub	r2,-32
    p[i][0].y = center->y + radius * cos(to_rad((i*360.0)/n + rotation));
    draw_point2D(&p[i][0]);
  }

  for (int j=1; j<4; j++){
    for (int i=0; i<n; i++){
80003392:	0a 31       	cp.w	r1,r5
80003394:	fe 99 ff 4e 	brgt	80003230 <draw_impossible_polygon+0x188>
    p[i][0].x = center->x + radius * sin(to_rad((i*360.0)/n + rotation));
    p[i][0].y = center->y + radius * cos(to_rad((i*360.0)/n + rotation));
    draw_point2D(&p[i][0]);
  }

  for (int j=1; j<4; j++){
80003398:	ee f8 ff d0 	ld.w	r8,r7[-48]
8000339c:	2f f8       	sub	r8,-1
8000339e:	ef 48 ff d0 	st.w	r7[-48],r8
800033a2:	ee f9 ff d8 	ld.w	r9,r7[-40]
800033a6:	2f f9       	sub	r9,-1
800033a8:	ef 49 ff d8 	st.w	r7[-40],r9
800033ac:	ee f8 ff e8 	ld.w	r8,r7[-24]
800033b0:	2f 88       	sub	r8,-8
800033b2:	ef 48 ff e8 	st.w	r7[-24],r8
800033b6:	ee f9 ff d0 	ld.w	r9,r7[-48]
800033ba:	58 49       	cp.w	r9,4
800033bc:	c1 b0       	breq	800033f2 <draw_impossible_polygon+0x34a>
    for (int i=0; i<n; i++){
800033be:	58 01       	cp.w	r1,0
800033c0:	fe 9a ff ec 	brle	80003398 <draw_impossible_polygon+0x2f0>
800033c4:	ee f8 ff d8 	ld.w	r8,r7[-40]
800033c8:	ee f9 ff dc 	ld.w	r9,r7[-36]
800033cc:	f2 08 00 30 	add	r0,r9,r8<<0x3
800033d0:	ee f8 ff d0 	ld.w	r8,r7[-48]
800033d4:	ef 48 ff ec 	st.w	r7[-20],r8
800033d8:	ee f4 ff e8 	ld.w	r4,r7[-24]
800033dc:	2f 84       	sub	r4,-8
800033de:	ee f2 ff e8 	ld.w	r2,r7[-24]
800033e2:	20 82       	sub	r2,8
800033e4:	10 93       	mov	r3,r8
800033e6:	ee f6 ff e8 	ld.w	r6,r7[-24]
800033ea:	30 05       	mov	r5,0
800033ec:	ef 40 ff a8 	st.w	r7[-88],r0
800033f0:	c2 0b       	rjmp	80003230 <draw_impossible_polygon+0x188>
800033f2:	02 94       	mov	r4,r1
      p[i][j].x = p[i][j-1].x + 1.2*dp * sin(to_rad(angle + rotation));
      p[i][j].y = p[i][j-1].y + 1.2*dp * cos(to_rad(angle + rotation));
      draw_line2D(&p[i][j-1], &p[i][j]);
    }
  }
  for (int i=0; i<n; i++){
800033f4:	58 01       	cp.w	r1,0
800033f6:	e0 8a 00 16 	brle	80003422 <draw_impossible_polygon+0x37a>
800033fa:	ee f6 ff f8 	ld.w	r6,r7[-8]
800033fe:	2e 86       	sub	r6,-24
80003400:	30 03       	mov	r3,0
80003402:	ee f5 ff dc 	ld.w	r5,r7[-36]
    draw_line2D(&p[i][3], &p[(i+1)%n][2]);
80003406:	2f f3       	sub	r3,-1
80003408:	e6 04 0c 0a 	divs	r10,r3,r4
8000340c:	a5 7b       	lsl	r11,0x5
8000340e:	2f 0b       	sub	r11,-16
80003410:	ea 0b 00 0b 	add	r11,r5,r11
80003414:	0c 9c       	mov	r12,r6
80003416:	f0 1f 00 15 	mcall	80003468 <draw_impossible_polygon+0x3c0>
8000341a:	2e 06       	sub	r6,-32
      p[i][j].x = p[i][j-1].x + 1.2*dp * sin(to_rad(angle + rotation));
      p[i][j].y = p[i][j-1].y + 1.2*dp * cos(to_rad(angle + rotation));
      draw_line2D(&p[i][j-1], &p[i][j]);
    }
  }
  for (int i=0; i<n; i++){
8000341c:	06 34       	cp.w	r4,r3
8000341e:	fe 99 ff f4 	brgt	80003406 <draw_impossible_polygon+0x35e>
  //   p[i][2].y = p[i][1].y + 2.5*radius * cos(to_rad(angle));
  //   draw_line2D(&p[i][0], &p[i][1]);
  //   draw_point2D(&p[i][1]);
  //   delay_ms(100);
  // }
}
80003422:	ee fd ff fc 	ld.w	sp,r7[-4]
80003426:	2e ad       	sub	sp,-88
80003428:	d8 32       	popm	r0-r7,pc
8000342a:	00 00       	add	r0,r0
8000342c:	80 00       	ld.sh	r0,r0[0x0]
8000342e:	50 3a       	stdsp	sp[0xc],r10
80003430:	80 00       	ld.sh	r0,r0[0x0]
80003432:	52 44       	stdsp	sp[0x90],r4
80003434:	80 00       	ld.sh	r0,r0[0x0]
80003436:	58 ac       	cp.w	r12,10
80003438:	80 00       	ld.sh	r0,r0[0x0]
8000343a:	58 4c       	cp.w	r12,4
8000343c:	80 00       	ld.sh	r0,r0[0x0]
8000343e:	4d 5c       	lddpc	r12,80003590 <main+0x40>
80003440:	80 00       	ld.sh	r0,r0[0x0]
80003442:	4b 84       	lddpc	r4,80003520 <act14+0xb4>
80003444:	80 00       	ld.sh	r0,r0[0x0]
80003446:	4e f8       	lddpc	r8,80003600 <main+0xb0>
80003448:	80 00       	ld.sh	r0,r0[0x0]
8000344a:	2d ec       	sub	r12,-34
8000344c:	80 00       	ld.sh	r0,r0[0x0]
8000344e:	37 f0       	mov	r0,127
80003450:	80 00       	ld.sh	r0,r0[0x0]
80003452:	36 b8       	mov	r8,107
80003454:	80 00       	ld.sh	r0,r0[0x0]
80003456:	2f dc       	sub	r12,-3
80003458:	80 00       	ld.sh	r0,r0[0x0]
8000345a:	2e 2c       	sub	r12,-30
8000345c:	80 00       	ld.sh	r0,r0[0x0]
8000345e:	57 be       	stdsp	sp[0x1ec],lr
80003460:	80 00       	ld.sh	r0,r0[0x0]
80003462:	56 dc       	stdsp	sp[0x1b4],r12
80003464:	80 00       	ld.sh	r0,r0[0x0]
80003466:	56 30       	stdsp	sp[0x18c],r0
80003468:	80 00       	ld.sh	r0,r0[0x0]
8000346a:	2e 8c       	sub	r12,-24

8000346c <act14>:
void draw_point2D(point2D * p);
void draw_line2D(point2D * p1, point2D * p2);
float euclidian_distance(point2D * p1, point2D * p2);
float to_deg(float radians);
float to_rad(float degrees);
void act14(void){
8000346c:	d4 31       	pushm	r0-r7,lr
  et024006_DrawFilledRect(0, 0, ET024006_WIDTH, ET024006_HEIGHT, WHITE);
8000346e:	e0 68 ff ff 	mov	r8,65535
80003472:	e0 69 00 f0 	mov	r9,240
80003476:	e0 6a 01 40 	mov	r10,320
8000347a:	30 0b       	mov	r11,0
8000347c:	16 9c       	mov	r12,r11
8000347e:	f0 1f 00 2f 	mcall	80003538 <act14+0xcc>
  uint8_t total_polygons = 3;
  point2D center[total_polygons];
80003482:	20 7d       	sub	sp,28
80003484:	1a 93       	mov	r3,sp
80003486:	1a 92       	mov	r2,sp
80003488:	1a 96       	mov	r6,sp
8000348a:	e0 67 01 40 	mov	r7,320
  for(int i = 0; i<total_polygons; i++){
    center[i].x = (i+1) * ET024006_WIDTH/(total_polygons+1);
    center[i].y = ET024006_HEIGHT/2;
8000348e:	fc 15 42 f0 	movh	r5,0x42f0
void act14(void){
  et024006_DrawFilledRect(0, 0, ET024006_WIDTH, ET024006_HEIGHT, WHITE);
  uint8_t total_polygons = 3;
  point2D center[total_polygons];
  for(int i = 0; i<total_polygons; i++){
    center[i].x = (i+1) * ET024006_WIDTH/(total_polygons+1);
80003492:	0e 9c       	mov	r12,r7
80003494:	58 07       	cp.w	r7,0
80003496:	f7 bc 05 fd 	sublt	r12,-3
8000349a:	a3 4c       	asr	r12,0x2
8000349c:	f0 1f 00 28 	mcall	8000353c <act14+0xd0>
800034a0:	8d 0c       	st.w	r6[0x0],r12
    center[i].y = ET024006_HEIGHT/2;
800034a2:	8d 15       	st.w	r6[0x4],r5
800034a4:	ee c7 fe c0 	sub	r7,r7,-320
800034a8:	2f 86       	sub	r6,-8
float to_rad(float degrees);
void act14(void){
  et024006_DrawFilledRect(0, 0, ET024006_WIDTH, ET024006_HEIGHT, WHITE);
  uint8_t total_polygons = 3;
  point2D center[total_polygons];
  for(int i = 0; i<total_polygons; i++){
800034aa:	e0 47 05 00 	cp.w	r7,1280
800034ae:	cf 21       	brne	80003492 <act14+0x26>
800034b0:	30 05       	mov	r5,0
800034b2:	30 04       	mov	r4,0
  }
  float rotation = 0.0;
  while(1){

    for(int i = 0; i<total_polygons; i++){
      et024006_DrawFilledRect(center[i].x-(ET024006_WIDTH/total_polygons+1)/2, 0, ET024006_WIDTH/total_polygons+1, ET024006_HEIGHT, WHITE);
800034b4:	fc 11 42 54 	movh	r1,0x4254
800034b8:	e0 60 ff ff 	mov	r0,65535
float to_rad(float degrees);
void act14(void){
  et024006_DrawFilledRect(0, 0, ET024006_WIDTH, ET024006_HEIGHT, WHITE);
  uint8_t total_polygons = 3;
  point2D center[total_polygons];
  for(int i = 0; i<total_polygons; i++){
800034bc:	30 f6       	mov	r6,15
800034be:	08 97       	mov	r7,r4
  }
  float rotation = 0.0;
  while(1){

    for(int i = 0; i<total_polygons; i++){
      et024006_DrawFilledRect(center[i].x-(ET024006_WIDTH/total_polygons+1)/2, 0, ET024006_WIDTH/total_polygons+1, ET024006_HEIGHT, WHITE);
800034c0:	02 9b       	mov	r11,r1
800034c2:	e4 07 03 0c 	ld.w	r12,r2[r7]
800034c6:	f0 1f 00 1f 	mcall	80003540 <act14+0xd4>
800034ca:	f0 1f 00 1f 	mcall	80003544 <act14+0xd8>
800034ce:	00 98       	mov	r8,r0
800034d0:	e0 69 00 f0 	mov	r9,240
800034d4:	36 ba       	mov	r10,107
800034d6:	08 9b       	mov	r11,r4
800034d8:	5c 7c       	castu.h	r12
800034da:	f0 1f 00 18 	mcall	80003538 <act14+0xcc>
      draw_impossible_polygon( i+3, &center[i], 18-(total_polygons-i), rotation);
800034de:	0c 9c       	mov	r12,r6
800034e0:	f0 1f 00 17 	mcall	8000353c <act14+0xd0>
800034e4:	0a 99       	mov	r9,r5
800034e6:	18 9a       	mov	r10,r12
800034e8:	e6 07 00 0b 	add	r11,r3,r7
800034ec:	ec cc 00 0c 	sub	r12,r6,12
800034f0:	f0 1f 00 16 	mcall	80003548 <act14+0xdc>
800034f4:	2f 87       	sub	r7,-8
800034f6:	2f f6       	sub	r6,-1
    center[i].y = ET024006_HEIGHT/2;
  }
  float rotation = 0.0;
  while(1){

    for(int i = 0; i<total_polygons; i++){
800034f8:	59 87       	cp.w	r7,24
800034fa:	ce 31       	brne	800034c0 <act14+0x54>
      et024006_DrawFilledRect(center[i].x-(ET024006_WIDTH/total_polygons+1)/2, 0, ET024006_WIDTH/total_polygons+1, ET024006_HEIGHT, WHITE);
      draw_impossible_polygon( i+3, &center[i], 18-(total_polygons-i), rotation);
    }
    rotation += 1;
800034fc:	fc 1b 3f 80 	movh	r11,0x3f80
80003500:	0a 9c       	mov	r12,r5
80003502:	f0 1f 00 13 	mcall	8000354c <act14+0xe0>
80003506:	18 95       	mov	r5,r12
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80003508:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
8000350c:	e6 69 0a e0 	mov	r9,396000
80003510:	f0 09 00 0a 	add	r10,r8,r9
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80003514:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80003518:	14 38       	cp.w	r8,r10
8000351a:	e0 88 00 08 	brls	8000352a <act14+0xbe>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
8000351e:	12 38       	cp.w	r8,r9
80003520:	fe 98 ff fa 	brls	80003514 <act14+0xa8>
80003524:	12 3a       	cp.w	r10,r9
80003526:	cc b3       	brcs	800034bc <act14+0x50>
80003528:	cf 6b       	rjmp	80003514 <act14+0xa8>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000352a:	12 38       	cp.w	r8,r9
8000352c:	fe 9b ff c8 	brhi	800034bc <act14+0x50>
80003530:	12 3a       	cp.w	r10,r9
80003532:	cc 53       	brcs	800034bc <act14+0x50>
80003534:	cf 0b       	rjmp	80003514 <act14+0xa8>
80003536:	00 00       	add	r0,r0
80003538:	80 00       	ld.sh	r0,r0[0x0]
8000353a:	24 64       	sub	r4,70
8000353c:	80 00       	ld.sh	r0,r0[0x0]
8000353e:	57 be       	stdsp	sp[0x1ec],lr
80003540:	80 00       	ld.sh	r0,r0[0x0]
80003542:	55 60       	stdsp	sp[0x158],r0
80003544:	80 00       	ld.sh	r0,r0[0x0]
80003546:	58 32       	cp.w	r2,3
80003548:	80 00       	ld.sh	r0,r0[0x0]
8000354a:	30 a8       	mov	r8,10
8000354c:	80 00       	ld.sh	r0,r0[0x0]
8000354e:	56 30       	stdsp	sp[0x18c],r0

80003550 <main>:

}

// Main function
int main(void)
{
80003550:	eb cd 40 c0 	pushm	r6-r7,lr
80003554:	20 4d       	sub	sp,16
  // Set CPU and PBA clock
  pcl_switch_to_osc(PCL_OSC0, FOSC0, OSC0_STARTUP);
80003556:	30 3a       	mov	r10,3
80003558:	e0 6b 1b 00 	mov	r11,6912
8000355c:	ea 1b 00 b7 	orh	r11,0xb7
80003560:	30 0c       	mov	r12,0
80003562:	f0 1f 00 46 	mcall	80003678 <main+0x128>
  gpio_enable_gpio_pin(LED0_GPIO);
80003566:	33 bc       	mov	r12,59
80003568:	f0 1f 00 45 	mcall	8000367c <main+0x12c>
  gpio_enable_gpio_pin(LED1_GPIO);
8000356c:	33 cc       	mov	r12,60
8000356e:	f0 1f 00 44 	mcall	8000367c <main+0x12c>
  gpio_enable_gpio_pin(LED2_GPIO);
80003572:	30 5c       	mov	r12,5
80003574:	f0 1f 00 42 	mcall	8000367c <main+0x12c>
  gpio_enable_gpio_pin(LED3_GPIO);
80003578:	30 6c       	mov	r12,6
8000357a:	f0 1f 00 41 	mcall	8000367c <main+0x12c>
  et024006_Init( FOSC0, FOSC0 );
8000357e:	e0 6b 1b 00 	mov	r11,6912
80003582:	ea 1b 00 b7 	orh	r11,0xb7
80003586:	16 9c       	mov	r12,r11
80003588:	f0 1f 00 3e 	mcall	80003680 <main+0x130>
  pwm_opt_t opt = {
    .diva = 0,
    .divb = 0,
    .prea = 0,
    .preb = 0
  };
8000358c:	30 08       	mov	r8,0
8000358e:	50 08       	stdsp	sp[0x0],r8
80003590:	50 18       	stdsp	sp[0x4],r8
80003592:	50 28       	stdsp	sp[0x8],r8
80003594:	50 38       	stdsp	sp[0xc],r8
   * Chosen MCK_DIV_2
   * CPRD = 12MHz / (60kHz * 2) = 100
   *
   * The duty cycle is 100% (CPRD = CDTY)
   * */
  pwm_init(&opt);
80003596:	1a 9c       	mov	r12,sp
80003598:	f0 1f 00 3b 	mcall	80003684 <main+0x134>
  pwm_channel6.CMR.calg = PWM_MODE_LEFT_ALIGNED;
8000359c:	4b bb       	lddpc	r11,80003688 <main+0x138>
8000359e:	76 08       	ld.w	r8,r11[0x0]
  pwm_channel6.CMR.cpol = PWM_POLARITY_HIGH; //PWM_POLARITY_LOW;//PWM_POLARITY_HIGH;
  pwm_channel6.CMR.cpd = PWM_UPDATE_DUTY;
800035a0:	e0 18 f8 ff 	andl	r8,0xf8ff
  pwm_channel6.CMR.cpre = AVR32_PWM_CMR_CPRE_MCK_DIV_2;
800035a4:	a9 b8       	sbr	r8,0x9
800035a6:	30 19       	mov	r9,1
800035a8:	f1 d9 d0 04 	bfins	r8,r9,0x0,0x4
800035ac:	97 08       	st.w	r11[0x0],r8

  pwm_channel_init(6, &pwm_channel6);
800035ae:	30 6c       	mov	r12,6
800035b0:	f0 1f 00 37 	mcall	8000368c <main+0x13c>
  pwm_start_channels(AVR32_PWM_ENA_CHID6_MASK);
800035b4:	34 0c       	mov	r12,64
800035b6:	f0 1f 00 37 	mcall	80003690 <main+0x140>
  /* PWM is fed by PBA bus clock which is by default the same
   * as the CPU speed. We set a 0 duty cycle and thus keep the
   * display black*/
  tft_bl_init();
  /* Lets do a nice fade in by increasing the duty cycle */
  while(pwm_channel6.cdty < pwm_channel6.cprd)
800035ba:	4b 47       	lddpc	r7,80003688 <main+0x138>
  {
    pwm_channel6.cdty++;
    pwm_channel6.cupd = pwm_channel6.cdty;
    //pwm_channel6.cdty--;
    pwm_async_update_channel(AVR32_PWM_ENA_CHID6, &pwm_channel6);
800035bc:	30 66       	mov	r6,6
800035be:	c1 c8       	rjmp	800035f6 <main+0xa6>
   * display black*/
  tft_bl_init();
  /* Lets do a nice fade in by increasing the duty cycle */
  while(pwm_channel6.cdty < pwm_channel6.cprd)
  {
    pwm_channel6.cdty++;
800035c0:	2f f8       	sub	r8,-1
800035c2:	8f 18       	st.w	r7[0x4],r8
    pwm_channel6.cupd = pwm_channel6.cdty;
800035c4:	8f 48       	st.w	r7[0x10],r8
    //pwm_channel6.cdty--;
    pwm_async_update_channel(AVR32_PWM_ENA_CHID6, &pwm_channel6);
800035c6:	0e 9b       	mov	r11,r7
800035c8:	0c 9c       	mov	r12,r6
800035ca:	f0 1f 00 33 	mcall	80003694 <main+0x144>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800035ce:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800035d2:	f0 ca d1 20 	sub	r10,r8,-12000
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
800035d6:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
800035da:	14 38       	cp.w	r8,r10
800035dc:	e0 88 00 08 	brls	800035ec <main+0x9c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
800035e0:	12 38       	cp.w	r8,r9
800035e2:	fe 98 ff fa 	brls	800035d6 <main+0x86>
800035e6:	12 3a       	cp.w	r10,r9
800035e8:	c0 73       	brcs	800035f6 <main+0xa6>
800035ea:	cf 6b       	rjmp	800035d6 <main+0x86>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
800035ec:	12 38       	cp.w	r8,r9
800035ee:	e0 8b 00 04 	brhi	800035f6 <main+0xa6>
800035f2:	12 3a       	cp.w	r10,r9
800035f4:	cf 12       	brcc	800035d6 <main+0x86>
  /* PWM is fed by PBA bus clock which is by default the same
   * as the CPU speed. We set a 0 duty cycle and thus keep the
   * display black*/
  tft_bl_init();
  /* Lets do a nice fade in by increasing the duty cycle */
  while(pwm_channel6.cdty < pwm_channel6.cprd)
800035f6:	6e 18       	ld.w	r8,r7[0x4]
800035f8:	6e 29       	ld.w	r9,r7[0x8]
800035fa:	12 38       	cp.w	r8,r9
800035fc:	ce 23       	brcs	800035c0 <main+0x70>
    //pwm_channel6.cdty--;
    pwm_async_update_channel(AVR32_PWM_ENA_CHID6, &pwm_channel6);
    delay_ms(1);
  }
  // Clear the display i.e. make it black
  et024006_DrawFilledRect(0 , 0, ET024006_WIDTH, ET024006_HEIGHT, BLACK );
800035fe:	30 08       	mov	r8,0
80003600:	e0 69 00 f0 	mov	r9,240
80003604:	e0 6a 01 40 	mov	r10,320
80003608:	10 9b       	mov	r11,r8
8000360a:	10 9c       	mov	r12,r8
8000360c:	f0 1f 00 23 	mcall	80003698 <main+0x148>
  // Draw the background AVR32 logo.
  // et024006_PutPixmap(avr32_logo, 320, 0, 0, 0, 0, 320, 240);
  // Draw a crossed square.
  et024006_DrawHorizLine(10, 50, 20, BLACK);
80003610:	30 09       	mov	r9,0
80003612:	31 4a       	mov	r10,20
80003614:	33 2b       	mov	r11,50
80003616:	30 ac       	mov	r12,10
80003618:	f0 1f 00 21 	mcall	8000369c <main+0x14c>
  et024006_DrawVertLine(10, 50, 20, BLACK);
8000361c:	30 09       	mov	r9,0
8000361e:	31 4a       	mov	r10,20
80003620:	33 2b       	mov	r11,50
80003622:	30 ac       	mov	r12,10
80003624:	f0 1f 00 1f 	mcall	800036a0 <main+0x150>
  et024006_DrawHorizLine(10, 70, 20, BLACK);
80003628:	30 09       	mov	r9,0
8000362a:	31 4a       	mov	r10,20
8000362c:	34 6b       	mov	r11,70
8000362e:	30 ac       	mov	r12,10
80003630:	f0 1f 00 1b 	mcall	8000369c <main+0x14c>
  et024006_DrawVertLine(30, 50, 20, BLACK);
80003634:	30 09       	mov	r9,0
80003636:	31 4a       	mov	r10,20
80003638:	33 2b       	mov	r11,50
8000363a:	31 ec       	mov	r12,30
8000363c:	f0 1f 00 19 	mcall	800036a0 <main+0x150>
  et024006_DrawLine(10, 50, 30, 70, BLACK);
80003640:	30 08       	mov	r8,0
80003642:	34 69       	mov	r9,70
80003644:	31 ea       	mov	r10,30
80003646:	33 2b       	mov	r11,50
80003648:	30 ac       	mov	r12,10
8000364a:	f0 1f 00 17 	mcall	800036a4 <main+0x154>
  et024006_DrawLine(30, 50, 10, 70, BLACK);
8000364e:	30 08       	mov	r8,0
80003650:	34 69       	mov	r9,70
80003652:	30 aa       	mov	r10,10
80003654:	33 2b       	mov	r11,50
80003656:	31 ec       	mov	r12,30
80003658:	f0 1f 00 13 	mcall	800036a4 <main+0x154>
      break;
    case 13:
      //act13();
      break;
    case 14:
      act14();
8000365c:	f0 1f 00 13 	mcall	800036a8 <main+0x158>
      // act16();
      break;
  }

  // Display text.
  et024006_PrintString(
80003660:	3f f8       	mov	r8,-1
80003662:	1a d8       	st.w	--sp,r8
80003664:	31 f8       	mov	r8,31
80003666:	30 09       	mov	r9,0
80003668:	12 9a       	mov	r10,r9
8000366a:	49 1b       	lddpc	r11,800036ac <main+0x15c>
8000366c:	49 1c       	lddpc	r12,800036b0 <main+0x160>
8000366e:	f0 1f 00 12 	mcall	800036b4 <main+0x164>
80003672:	2f fd       	sub	sp,-4
80003674:	c0 08       	rjmp	80003674 <main+0x124>
80003676:	00 00       	add	r0,r0
80003678:	80 00       	ld.sh	r0,r0[0x0]
8000367a:	2c cc       	sub	r12,-52
8000367c:	80 00       	ld.sh	r0,r0[0x0]
8000367e:	2b 8c       	sub	r12,-72
80003680:	80 00       	ld.sh	r0,r0[0x0]
80003682:	25 48       	sub	r8,84
80003684:	80 00       	ld.sh	r0,r0[0x0]
80003686:	2d 58       	sub	r8,-43
80003688:	00 00       	add	r0,r0
8000368a:	00 08       	add	r8,r0
8000368c:	80 00       	ld.sh	r0,r0[0x0]
8000368e:	2c e8       	sub	r8,-50
80003690:	80 00       	ld.sh	r0,r0[0x0]
80003692:	2d 1e       	sub	lr,-47
80003694:	80 00       	ld.sh	r0,r0[0x0]
80003696:	2d 30       	sub	r0,-45
80003698:	80 00       	ld.sh	r0,r0[0x0]
8000369a:	24 64       	sub	r4,70
8000369c:	80 00       	ld.sh	r0,r0[0x0]
8000369e:	24 c0       	sub	r0,76
800036a0:	80 00       	ld.sh	r0,r0[0x0]
800036a2:	24 a4       	sub	r4,74
800036a4:	80 00       	ld.sh	r0,r0[0x0]
800036a6:	23 0c       	sub	r12,48
800036a8:	80 00       	ld.sh	r0,r0[0x0]
800036aa:	34 6c       	mov	r12,70
800036ac:	80 00       	ld.sh	r0,r0[0x0]
800036ae:	5e 00       	reteq	r0
800036b0:	80 00       	ld.sh	r0,r0[0x0]
800036b2:	62 48       	ld.w	r8,r1[0x10]
800036b4:	80 00       	ld.sh	r0,r0[0x0]
800036b6:	20 d0       	sub	r0,13

800036b8 <cos>:
800036b8:	d4 21       	pushm	r4-r7,lr
800036ba:	20 4d       	sub	sp,16
800036bc:	e0 6e 21 fb 	mov	lr,8699
800036c0:	ea 1e 3f e9 	orh	lr,0x3fe9
800036c4:	14 98       	mov	r8,r10
800036c6:	16 99       	mov	r9,r11
800036c8:	16 95       	mov	r5,r11
800036ca:	14 96       	mov	r6,r10
800036cc:	16 97       	mov	r7,r11
800036ce:	16 94       	mov	r4,r11
800036d0:	f9 db c0 1f 	bfextu	r12,r11,0x0,0x1f
800036d4:	1c 3c       	cp.w	r12,lr
800036d6:	e0 89 00 05 	brgt	800036e0 <cos+0x28>
800036da:	30 08       	mov	r8,0
800036dc:	30 09       	mov	r9,0
800036de:	c1 98       	rjmp	80003710 <cos+0x58>
800036e0:	e0 65 ff ff 	mov	r5,65535
800036e4:	ea 15 7f ef 	orh	r5,0x7fef
800036e8:	0a 3c       	cp.w	r12,r5
800036ea:	e0 8a 00 05 	brle	800036f4 <cos+0x3c>
800036ee:	e0 a0 0b 37 	rcall	80004d5c <__avr32_f64_sub>
800036f2:	c2 58       	rjmp	8000373c <cos+0x84>
800036f4:	1a 9c       	mov	r12,sp
800036f6:	c0 dd       	rcall	80003910 <__ieee754_rem_pio2>
800036f8:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
800036fc:	58 1c       	cp.w	r12,1
800036fe:	c0 c0       	breq	80003716 <cos+0x5e>
80003700:	58 2c       	cp.w	r12,2
80003702:	c1 10       	breq	80003724 <cos+0x6c>
80003704:	fa e8 00 08 	ld.d	r8,sp[8]
80003708:	fa ea 00 00 	ld.d	r10,sp[0]
8000370c:	58 0c       	cp.w	r12,0
8000370e:	c1 41       	brne	80003736 <cos+0x7e>
80003710:	e0 a0 03 fa 	rcall	80003f04 <__kernel_cos>
80003714:	c1 48       	rjmp	8000373c <cos+0x84>
80003716:	fa e8 00 08 	ld.d	r8,sp[8]
8000371a:	fa ea 00 00 	ld.d	r10,sp[0]
8000371e:	e0 a0 08 57 	rcall	800047cc <__kernel_sin>
80003722:	c0 78       	rjmp	80003730 <cos+0x78>
80003724:	fa e8 00 08 	ld.d	r8,sp[8]
80003728:	fa ea 00 00 	ld.d	r10,sp[0]
8000372c:	e0 a0 03 ec 	rcall	80003f04 <__kernel_cos>
80003730:	ee 1b 80 00 	eorh	r11,0x8000
80003734:	c0 48       	rjmp	8000373c <cos+0x84>
80003736:	30 1c       	mov	r12,1
80003738:	e0 a0 08 4a 	rcall	800047cc <__kernel_sin>
8000373c:	2f cd       	sub	sp,-16
8000373e:	d8 22       	popm	r4-r7,pc

80003740 <round>:
80003740:	d4 21       	pushm	r4-r7,lr
80003742:	fd db c2 8b 	bfextu	lr,r11,0x14,0xb
80003746:	14 96       	mov	r6,r10
80003748:	16 97       	mov	r7,r11
8000374a:	14 94       	mov	r4,r10
8000374c:	16 95       	mov	r5,r11
8000374e:	16 98       	mov	r8,r11
80003750:	fc cc 03 ff 	sub	r12,lr,1023
80003754:	59 3c       	cp.w	r12,19
80003756:	e0 89 00 25 	brgt	800037a0 <round+0x60>
8000375a:	58 0c       	cp.w	r12,0
8000375c:	c0 e4       	brge	80003778 <round+0x38>
8000375e:	e6 18 80 00 	andh	r8,0x8000,COH
80003762:	10 99       	mov	r9,r8
80003764:	ea 19 3f f0 	orh	r9,0x3ff0
80003768:	5b fc       	cp.w	r12,-1
8000376a:	f2 08 17 00 	moveq	r8,r9
8000376e:	f9 bc 00 00 	moveq	r12,0
80003772:	f9 bc 01 00 	movne	r12,0
80003776:	c3 88       	rjmp	800037e6 <round+0xa6>
80003778:	ee 7a ff ff 	mov	r10,1048575
8000377c:	f4 0c 08 4a 	asr	r10,r10,r12
80003780:	f5 eb 00 0b 	and	r11,r10,r11
80003784:	f7 e6 10 09 	or	r9,r11,r6
80003788:	c3 10       	breq	800037ea <round+0xaa>
8000378a:	e8 69 00 00 	mov	r9,524288
8000378e:	f2 0c 08 4c 	asr	r12,r9,r12
80003792:	5c da       	com	r10
80003794:	f8 07 00 08 	add	r8,r12,r7
80003798:	30 0c       	mov	r12,0
8000379a:	f5 e8 00 08 	and	r8,r10,r8
8000379e:	c2 48       	rjmp	800037e6 <round+0xa6>
800037a0:	e0 4c 00 33 	cp.w	r12,51
800037a4:	e0 8a 00 0c 	brle	800037bc <round+0x7c>
800037a8:	e0 4c 04 00 	cp.w	r12,1024
800037ac:	c1 f1       	brne	800037ea <round+0xaa>
800037ae:	14 98       	mov	r8,r10
800037b0:	16 99       	mov	r9,r11
800037b2:	e0 a0 0b a3 	rcall	80004ef8 <__avr32_f64_add>
800037b6:	14 96       	mov	r6,r10
800037b8:	16 97       	mov	r7,r11
800037ba:	c1 88       	rjmp	800037ea <round+0xaa>
800037bc:	3f fa       	mov	r10,-1
800037be:	fc ce 04 13 	sub	lr,lr,1043
800037c2:	f4 0e 0a 4e 	lsr	lr,r10,lr
800037c6:	fd e6 00 0a 	and	r10,lr,r6
800037ca:	c1 00       	breq	800037ea <round+0xaa>
800037cc:	f8 0c 11 33 	rsub	r12,r12,51
800037d0:	30 1a       	mov	r10,1
800037d2:	f4 0c 09 4a 	lsl	r10,r10,r12
800037d6:	fc 0c 11 ff 	rsub	r12,lr,-1
800037da:	0c 0a       	add	r10,r6
800037dc:	0c 3a       	cp.w	r10,r6
800037de:	f7 b8 03 ff 	sublo	r8,-1
800037e2:	f5 ec 00 0c 	and	r12,r10,r12
800037e6:	10 97       	mov	r7,r8
800037e8:	18 96       	mov	r6,r12
800037ea:	0c 9a       	mov	r10,r6
800037ec:	0e 9b       	mov	r11,r7
800037ee:	d8 22       	popm	r4-r7,pc

800037f0 <sin>:
800037f0:	d4 21       	pushm	r4-r7,lr
800037f2:	20 4d       	sub	sp,16
800037f4:	e0 6e 21 fb 	mov	lr,8699
800037f8:	ea 1e 3f e9 	orh	lr,0x3fe9
800037fc:	14 98       	mov	r8,r10
800037fe:	16 99       	mov	r9,r11
80003800:	16 95       	mov	r5,r11
80003802:	14 96       	mov	r6,r10
80003804:	16 97       	mov	r7,r11
80003806:	16 94       	mov	r4,r11
80003808:	f9 db c0 1f 	bfextu	r12,r11,0x0,0x1f
8000380c:	1c 3c       	cp.w	r12,lr
8000380e:	e0 89 00 06 	brgt	8000381a <sin+0x2a>
80003812:	30 0c       	mov	r12,0
80003814:	30 08       	mov	r8,0
80003816:	30 09       	mov	r9,0
80003818:	c1 a8       	rjmp	8000384c <sin+0x5c>
8000381a:	e0 65 ff ff 	mov	r5,65535
8000381e:	ea 15 7f ef 	orh	r5,0x7fef
80003822:	0a 3c       	cp.w	r12,r5
80003824:	e0 8a 00 05 	brle	8000382e <sin+0x3e>
80003828:	e0 a0 0a 9a 	rcall	80004d5c <__avr32_f64_sub>
8000382c:	c2 68       	rjmp	80003878 <sin+0x88>
8000382e:	1a 9c       	mov	r12,sp
80003830:	c7 0c       	rcall	80003910 <__ieee754_rem_pio2>
80003832:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80003836:	58 1c       	cp.w	r12,1
80003838:	c0 d0       	breq	80003852 <sin+0x62>
8000383a:	58 2c       	cp.w	r12,2
8000383c:	c1 20       	breq	80003860 <sin+0x70>
8000383e:	fa e8 00 08 	ld.d	r8,sp[8]
80003842:	fa ea 00 00 	ld.d	r10,sp[0]
80003846:	58 0c       	cp.w	r12,0
80003848:	c1 41       	brne	80003870 <sin+0x80>
8000384a:	30 1c       	mov	r12,1
8000384c:	e0 a0 07 c0 	rcall	800047cc <__kernel_sin>
80003850:	c1 48       	rjmp	80003878 <sin+0x88>
80003852:	fa e8 00 08 	ld.d	r8,sp[8]
80003856:	fa ea 00 00 	ld.d	r10,sp[0]
8000385a:	e0 a0 03 55 	rcall	80003f04 <__kernel_cos>
8000385e:	c0 d8       	rjmp	80003878 <sin+0x88>
80003860:	30 1c       	mov	r12,1
80003862:	fa e8 00 08 	ld.d	r8,sp[8]
80003866:	fa ea 00 00 	ld.d	r10,sp[0]
8000386a:	e0 a0 07 b1 	rcall	800047cc <__kernel_sin>
8000386e:	c0 38       	rjmp	80003874 <sin+0x84>
80003870:	e0 a0 03 4a 	rcall	80003f04 <__kernel_cos>
80003874:	ee 1b 80 00 	eorh	r11,0x8000
80003878:	2f cd       	sub	sp,-16
8000387a:	d8 22       	popm	r4-r7,pc

8000387c <sqrt>:
8000387c:	d4 31       	pushm	r0-r7,lr
8000387e:	20 9d       	sub	sp,36
80003880:	32 87       	mov	r7,40
80003882:	14 94       	mov	r4,r10
80003884:	16 95       	mov	r5,r11
80003886:	e0 a0 02 79 	rcall	80003d78 <__ieee754_sqrt>
8000388a:	6e 08       	ld.w	r8,r7[0x0]
8000388c:	14 92       	mov	r2,r10
8000388e:	16 93       	mov	r3,r11
80003890:	5b f8       	cp.w	r8,-1
80003892:	c3 b0       	breq	80003908 <sqrt+0x8c>
80003894:	08 9a       	mov	r10,r4
80003896:	0a 9b       	mov	r11,r5
80003898:	e0 a0 08 ec 	rcall	80004a70 <__isnand>
8000389c:	18 96       	mov	r6,r12
8000389e:	c3 51       	brne	80003908 <sqrt+0x8c>
800038a0:	30 08       	mov	r8,0
800038a2:	30 09       	mov	r9,0
800038a4:	08 9a       	mov	r10,r4
800038a6:	0a 9b       	mov	r11,r5
800038a8:	e0 a0 0c 80 	rcall	800051a8 <__avr32_f64_cmp_lt>
800038ac:	c2 e0       	breq	80003908 <sqrt+0x8c>
800038ae:	30 18       	mov	r8,1
800038b0:	50 86       	stdsp	sp[0x20],r6
800038b2:	50 08       	stdsp	sp[0x0],r8
800038b4:	fa e5 00 08 	st.d	sp[8],r4
800038b8:	fe c8 d6 50 	sub	r8,pc,-10672
800038bc:	fa e5 00 10 	st.d	sp[16],r4
800038c0:	50 18       	stdsp	sp[0x4],r8
800038c2:	6e 07       	ld.w	r7,r7[0x0]
800038c4:	58 07       	cp.w	r7,0
800038c6:	c0 61       	brne	800038d2 <sqrt+0x56>
800038c8:	30 08       	mov	r8,0
800038ca:	30 09       	mov	r9,0
800038cc:	fa e9 00 18 	st.d	sp[24],r8
800038d0:	c0 b8       	rjmp	800038e6 <sqrt+0x6a>
800038d2:	30 08       	mov	r8,0
800038d4:	30 09       	mov	r9,0
800038d6:	10 9a       	mov	r10,r8
800038d8:	12 9b       	mov	r11,r9
800038da:	e0 a0 0c b5 	rcall	80005244 <__avr32_f64_div>
800038de:	fa eb 00 18 	st.d	sp[24],r10
800038e2:	58 27       	cp.w	r7,2
800038e4:	c0 50       	breq	800038ee <sqrt+0x72>
800038e6:	1a 9c       	mov	r12,sp
800038e8:	e0 a0 08 d2 	rcall	80004a8c <matherr>
800038ec:	c0 51       	brne	800038f6 <sqrt+0x7a>
800038ee:	e0 a0 11 57 	rcall	80005b9c <__errno>
800038f2:	32 18       	mov	r8,33
800038f4:	99 08       	st.w	r12[0x0],r8
800038f6:	40 88       	lddsp	r8,sp[0x20]
800038f8:	58 08       	cp.w	r8,0
800038fa:	c0 50       	breq	80003904 <sqrt+0x88>
800038fc:	e0 a0 11 50 	rcall	80005b9c <__errno>
80003900:	40 88       	lddsp	r8,sp[0x20]
80003902:	99 08       	st.w	r12[0x0],r8
80003904:	fa e2 00 18 	ld.d	r2,sp[24]
80003908:	04 9a       	mov	r10,r2
8000390a:	06 9b       	mov	r11,r3
8000390c:	2f 7d       	sub	sp,-36
8000390e:	d8 32       	popm	r0-r7,pc

80003910 <__ieee754_rem_pio2>:
80003910:	d4 31       	pushm	r0-r7,lr
80003912:	20 ad       	sub	sp,40
80003914:	50 3b       	stdsp	sp[0xc],r11
80003916:	18 96       	mov	r6,r12
80003918:	14 98       	mov	r8,r10
8000391a:	16 99       	mov	r9,r11
8000391c:	14 92       	mov	r2,r10
8000391e:	16 93       	mov	r3,r11
80003920:	eb db c0 1f 	bfextu	r5,r11,0x0,0x1f
80003924:	e0 6c 21 fb 	mov	r12,8699
80003928:	ea 1c 3f e9 	orh	r12,0x3fe9
8000392c:	18 35       	cp.w	r5,r12
8000392e:	e0 89 00 0b 	brgt	80003944 <__ieee754_rem_pio2+0x34>
80003932:	ec e9 00 00 	st.d	r6[0],r8
80003936:	30 07       	mov	r7,0
80003938:	30 08       	mov	r8,0
8000393a:	30 09       	mov	r9,0
8000393c:	ec e9 00 08 	st.d	r6[8],r8
80003940:	e0 8f 02 19 	bral	80003d72 <__ieee754_rem_pio2+0x462>
80003944:	e0 6c d9 7b 	mov	r12,55675
80003948:	ea 1c 40 02 	orh	r12,0x4002
8000394c:	18 35       	cp.w	r5,r12
8000394e:	e0 89 00 b6 	brgt	80003aba <__ieee754_rem_pio2+0x1aa>
80003952:	58 0b       	cp.w	r11,0
80003954:	e0 8a 00 59 	brle	80003a06 <__ieee754_rem_pio2+0xf6>
80003958:	fc 18 54 40 	movh	r8,0x5440
8000395c:	e0 69 21 fb 	mov	r9,8699
80003960:	ea 19 3f f9 	orh	r9,0x3ff9
80003964:	e0 a0 09 fc 	rcall	80004d5c <__avr32_f64_sub>
80003968:	e0 68 21 fb 	mov	r8,8699
8000396c:	ea 18 3f f9 	orh	r8,0x3ff9
80003970:	14 92       	mov	r2,r10
80003972:	16 93       	mov	r3,r11
80003974:	10 35       	cp.w	r5,r8
80003976:	c1 e0       	breq	800039b2 <__ieee754_rem_pio2+0xa2>
80003978:	e0 68 63 31 	mov	r8,25393
8000397c:	ea 18 1a 62 	orh	r8,0x1a62
80003980:	e0 69 b4 61 	mov	r9,46177
80003984:	ea 19 3d d0 	orh	r9,0x3dd0
80003988:	e0 a0 09 ea 	rcall	80004d5c <__avr32_f64_sub>
8000398c:	14 94       	mov	r4,r10
8000398e:	16 95       	mov	r5,r11
80003990:	08 98       	mov	r8,r4
80003992:	0a 99       	mov	r9,r5
80003994:	04 9a       	mov	r10,r2
80003996:	06 9b       	mov	r11,r3
80003998:	ec e5 00 00 	st.d	r6[0],r4
8000399c:	e0 a0 09 e0 	rcall	80004d5c <__avr32_f64_sub>
800039a0:	e0 68 63 31 	mov	r8,25393
800039a4:	ea 18 1a 62 	orh	r8,0x1a62
800039a8:	e0 69 b4 61 	mov	r9,46177
800039ac:	ea 19 3d d0 	orh	r9,0x3dd0
800039b0:	c2 78       	rjmp	800039fe <__ieee754_rem_pio2+0xee>
800039b2:	fc 18 1a 60 	movh	r8,0x1a60
800039b6:	e0 69 b4 61 	mov	r9,46177
800039ba:	ea 19 3d d0 	orh	r9,0x3dd0
800039be:	e0 a0 09 cf 	rcall	80004d5c <__avr32_f64_sub>
800039c2:	e0 68 70 73 	mov	r8,28787
800039c6:	ea 18 2e 03 	orh	r8,0x2e03
800039ca:	14 94       	mov	r4,r10
800039cc:	16 95       	mov	r5,r11
800039ce:	e0 69 19 8a 	mov	r9,6538
800039d2:	ea 19 3b a3 	orh	r9,0x3ba3
800039d6:	e0 a0 09 c3 	rcall	80004d5c <__avr32_f64_sub>
800039da:	14 92       	mov	r2,r10
800039dc:	16 93       	mov	r3,r11
800039de:	04 98       	mov	r8,r2
800039e0:	06 99       	mov	r9,r3
800039e2:	08 9a       	mov	r10,r4
800039e4:	0a 9b       	mov	r11,r5
800039e6:	ec e3 00 00 	st.d	r6[0],r2
800039ea:	e0 a0 09 b9 	rcall	80004d5c <__avr32_f64_sub>
800039ee:	e0 68 70 73 	mov	r8,28787
800039f2:	ea 18 2e 03 	orh	r8,0x2e03
800039f6:	e0 69 19 8a 	mov	r9,6538
800039fa:	ea 19 3b a3 	orh	r9,0x3ba3
800039fe:	30 17       	mov	r7,1
80003a00:	e0 a0 09 ae 	rcall	80004d5c <__avr32_f64_sub>
80003a04:	c3 08       	rjmp	80003a64 <__ieee754_rem_pio2+0x154>
80003a06:	fc 18 54 40 	movh	r8,0x5440
80003a0a:	e0 69 21 fb 	mov	r9,8699
80003a0e:	ea 19 3f f9 	orh	r9,0x3ff9
80003a12:	e0 a0 0a 73 	rcall	80004ef8 <__avr32_f64_add>
80003a16:	e0 6c 21 fb 	mov	r12,8699
80003a1a:	ea 1c 3f f9 	orh	r12,0x3ff9
80003a1e:	14 92       	mov	r2,r10
80003a20:	16 93       	mov	r3,r11
80003a22:	18 35       	cp.w	r5,r12
80003a24:	c2 40       	breq	80003a6c <__ieee754_rem_pio2+0x15c>
80003a26:	e0 68 63 31 	mov	r8,25393
80003a2a:	ea 18 1a 62 	orh	r8,0x1a62
80003a2e:	e0 69 b4 61 	mov	r9,46177
80003a32:	ea 19 3d d0 	orh	r9,0x3dd0
80003a36:	e0 a0 0a 61 	rcall	80004ef8 <__avr32_f64_add>
80003a3a:	14 94       	mov	r4,r10
80003a3c:	16 95       	mov	r5,r11
80003a3e:	08 98       	mov	r8,r4
80003a40:	0a 99       	mov	r9,r5
80003a42:	04 9a       	mov	r10,r2
80003a44:	06 9b       	mov	r11,r3
80003a46:	ec e5 00 00 	st.d	r6[0],r4
80003a4a:	e0 a0 09 89 	rcall	80004d5c <__avr32_f64_sub>
80003a4e:	e0 68 63 31 	mov	r8,25393
80003a52:	ea 18 1a 62 	orh	r8,0x1a62
80003a56:	e0 69 b4 61 	mov	r9,46177
80003a5a:	ea 19 3d d0 	orh	r9,0x3dd0
80003a5e:	3f f7       	mov	r7,-1
80003a60:	e0 a0 0a 4c 	rcall	80004ef8 <__avr32_f64_add>
80003a64:	ec eb 00 08 	st.d	r6[8],r10
80003a68:	e0 8f 01 85 	bral	80003d72 <__ieee754_rem_pio2+0x462>
80003a6c:	fc 18 1a 60 	movh	r8,0x1a60
80003a70:	e0 69 b4 61 	mov	r9,46177
80003a74:	ea 19 3d d0 	orh	r9,0x3dd0
80003a78:	e0 a0 0a 40 	rcall	80004ef8 <__avr32_f64_add>
80003a7c:	e0 68 70 73 	mov	r8,28787
80003a80:	ea 18 2e 03 	orh	r8,0x2e03
80003a84:	14 94       	mov	r4,r10
80003a86:	16 95       	mov	r5,r11
80003a88:	e0 69 19 8a 	mov	r9,6538
80003a8c:	ea 19 3b a3 	orh	r9,0x3ba3
80003a90:	e0 a0 0a 34 	rcall	80004ef8 <__avr32_f64_add>
80003a94:	14 92       	mov	r2,r10
80003a96:	16 93       	mov	r3,r11
80003a98:	04 98       	mov	r8,r2
80003a9a:	06 99       	mov	r9,r3
80003a9c:	08 9a       	mov	r10,r4
80003a9e:	0a 9b       	mov	r11,r5
80003aa0:	ec e3 00 00 	st.d	r6[0],r2
80003aa4:	e0 a0 09 5c 	rcall	80004d5c <__avr32_f64_sub>
80003aa8:	e0 68 70 73 	mov	r8,28787
80003aac:	ea 18 2e 03 	orh	r8,0x2e03
80003ab0:	e0 69 19 8a 	mov	r9,6538
80003ab4:	ea 19 3b a3 	orh	r9,0x3ba3
80003ab8:	cd 3b       	rjmp	80003a5e <__ieee754_rem_pio2+0x14e>
80003aba:	e0 6c 21 fb 	mov	r12,8699
80003abe:	ea 1c 41 39 	orh	r12,0x4139
80003ac2:	18 35       	cp.w	r5,r12
80003ac4:	e0 89 00 f2 	brgt	80003ca8 <__ieee754_rem_pio2+0x398>
80003ac8:	e0 a0 07 40 	rcall	80004948 <fabs>
80003acc:	e0 68 c8 83 	mov	r8,51331
80003ad0:	ea 18 6d c9 	orh	r8,0x6dc9
80003ad4:	14 92       	mov	r2,r10
80003ad6:	16 93       	mov	r3,r11
80003ad8:	e0 69 5f 30 	mov	r9,24368
80003adc:	ea 19 3f e4 	orh	r9,0x3fe4
80003ae0:	e0 a0 08 52 	rcall	80004b84 <__avr32_f64_mul>
80003ae4:	30 08       	mov	r8,0
80003ae6:	fc 19 3f e0 	movh	r9,0x3fe0
80003aea:	e0 a0 0a 07 	rcall	80004ef8 <__avr32_f64_add>
80003aee:	e0 a0 0a 8f 	rcall	8000500c <__avr32_f64_to_s32>
80003af2:	18 97       	mov	r7,r12
80003af4:	e0 a0 0a a3 	rcall	8000503a <__avr32_s32_to_f64>
80003af8:	fc 18 54 40 	movh	r8,0x5440
80003afc:	e0 69 21 fb 	mov	r9,8699
80003b00:	ea 19 bf f9 	orh	r9,0xbff9
80003b04:	fa eb 00 04 	st.d	sp[4],r10
80003b08:	e0 a0 08 3e 	rcall	80004b84 <__avr32_f64_mul>
80003b0c:	14 98       	mov	r8,r10
80003b0e:	16 99       	mov	r9,r11
80003b10:	04 9a       	mov	r10,r2
80003b12:	06 9b       	mov	r11,r3
80003b14:	e0 a0 09 f2 	rcall	80004ef8 <__avr32_f64_add>
80003b18:	e0 68 63 31 	mov	r8,25393
80003b1c:	ea 18 1a 62 	orh	r8,0x1a62
80003b20:	14 92       	mov	r2,r10
80003b22:	16 93       	mov	r3,r11
80003b24:	e0 69 b4 61 	mov	r9,46177
80003b28:	ea 19 3d d0 	orh	r9,0x3dd0
80003b2c:	fa ea 00 04 	ld.d	r10,sp[4]
80003b30:	e0 a0 08 2a 	rcall	80004b84 <__avr32_f64_mul>
80003b34:	14 90       	mov	r0,r10
80003b36:	16 91       	mov	r1,r11
80003b38:	59 f7       	cp.w	r7,31
80003b3a:	e0 89 00 0b 	brgt	80003b50 <__ieee754_rem_pio2+0x240>
80003b3e:	ee c9 00 01 	sub	r9,r7,1
80003b42:	fe c8 d8 d2 	sub	r8,pc,-10030
80003b46:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80003b4a:	10 35       	cp.w	r5,r8
80003b4c:	e0 81 00 8b 	brne	80003c62 <__ieee754_rem_pio2+0x352>
80003b50:	00 98       	mov	r8,r0
80003b52:	02 99       	mov	r9,r1
80003b54:	04 9a       	mov	r10,r2
80003b56:	06 9b       	mov	r11,r3
80003b58:	e0 a0 09 02 	rcall	80004d5c <__avr32_f64_sub>
80003b5c:	ec eb 00 00 	st.d	r6[0],r10
80003b60:	ea 0c 14 14 	asr	r12,r5,0x14
80003b64:	f7 db c2 8b 	bfextu	r11,r11,0x14,0xb
80003b68:	f8 0b 01 0b 	sub	r11,r12,r11
80003b6c:	59 0b       	cp.w	r11,16
80003b6e:	e0 8a 00 82 	brle	80003c72 <__ieee754_rem_pio2+0x362>
80003b72:	50 0c       	stdsp	sp[0x0],r12
80003b74:	fc 18 1a 60 	movh	r8,0x1a60
80003b78:	e0 69 b4 61 	mov	r9,46177
80003b7c:	ea 19 3d d0 	orh	r9,0x3dd0
80003b80:	fa ea 00 04 	ld.d	r10,sp[4]
80003b84:	e0 a0 08 00 	rcall	80004b84 <__avr32_f64_mul>
80003b88:	16 91       	mov	r1,r11
80003b8a:	14 90       	mov	r0,r10
80003b8c:	14 98       	mov	r8,r10
80003b8e:	02 99       	mov	r9,r1
80003b90:	04 9a       	mov	r10,r2
80003b92:	06 9b       	mov	r11,r3
80003b94:	e0 a0 08 e4 	rcall	80004d5c <__avr32_f64_sub>
80003b98:	16 95       	mov	r5,r11
80003b9a:	14 98       	mov	r8,r10
80003b9c:	14 94       	mov	r4,r10
80003b9e:	0a 99       	mov	r9,r5
80003ba0:	04 9a       	mov	r10,r2
80003ba2:	06 9b       	mov	r11,r3
80003ba4:	e0 a0 08 dc 	rcall	80004d5c <__avr32_f64_sub>
80003ba8:	00 98       	mov	r8,r0
80003baa:	02 99       	mov	r9,r1
80003bac:	e0 a0 08 d8 	rcall	80004d5c <__avr32_f64_sub>
80003bb0:	e0 68 70 73 	mov	r8,28787
80003bb4:	ea 18 2e 03 	orh	r8,0x2e03
80003bb8:	14 92       	mov	r2,r10
80003bba:	16 93       	mov	r3,r11
80003bbc:	e0 69 19 8a 	mov	r9,6538
80003bc0:	ea 19 3b a3 	orh	r9,0x3ba3
80003bc4:	fa ea 00 04 	ld.d	r10,sp[4]
80003bc8:	e0 a0 07 de 	rcall	80004b84 <__avr32_f64_mul>
80003bcc:	04 98       	mov	r8,r2
80003bce:	06 99       	mov	r9,r3
80003bd0:	e0 a0 08 c6 	rcall	80004d5c <__avr32_f64_sub>
80003bd4:	16 91       	mov	r1,r11
80003bd6:	14 98       	mov	r8,r10
80003bd8:	14 90       	mov	r0,r10
80003bda:	02 99       	mov	r9,r1
80003bdc:	08 9a       	mov	r10,r4
80003bde:	0a 9b       	mov	r11,r5
80003be0:	e0 a0 08 be 	rcall	80004d5c <__avr32_f64_sub>
80003be4:	ec eb 00 00 	st.d	r6[0],r10
80003be8:	40 0c       	lddsp	r12,sp[0x0]
80003bea:	f7 db c2 8b 	bfextu	r11,r11,0x14,0xb
80003bee:	16 1c       	sub	r12,r11
80003bf0:	e0 4c 00 31 	cp.w	r12,49
80003bf4:	e0 89 00 05 	brgt	80003bfe <__ieee754_rem_pio2+0x2ee>
80003bf8:	08 92       	mov	r2,r4
80003bfa:	0a 93       	mov	r3,r5
80003bfc:	c3 b8       	rjmp	80003c72 <__ieee754_rem_pio2+0x362>
80003bfe:	fc 18 2e 00 	movh	r8,0x2e00
80003c02:	e0 69 19 8a 	mov	r9,6538
80003c06:	ea 19 3b a3 	orh	r9,0x3ba3
80003c0a:	fa ea 00 04 	ld.d	r10,sp[4]
80003c0e:	e0 a0 07 bb 	rcall	80004b84 <__avr32_f64_mul>
80003c12:	16 91       	mov	r1,r11
80003c14:	14 90       	mov	r0,r10
80003c16:	14 98       	mov	r8,r10
80003c18:	02 99       	mov	r9,r1
80003c1a:	08 9a       	mov	r10,r4
80003c1c:	0a 9b       	mov	r11,r5
80003c1e:	e0 a0 08 9f 	rcall	80004d5c <__avr32_f64_sub>
80003c22:	14 98       	mov	r8,r10
80003c24:	16 93       	mov	r3,r11
80003c26:	14 92       	mov	r2,r10
80003c28:	06 99       	mov	r9,r3
80003c2a:	08 9a       	mov	r10,r4
80003c2c:	0a 9b       	mov	r11,r5
80003c2e:	e0 a0 08 97 	rcall	80004d5c <__avr32_f64_sub>
80003c32:	00 98       	mov	r8,r0
80003c34:	02 99       	mov	r9,r1
80003c36:	e0 a0 08 93 	rcall	80004d5c <__avr32_f64_sub>
80003c3a:	e0 68 49 c1 	mov	r8,18881
80003c3e:	ea 18 25 20 	orh	r8,0x2520
80003c42:	14 94       	mov	r4,r10
80003c44:	16 95       	mov	r5,r11
80003c46:	e0 69 83 9a 	mov	r9,33690
80003c4a:	ea 19 39 7b 	orh	r9,0x397b
80003c4e:	fa ea 00 04 	ld.d	r10,sp[4]
80003c52:	e0 a0 07 99 	rcall	80004b84 <__avr32_f64_mul>
80003c56:	08 98       	mov	r8,r4
80003c58:	0a 99       	mov	r9,r5
80003c5a:	e0 a0 08 81 	rcall	80004d5c <__avr32_f64_sub>
80003c5e:	14 90       	mov	r0,r10
80003c60:	16 91       	mov	r1,r11
80003c62:	00 98       	mov	r8,r0
80003c64:	02 99       	mov	r9,r1
80003c66:	04 9a       	mov	r10,r2
80003c68:	06 9b       	mov	r11,r3
80003c6a:	e0 a0 08 79 	rcall	80004d5c <__avr32_f64_sub>
80003c6e:	ec eb 00 00 	st.d	r6[0],r10
80003c72:	ec e8 00 00 	ld.d	r8,r6[0]
80003c76:	04 9a       	mov	r10,r2
80003c78:	06 9b       	mov	r11,r3
80003c7a:	e0 a0 08 71 	rcall	80004d5c <__avr32_f64_sub>
80003c7e:	00 98       	mov	r8,r0
80003c80:	ec c5 ff f8 	sub	r5,r6,-8
80003c84:	02 99       	mov	r9,r1
80003c86:	e0 a0 08 6b 	rcall	80004d5c <__avr32_f64_sub>
80003c8a:	ea eb 00 00 	st.d	r5[0],r10
80003c8e:	40 38       	lddsp	r8,sp[0xc]
80003c90:	58 08       	cp.w	r8,0
80003c92:	c7 04       	brge	80003d72 <__ieee754_rem_pio2+0x462>
80003c94:	6c 08       	ld.w	r8,r6[0x0]
80003c96:	ee 18 80 00 	eorh	r8,0x8000
80003c9a:	8d 08       	st.w	r6[0x0],r8
80003c9c:	5c 37       	neg	r7
80003c9e:	6a 08       	ld.w	r8,r5[0x0]
80003ca0:	ee 18 80 00 	eorh	r8,0x8000
80003ca4:	8b 08       	st.w	r5[0x0],r8
80003ca6:	c6 68       	rjmp	80003d72 <__ieee754_rem_pio2+0x462>
80003ca8:	e0 6c ff ff 	mov	r12,65535
80003cac:	ea 1c 7f ef 	orh	r12,0x7fef
80003cb0:	18 35       	cp.w	r5,r12
80003cb2:	e0 8a 00 08 	brle	80003cc2 <__ieee754_rem_pio2+0x3b2>
80003cb6:	30 07       	mov	r7,0
80003cb8:	e0 a0 08 52 	rcall	80004d5c <__avr32_f64_sub>
80003cbc:	ec eb 00 00 	st.d	r6[0],r10
80003cc0:	cd 2a       	rjmp	80003a64 <__ieee754_rem_pio2+0x154>
80003cc2:	ea 03 14 14 	asr	r3,r5,0x14
80003cc6:	e6 c3 04 16 	sub	r3,r3,1046
80003cca:	e6 08 15 14 	lsl	r8,r3,0x14
80003cce:	ea 08 01 01 	sub	r1,r5,r8
80003cd2:	02 9b       	mov	r11,r1
80003cd4:	e0 a0 09 9c 	rcall	8000500c <__avr32_f64_to_s32>
80003cd8:	e0 a0 09 b1 	rcall	8000503a <__avr32_s32_to_f64>
80003cdc:	14 94       	mov	r4,r10
80003cde:	16 95       	mov	r5,r11
80003ce0:	08 98       	mov	r8,r4
80003ce2:	0a 99       	mov	r9,r5
80003ce4:	fa e5 00 10 	st.d	sp[16],r4
80003ce8:	02 9b       	mov	r11,r1
80003cea:	04 9a       	mov	r10,r2
80003cec:	e0 a0 08 38 	rcall	80004d5c <__avr32_f64_sub>
80003cf0:	30 08       	mov	r8,0
80003cf2:	fc 19 41 70 	movh	r9,0x4170
80003cf6:	e0 a0 07 47 	rcall	80004b84 <__avr32_f64_mul>
80003cfa:	14 90       	mov	r0,r10
80003cfc:	16 91       	mov	r1,r11
80003cfe:	e0 a0 09 87 	rcall	8000500c <__avr32_f64_to_s32>
80003d02:	e0 a0 09 9c 	rcall	8000503a <__avr32_s32_to_f64>
80003d06:	16 95       	mov	r5,r11
80003d08:	14 94       	mov	r4,r10
80003d0a:	0a 99       	mov	r9,r5
80003d0c:	08 98       	mov	r8,r4
80003d0e:	fa e5 00 18 	st.d	sp[24],r4
80003d12:	00 9a       	mov	r10,r0
80003d14:	02 9b       	mov	r11,r1
80003d16:	e0 a0 08 23 	rcall	80004d5c <__avr32_f64_sub>
80003d1a:	30 08       	mov	r8,0
80003d1c:	fc 19 41 70 	movh	r9,0x4170
80003d20:	30 35       	mov	r5,3
80003d22:	e0 a0 07 31 	rcall	80004b84 <__avr32_f64_mul>
80003d26:	fa c7 ff d8 	sub	r7,sp,-40
80003d2a:	af 2b       	st.d	--r7,r10
80003d2c:	ee ea 00 00 	ld.d	r10,r7[0]
80003d30:	0a 91       	mov	r1,r5
80003d32:	20 87       	sub	r7,8
80003d34:	20 15       	sub	r5,1
80003d36:	30 08       	mov	r8,0
80003d38:	30 09       	mov	r9,0
80003d3a:	e0 a0 09 f0 	rcall	8000511a <__avr32_f64_cmp_eq>
80003d3e:	cf 71       	brne	80003d2c <__ieee754_rem_pio2+0x41c>
80003d40:	fe c8 da 50 	sub	r8,pc,-9648
80003d44:	02 99       	mov	r9,r1
80003d46:	1a d8       	st.w	--sp,r8
80003d48:	06 9a       	mov	r10,r3
80003d4a:	30 28       	mov	r8,2
80003d4c:	fa cc ff ec 	sub	r12,sp,-20
80003d50:	0c 9b       	mov	r11,r6
80003d52:	cc dd       	rcall	800040ec <__kernel_rem_pio2>
80003d54:	2f fd       	sub	sp,-4
80003d56:	18 97       	mov	r7,r12
80003d58:	40 38       	lddsp	r8,sp[0xc]
80003d5a:	58 08       	cp.w	r8,0
80003d5c:	c0 b4       	brge	80003d72 <__ieee754_rem_pio2+0x462>
80003d5e:	6c 08       	ld.w	r8,r6[0x0]
80003d60:	ee 18 80 00 	eorh	r8,0x8000
80003d64:	8d 08       	st.w	r6[0x0],r8
80003d66:	5c 37       	neg	r7
80003d68:	2f 86       	sub	r6,-8
80003d6a:	6c 08       	ld.w	r8,r6[0x0]
80003d6c:	ee 18 80 00 	eorh	r8,0x8000
80003d70:	8d 08       	st.w	r6[0x0],r8
80003d72:	0e 9c       	mov	r12,r7
80003d74:	2f 6d       	sub	sp,-40
80003d76:	d8 32       	popm	r0-r7,pc

80003d78 <__ieee754_sqrt>:
80003d78:	d4 31       	pushm	r0-r7,lr
80003d7a:	fc 1e 7f f0 	movh	lr,0x7ff0
80003d7e:	16 9c       	mov	r12,r11
80003d80:	14 96       	mov	r6,r10
80003d82:	16 97       	mov	r7,r11
80003d84:	14 94       	mov	r4,r10
80003d86:	16 95       	mov	r5,r11
80003d88:	16 99       	mov	r9,r11
80003d8a:	14 98       	mov	r8,r10
80003d8c:	e6 1c 7f f0 	andh	r12,0x7ff0,COH
80003d90:	1c 3c       	cp.w	r12,lr
80003d92:	c0 c1       	brne	80003daa <__ieee754_sqrt+0x32>
80003d94:	14 98       	mov	r8,r10
80003d96:	16 99       	mov	r9,r11
80003d98:	e0 a0 06 f6 	rcall	80004b84 <__avr32_f64_mul>
80003d9c:	14 98       	mov	r8,r10
80003d9e:	16 99       	mov	r9,r11
80003da0:	0c 9a       	mov	r10,r6
80003da2:	0e 9b       	mov	r11,r7
80003da4:	e0 a0 08 aa 	rcall	80004ef8 <__avr32_f64_add>
80003da8:	c1 38       	rjmp	80003dce <__ieee754_sqrt+0x56>
80003daa:	58 0b       	cp.w	r11,0
80003dac:	e0 89 00 14 	brgt	80003dd4 <__ieee754_sqrt+0x5c>
80003db0:	f9 db c0 1f 	bfextu	r12,r11,0x0,0x1f
80003db4:	14 4c       	or	r12,r10
80003db6:	e0 80 00 a3 	breq	80003efc <__ieee754_sqrt+0x184>
80003dba:	58 0b       	cp.w	r11,0
80003dbc:	c0 c0       	breq	80003dd4 <__ieee754_sqrt+0x5c>
80003dbe:	14 98       	mov	r8,r10
80003dc0:	16 99       	mov	r9,r11
80003dc2:	e0 a0 07 cd 	rcall	80004d5c <__avr32_f64_sub>
80003dc6:	14 98       	mov	r8,r10
80003dc8:	16 99       	mov	r9,r11
80003dca:	e0 a0 0a 3d 	rcall	80005244 <__avr32_f64_div>
80003dce:	14 96       	mov	r6,r10
80003dd0:	16 97       	mov	r7,r11
80003dd2:	c9 58       	rjmp	80003efc <__ieee754_sqrt+0x184>
80003dd4:	f2 0a 14 14 	asr	r10,r9,0x14
80003dd8:	c0 60       	breq	80003de4 <__ieee754_sqrt+0x6c>
80003dda:	c1 88       	rjmp	80003e0a <__ieee754_sqrt+0x92>
80003ddc:	f0 09 16 0b 	lsr	r9,r8,0xb
80003de0:	21 5a       	sub	r10,21
80003de2:	b5 78       	lsl	r8,0x15
80003de4:	58 09       	cp.w	r9,0
80003de6:	cf b0       	breq	80003ddc <__ieee754_sqrt+0x64>
80003de8:	30 0b       	mov	r11,0
80003dea:	c0 38       	rjmp	80003df0 <__ieee754_sqrt+0x78>
80003dec:	a1 79       	lsl	r9,0x1
80003dee:	2f fb       	sub	r11,-1
80003df0:	ed b9 00 14 	bld	r9,0x14
80003df4:	cf c1       	brne	80003dec <__ieee754_sqrt+0x74>
80003df6:	2f fa       	sub	r10,-1
80003df8:	f6 0c 11 20 	rsub	r12,r11,32
80003dfc:	16 1a       	sub	r10,r11
80003dfe:	f0 0c 0a 4c 	lsr	r12,r8,r12
80003e02:	f0 0b 09 48 	lsl	r8,r8,r11
80003e06:	f9 e9 10 09 	or	r9,r12,r9
80003e0a:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
80003e0e:	f4 c6 03 ff 	sub	r6,r10,1023
80003e12:	b5 a9       	sbr	r9,0x14
80003e14:	ed b6 00 00 	bld	r6,0x0
80003e18:	c0 61       	brne	80003e24 <__ieee754_sqrt+0xac>
80003e1a:	f0 0a 16 1f 	lsr	r10,r8,0x1f
80003e1e:	a1 78       	lsl	r8,0x1
80003e20:	f4 09 00 19 	add	r9,r10,r9<<0x1
80003e24:	30 07       	mov	r7,0
80003e26:	f0 0a 15 01 	lsl	r10,r8,0x1
80003e2a:	0e 9c       	mov	r12,r7
80003e2c:	bf 98       	lsr	r8,0x1f
80003e2e:	fc 1b 00 20 	movh	r11,0x20
80003e32:	f0 09 00 18 	add	r8,r8,r9<<0x1
80003e36:	0e 99       	mov	r9,r7
80003e38:	f2 0b 00 0e 	add	lr,r9,r11
80003e3c:	2f f7       	sub	r7,-1
80003e3e:	10 3e       	cp.w	lr,r8
80003e40:	f1 de ea 18 	suble	r8,r8,lr
80003e44:	f9 db ea 0c 	addle	r12,r12,r11
80003e48:	fd db ea 09 	addle	r9,lr,r11
80003e4c:	f4 0e 16 1f 	lsr	lr,r10,0x1f
80003e50:	a1 9b       	lsr	r11,0x1
80003e52:	fc 08 00 18 	add	r8,lr,r8<<0x1
80003e56:	a1 7a       	lsl	r10,0x1
80003e58:	59 67       	cp.w	r7,22
80003e5a:	ce f1       	brne	80003e38 <__ieee754_sqrt+0xc0>
80003e5c:	30 07       	mov	r7,0
80003e5e:	fc 15 80 00 	movh	r5,0x8000
80003e62:	0e 9b       	mov	r11,r7
80003e64:	0e 94       	mov	r4,r7
80003e66:	0e 92       	mov	r2,r7
80003e68:	ea 04 00 0e 	add	lr,r5,r4
80003e6c:	10 39       	cp.w	r9,r8
80003e6e:	c0 95       	brlt	80003e80 <__ieee754_sqrt+0x108>
80003e70:	5f 03       	sreq	r3
80003e72:	14 3e       	cp.w	lr,r10
80003e74:	5f 81       	srls	r1
80003e76:	e3 e3 00 03 	and	r3,r1,r3
80003e7a:	e4 03 18 00 	cp.b	r3,r2
80003e7e:	c1 70       	breq	80003eac <__ieee754_sqrt+0x134>
80003e80:	1c 93       	mov	r3,lr
80003e82:	fc 05 00 04 	add	r4,lr,r5
80003e86:	e6 13 80 00 	andh	r3,0x8000,COH
80003e8a:	fc 11 80 00 	movh	r1,0x8000
80003e8e:	02 33       	cp.w	r3,r1
80003e90:	c0 61       	brne	80003e9c <__ieee754_sqrt+0x124>
80003e92:	58 04       	cp.w	r4,0
80003e94:	c0 45       	brlt	80003e9c <__ieee754_sqrt+0x124>
80003e96:	f2 c3 ff ff 	sub	r3,r9,-1
80003e9a:	c0 28       	rjmp	80003e9e <__ieee754_sqrt+0x126>
80003e9c:	12 93       	mov	r3,r9
80003e9e:	12 18       	sub	r8,r9
80003ea0:	0a 0b       	add	r11,r5
80003ea2:	1c 3a       	cp.w	r10,lr
80003ea4:	f7 b8 03 01 	sublo	r8,1
80003ea8:	06 99       	mov	r9,r3
80003eaa:	1c 1a       	sub	r10,lr
80003eac:	f4 0e 16 1f 	lsr	lr,r10,0x1f
80003eb0:	a1 95       	lsr	r5,0x1
80003eb2:	2f f7       	sub	r7,-1
80003eb4:	fc 08 00 18 	add	r8,lr,r8<<0x1
80003eb8:	a1 7a       	lsl	r10,0x1
80003eba:	e0 47 00 20 	cp.w	r7,32
80003ebe:	cd 51       	brne	80003e68 <__ieee754_sqrt+0xf0>
80003ec0:	14 48       	or	r8,r10
80003ec2:	c0 a0       	breq	80003ed6 <__ieee754_sqrt+0x15e>
80003ec4:	f1 db c0 01 	bfextu	r8,r11,0x0,0x1
80003ec8:	5b fb       	cp.w	r11,-1
80003eca:	f7 bc 00 ff 	subeq	r12,-1
80003ece:	f9 bb 00 00 	moveq	r11,0
80003ed2:	f1 db e1 0b 	addne	r11,r8,r11
80003ed6:	a1 9b       	lsr	r11,0x1
80003ed8:	16 99       	mov	r9,r11
80003eda:	bf b9       	sbr	r9,0x1f
80003edc:	ec 0a 14 01 	asr	r10,r6,0x1
80003ee0:	f8 08 14 01 	asr	r8,r12,0x1
80003ee4:	b5 6a       	lsl	r10,0x14
80003ee6:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80003eea:	f2 0b 17 10 	movne	r11,r9
80003eee:	fc 19 3f e0 	movh	r9,0x3fe0
80003ef2:	16 96       	mov	r6,r11
80003ef4:	12 0a       	add	r10,r9
80003ef6:	f4 08 00 08 	add	r8,r10,r8
80003efa:	10 97       	mov	r7,r8
80003efc:	0c 9a       	mov	r10,r6
80003efe:	0e 9b       	mov	r11,r7
80003f00:	d8 32       	popm	r0-r7,pc
80003f02:	d7 03       	nop

80003f04 <__kernel_cos>:
80003f04:	d4 31       	pushm	r0-r7,lr
80003f06:	20 6d       	sub	sp,24
80003f08:	fa e9 00 08 	st.d	sp[8],r8
80003f0c:	14 92       	mov	r2,r10
80003f0e:	16 93       	mov	r3,r11
80003f10:	14 96       	mov	r6,r10
80003f12:	ef db c0 1f 	bfextu	r7,r11,0x0,0x1f
80003f16:	e0 69 ff ff 	mov	r9,65535
80003f1a:	ea 19 3e 3f 	orh	r9,0x3e3f
80003f1e:	12 37       	cp.w	r7,r9
80003f20:	e0 89 00 09 	brgt	80003f32 <__kernel_cos+0x2e>
80003f24:	e0 a0 08 74 	rcall	8000500c <__avr32_f64_to_s32>
80003f28:	c0 51       	brne	80003f32 <__kernel_cos+0x2e>
80003f2a:	30 0a       	mov	r10,0
80003f2c:	fc 1b 3f f0 	movh	r11,0x3ff0
80003f30:	cd b8       	rjmp	800040e6 <__kernel_cos+0x1e2>
80003f32:	04 98       	mov	r8,r2
80003f34:	06 99       	mov	r9,r3
80003f36:	04 9a       	mov	r10,r2
80003f38:	06 9b       	mov	r11,r3
80003f3a:	e0 a0 06 25 	rcall	80004b84 <__avr32_f64_mul>
80003f3e:	e0 68 38 d4 	mov	r8,14548
80003f42:	ea 18 be 88 	orh	r8,0xbe88
80003f46:	14 94       	mov	r4,r10
80003f48:	16 95       	mov	r5,r11
80003f4a:	e0 69 fa e9 	mov	r9,64233
80003f4e:	ea 19 bd a8 	orh	r9,0xbda8
80003f52:	e0 a0 06 19 	rcall	80004b84 <__avr32_f64_mul>
80003f56:	e0 68 b1 c4 	mov	r8,45508
80003f5a:	ea 18 bd b4 	orh	r8,0xbdb4
80003f5e:	e0 69 ee 9e 	mov	r9,61086
80003f62:	ea 19 3e 21 	orh	r9,0x3e21
80003f66:	e0 a0 07 c9 	rcall	80004ef8 <__avr32_f64_add>
80003f6a:	14 98       	mov	r8,r10
80003f6c:	16 99       	mov	r9,r11
80003f6e:	08 9a       	mov	r10,r4
80003f70:	0a 9b       	mov	r11,r5
80003f72:	e0 a0 06 09 	rcall	80004b84 <__avr32_f64_mul>
80003f76:	e0 68 52 ad 	mov	r8,21165
80003f7a:	ea 18 80 9c 	orh	r8,0x809c
80003f7e:	e0 69 7e 4f 	mov	r9,32335
80003f82:	ea 19 3e 92 	orh	r9,0x3e92
80003f86:	e0 a0 06 eb 	rcall	80004d5c <__avr32_f64_sub>
80003f8a:	14 98       	mov	r8,r10
80003f8c:	16 99       	mov	r9,r11
80003f8e:	08 9a       	mov	r10,r4
80003f90:	0a 9b       	mov	r11,r5
80003f92:	e0 a0 05 f9 	rcall	80004b84 <__avr32_f64_mul>
80003f96:	e0 68 15 90 	mov	r8,5520
80003f9a:	ea 18 19 cb 	orh	r8,0x19cb
80003f9e:	e0 69 01 a0 	mov	r9,416
80003fa2:	ea 19 3e fa 	orh	r9,0x3efa
80003fa6:	e0 a0 07 a9 	rcall	80004ef8 <__avr32_f64_add>
80003faa:	14 98       	mov	r8,r10
80003fac:	16 99       	mov	r9,r11
80003fae:	08 9a       	mov	r10,r4
80003fb0:	0a 9b       	mov	r11,r5
80003fb2:	e0 a0 05 e9 	rcall	80004b84 <__avr32_f64_mul>
80003fb6:	e0 68 51 77 	mov	r8,20855
80003fba:	ea 18 16 c1 	orh	r8,0x16c1
80003fbe:	e0 69 c1 6c 	mov	r9,49516
80003fc2:	ea 19 3f 56 	orh	r9,0x3f56
80003fc6:	e0 a0 06 cb 	rcall	80004d5c <__avr32_f64_sub>
80003fca:	14 98       	mov	r8,r10
80003fcc:	16 99       	mov	r9,r11
80003fce:	08 9a       	mov	r10,r4
80003fd0:	0a 9b       	mov	r11,r5
80003fd2:	e0 a0 05 d9 	rcall	80004b84 <__avr32_f64_mul>
80003fd6:	e0 68 55 4c 	mov	r8,21836
80003fda:	ea 18 55 55 	orh	r8,0x5555
80003fde:	e0 69 55 55 	mov	r9,21845
80003fe2:	ea 19 3f a5 	orh	r9,0x3fa5
80003fe6:	e0 a0 07 89 	rcall	80004ef8 <__avr32_f64_add>
80003fea:	14 98       	mov	r8,r10
80003fec:	16 99       	mov	r9,r11
80003fee:	08 9a       	mov	r10,r4
80003ff0:	0a 9b       	mov	r11,r5
80003ff2:	e0 a0 05 c9 	rcall	80004b84 <__avr32_f64_mul>
80003ff6:	fa eb 00 00 	st.d	sp[0],r10
80003ffa:	e0 68 33 32 	mov	r8,13106
80003ffe:	ea 18 3f d3 	orh	r8,0x3fd3
80004002:	10 37       	cp.w	r7,r8
80004004:	e0 89 00 2b 	brgt	8000405a <__kernel_cos+0x156>
80004008:	30 08       	mov	r8,0
8000400a:	fc 19 3f e0 	movh	r9,0x3fe0
8000400e:	08 9a       	mov	r10,r4
80004010:	0a 9b       	mov	r11,r5
80004012:	e0 a0 05 b9 	rcall	80004b84 <__avr32_f64_mul>
80004016:	fa e8 00 00 	ld.d	r8,sp[0]
8000401a:	14 90       	mov	r0,r10
8000401c:	16 91       	mov	r1,r11
8000401e:	08 9a       	mov	r10,r4
80004020:	0a 9b       	mov	r11,r5
80004022:	e0 a0 05 b1 	rcall	80004b84 <__avr32_f64_mul>
80004026:	fa e8 00 08 	ld.d	r8,sp[8]
8000402a:	16 97       	mov	r7,r11
8000402c:	14 96       	mov	r6,r10
8000402e:	06 9b       	mov	r11,r3
80004030:	04 9a       	mov	r10,r2
80004032:	e0 a0 05 a9 	rcall	80004b84 <__avr32_f64_mul>
80004036:	14 98       	mov	r8,r10
80004038:	16 99       	mov	r9,r11
8000403a:	0c 9a       	mov	r10,r6
8000403c:	0e 9b       	mov	r11,r7
8000403e:	e0 a0 06 8f 	rcall	80004d5c <__avr32_f64_sub>
80004042:	14 98       	mov	r8,r10
80004044:	16 99       	mov	r9,r11
80004046:	00 9a       	mov	r10,r0
80004048:	02 9b       	mov	r11,r1
8000404a:	e0 a0 06 89 	rcall	80004d5c <__avr32_f64_sub>
8000404e:	14 98       	mov	r8,r10
80004050:	16 99       	mov	r9,r11
80004052:	30 0a       	mov	r10,0
80004054:	fc 1b 3f f0 	movh	r11,0x3ff0
80004058:	c4 58       	rjmp	800040e2 <__kernel_cos+0x1de>
8000405a:	fc 19 3f e9 	movh	r9,0x3fe9
8000405e:	12 37       	cp.w	r7,r9
80004060:	e0 8a 00 06 	brle	8000406c <__kernel_cos+0x168>
80004064:	30 06       	mov	r6,0
80004066:	fc 17 3f d2 	movh	r7,0x3fd2
8000406a:	c0 88       	rjmp	8000407a <__kernel_cos+0x176>
8000406c:	fc 1a ff e0 	movh	r10,0xffe0
80004070:	30 08       	mov	r8,0
80004072:	ee 0a 00 09 	add	r9,r7,r10
80004076:	10 96       	mov	r6,r8
80004078:	12 97       	mov	r7,r9
8000407a:	0c 98       	mov	r8,r6
8000407c:	0e 99       	mov	r9,r7
8000407e:	30 0a       	mov	r10,0
80004080:	fc 1b 3f f0 	movh	r11,0x3ff0
80004084:	e0 a0 06 6c 	rcall	80004d5c <__avr32_f64_sub>
80004088:	30 08       	mov	r8,0
8000408a:	fa eb 00 10 	st.d	sp[16],r10
8000408e:	fc 19 3f e0 	movh	r9,0x3fe0
80004092:	08 9a       	mov	r10,r4
80004094:	0a 9b       	mov	r11,r5
80004096:	e0 a0 05 77 	rcall	80004b84 <__avr32_f64_mul>
8000409a:	0c 98       	mov	r8,r6
8000409c:	0e 99       	mov	r9,r7
8000409e:	e0 a0 06 5f 	rcall	80004d5c <__avr32_f64_sub>
800040a2:	fa e8 00 00 	ld.d	r8,sp[0]
800040a6:	14 90       	mov	r0,r10
800040a8:	16 91       	mov	r1,r11
800040aa:	08 9a       	mov	r10,r4
800040ac:	0a 9b       	mov	r11,r5
800040ae:	e0 a0 05 6b 	rcall	80004b84 <__avr32_f64_mul>
800040b2:	fa e8 00 08 	ld.d	r8,sp[8]
800040b6:	16 97       	mov	r7,r11
800040b8:	14 96       	mov	r6,r10
800040ba:	06 9b       	mov	r11,r3
800040bc:	04 9a       	mov	r10,r2
800040be:	e0 a0 05 63 	rcall	80004b84 <__avr32_f64_mul>
800040c2:	14 98       	mov	r8,r10
800040c4:	16 99       	mov	r9,r11
800040c6:	0c 9a       	mov	r10,r6
800040c8:	0e 9b       	mov	r11,r7
800040ca:	e0 a0 06 49 	rcall	80004d5c <__avr32_f64_sub>
800040ce:	14 98       	mov	r8,r10
800040d0:	16 99       	mov	r9,r11
800040d2:	00 9a       	mov	r10,r0
800040d4:	02 9b       	mov	r11,r1
800040d6:	e0 a0 06 43 	rcall	80004d5c <__avr32_f64_sub>
800040da:	14 98       	mov	r8,r10
800040dc:	16 99       	mov	r9,r11
800040de:	fa ea 00 10 	ld.d	r10,sp[16]
800040e2:	e0 a0 06 3d 	rcall	80004d5c <__avr32_f64_sub>
800040e6:	2f ad       	sub	sp,-24
800040e8:	d8 32       	popm	r0-r7,pc
800040ea:	d7 03       	nop

800040ec <__kernel_rem_pio2>:
800040ec:	d4 31       	pushm	r0-r7,lr
800040ee:	fa cd 02 70 	sub	sp,sp,624
800040f2:	50 b9       	stdsp	sp[0x2c],r9
800040f4:	fa f9 02 94 	ld.w	r9,sp[660]
800040f8:	50 68       	stdsp	sp[0x18],r8
800040fa:	50 c9       	stdsp	sp[0x30],r9
800040fc:	16 94       	mov	r4,r11
800040fe:	40 b8       	lddsp	r8,sp[0x2c]
80004100:	fe c9 dd 08 	sub	r9,pc,-8952
80004104:	20 18       	sub	r8,1
80004106:	40 6b       	lddsp	r11,sp[0x18]
80004108:	f2 0b 03 29 	ld.w	r9,r9[r11<<0x2]
8000410c:	50 58       	stdsp	sp[0x14],r8
8000410e:	50 39       	stdsp	sp[0xc],r9
80004110:	30 08       	mov	r8,0
80004112:	f4 c9 00 03 	sub	r9,r10,3
80004116:	10 97       	mov	r7,r8
80004118:	31 83       	mov	r3,24
8000411a:	f2 03 0c 02 	divs	r2,r9,r3
8000411e:	f0 02 0c 48 	max	r8,r8,r2
80004122:	40 59       	lddsp	r9,sp[0x14]
80004124:	10 96       	mov	r6,r8
80004126:	10 93       	mov	r3,r8
80004128:	50 78       	stdsp	sp[0x1c],r8
8000412a:	40 31       	lddsp	r1,sp[0xc]
8000412c:	5c d6       	com	r6
8000412e:	12 13       	sub	r3,r9
80004130:	ec 06 00 16 	add	r6,r6,r6<<0x1
80004134:	40 c8       	lddsp	r8,sp[0x30]
80004136:	50 ac       	stdsp	sp[0x28],r12
80004138:	12 01       	add	r1,r9
8000413a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000413e:	fa c2 fe 80 	sub	r2,sp,-384
80004142:	f0 03 00 25 	add	r5,r8,r3<<0x2
80004146:	c0 d8       	rjmp	80004160 <__kernel_rem_pio2+0x74>
80004148:	ee 03 00 08 	add	r8,r7,r3
8000414c:	c0 47       	brpl	80004154 <__kernel_rem_pio2+0x68>
8000414e:	30 0a       	mov	r10,0
80004150:	30 0b       	mov	r11,0
80004152:	c0 48       	rjmp	8000415a <__kernel_rem_pio2+0x6e>
80004154:	6a 0c       	ld.w	r12,r5[0x0]
80004156:	e0 a0 07 72 	rcall	8000503a <__avr32_s32_to_f64>
8000415a:	a5 2a       	st.d	r2++,r10
8000415c:	2f f7       	sub	r7,-1
8000415e:	2f c5       	sub	r5,-4
80004160:	02 37       	cp.w	r7,r1
80004162:	fe 9a ff f3 	brle	80004148 <__kernel_rem_pio2+0x5c>
80004166:	fa c0 ff c0 	sub	r0,sp,-64
8000416a:	40 53       	lddsp	r3,sp[0x14]
8000416c:	30 02       	mov	r2,0
8000416e:	fa cc fe 80 	sub	r12,sp,-384
80004172:	0c 95       	mov	r5,r6
80004174:	c1 b8       	rjmp	800041aa <__kernel_rem_pio2+0xbe>
80004176:	ee e8 00 00 	ld.d	r8,r7[0]
8000417a:	50 0c       	stdsp	sp[0x0],r12
8000417c:	20 87       	sub	r7,8
8000417e:	a3 0b       	ld.d	r10,r1++
80004180:	e0 a0 05 02 	rcall	80004b84 <__avr32_f64_mul>
80004184:	14 98       	mov	r8,r10
80004186:	16 99       	mov	r9,r11
80004188:	fa ea 00 04 	ld.d	r10,sp[4]
8000418c:	e0 a0 06 b6 	rcall	80004ef8 <__avr32_f64_add>
80004190:	2f f6       	sub	r6,-1
80004192:	fa eb 00 04 	st.d	sp[4],r10
80004196:	40 0c       	lddsp	r12,sp[0x0]
80004198:	40 5b       	lddsp	r11,sp[0x14]
8000419a:	16 36       	cp.w	r6,r11
8000419c:	fe 9a ff ed 	brle	80004176 <__kernel_rem_pio2+0x8a>
800041a0:	fa e8 00 04 	ld.d	r8,sp[4]
800041a4:	2f f2       	sub	r2,-1
800041a6:	a1 28       	st.d	r0++,r8
800041a8:	2f f3       	sub	r3,-1
800041aa:	40 38       	lddsp	r8,sp[0xc]
800041ac:	10 32       	cp.w	r2,r8
800041ae:	e0 89 00 0b 	brgt	800041c4 <__kernel_rem_pio2+0xd8>
800041b2:	30 0a       	mov	r10,0
800041b4:	30 0b       	mov	r11,0
800041b6:	40 a1       	lddsp	r1,sp[0x28]
800041b8:	f8 03 00 37 	add	r7,r12,r3<<0x3
800041bc:	fa eb 00 04 	st.d	sp[4],r10
800041c0:	30 06       	mov	r6,0
800041c2:	ce bb       	rjmp	80004198 <__kernel_rem_pio2+0xac>
800041c4:	40 38       	lddsp	r8,sp[0xc]
800041c6:	fa ca fd e0 	sub	r10,sp,-544
800041ca:	20 18       	sub	r8,1
800041cc:	0a 96       	mov	r6,r5
800041ce:	f4 08 00 2a 	add	r10,r10,r8<<0x2
800041d2:	40 37       	lddsp	r7,sp[0xc]
800041d4:	50 fa       	stdsp	sp[0x3c],r10
800041d6:	50 e4       	stdsp	sp[0x38],r4
800041d8:	fa c9 fd 90 	sub	r9,sp,-624
800041dc:	f2 07 00 38 	add	r8,r9,r7<<0x3
800041e0:	ee c5 00 01 	sub	r5,r7,1
800041e4:	f0 e2 fd d0 	ld.d	r2,r8[-560]
800041e8:	fa c1 fd e0 	sub	r1,sp,-544
800041ec:	fa c8 ff c0 	sub	r8,sp,-64
800041f0:	50 11       	stdsp	sp[0x4],r1
800041f2:	f0 05 00 34 	add	r4,r8,r5<<0x3
800041f6:	0e 90       	mov	r0,r7
800041f8:	c2 48       	rjmp	80004240 <__kernel_rem_pio2+0x154>
800041fa:	d7 03       	nop
800041fc:	e0 a0 04 c4 	rcall	80004b84 <__avr32_f64_mul>
80004200:	e0 a0 07 06 	rcall	8000500c <__avr32_f64_to_s32>
80004204:	e0 a0 07 1b 	rcall	8000503a <__avr32_s32_to_f64>
80004208:	30 08       	mov	r8,0
8000420a:	fc 19 c1 70 	movh	r9,0xc170
8000420e:	fa eb 00 20 	st.d	sp[32],r10
80004212:	e0 a0 04 b9 	rcall	80004b84 <__avr32_f64_mul>
80004216:	14 98       	mov	r8,r10
80004218:	16 99       	mov	r9,r11
8000421a:	04 9a       	mov	r10,r2
8000421c:	06 9b       	mov	r11,r3
8000421e:	e0 a0 06 6d 	rcall	80004ef8 <__avr32_f64_add>
80004222:	e0 a0 06 f5 	rcall	8000500c <__avr32_f64_to_s32>
80004226:	40 1a       	lddsp	r10,sp[0x4]
80004228:	14 ac       	st.w	r10++,r12
8000422a:	e8 e8 00 00 	ld.d	r8,r4[0]
8000422e:	50 1a       	stdsp	sp[0x4],r10
80004230:	20 10       	sub	r0,1
80004232:	fa ea 00 20 	ld.d	r10,sp[32]
80004236:	20 84       	sub	r4,8
80004238:	e0 a0 06 60 	rcall	80004ef8 <__avr32_f64_add>
8000423c:	14 92       	mov	r2,r10
8000423e:	16 93       	mov	r3,r11
80004240:	30 08       	mov	r8,0
80004242:	fc 19 3e 70 	movh	r9,0x3e70
80004246:	04 9a       	mov	r10,r2
80004248:	06 9b       	mov	r11,r3
8000424a:	58 00       	cp.w	r0,0
8000424c:	fe 99 ff d8 	brgt	800041fc <__kernel_rem_pio2+0x110>
80004250:	0c 9c       	mov	r12,r6
80004252:	e0 a0 04 1f 	rcall	80004a90 <scalbn>
80004256:	30 08       	mov	r8,0
80004258:	fc 19 3f c0 	movh	r9,0x3fc0
8000425c:	14 92       	mov	r2,r10
8000425e:	16 93       	mov	r3,r11
80004260:	e0 a0 04 92 	rcall	80004b84 <__avr32_f64_mul>
80004264:	e0 a0 03 76 	rcall	80004950 <floor>
80004268:	30 08       	mov	r8,0
8000426a:	fc 19 c0 20 	movh	r9,0xc020
8000426e:	e0 a0 04 8b 	rcall	80004b84 <__avr32_f64_mul>
80004272:	14 98       	mov	r8,r10
80004274:	16 99       	mov	r9,r11
80004276:	04 9a       	mov	r10,r2
80004278:	06 9b       	mov	r11,r3
8000427a:	e0 a0 06 3f 	rcall	80004ef8 <__avr32_f64_add>
8000427e:	14 92       	mov	r2,r10
80004280:	16 93       	mov	r3,r11
80004282:	e0 a0 06 c5 	rcall	8000500c <__avr32_f64_to_s32>
80004286:	18 90       	mov	r0,r12
80004288:	e0 a0 06 d9 	rcall	8000503a <__avr32_s32_to_f64>
8000428c:	14 98       	mov	r8,r10
8000428e:	16 99       	mov	r9,r11
80004290:	04 9a       	mov	r10,r2
80004292:	06 9b       	mov	r11,r3
80004294:	e0 a0 05 64 	rcall	80004d5c <__avr32_f64_sub>
80004298:	fa eb 00 04 	st.d	sp[4],r10
8000429c:	58 06       	cp.w	r6,0
8000429e:	e0 8a 00 18 	brle	800042ce <__kernel_rem_pio2+0x1e2>
800042a2:	fa c8 fd 90 	sub	r8,sp,-624
800042a6:	ec 0b 11 18 	rsub	r11,r6,24
800042aa:	f0 05 00 29 	add	r9,r8,r5<<0x2
800042ae:	ec 0c 11 17 	rsub	r12,r6,23
800042b2:	f2 fa ff b0 	ld.w	r10,r9[-80]
800042b6:	f4 0b 08 48 	asr	r8,r10,r11
800042ba:	f0 0b 09 4b 	lsl	r11,r8,r11
800042be:	10 00       	add	r0,r8
800042c0:	f4 0b 01 0b 	sub	r11,r10,r11
800042c4:	f3 4b ff b0 	st.w	r9[-80],r11
800042c8:	f6 0c 08 44 	asr	r4,r11,r12
800042cc:	c1 58       	rjmp	800042f6 <__kernel_rem_pio2+0x20a>
800042ce:	58 06       	cp.w	r6,0
800042d0:	c0 91       	brne	800042e2 <__kernel_rem_pio2+0x1f6>
800042d2:	fa cb fd 90 	sub	r11,sp,-624
800042d6:	f6 05 00 28 	add	r8,r11,r5<<0x2
800042da:	f0 f4 ff b0 	ld.w	r4,r8[-80]
800042de:	b7 54       	asr	r4,0x17
800042e0:	c0 b8       	rjmp	800042f6 <__kernel_rem_pio2+0x20a>
800042e2:	30 08       	mov	r8,0
800042e4:	fc 19 3f e0 	movh	r9,0x3fe0
800042e8:	e0 a0 07 2c 	rcall	80005140 <__avr32_f64_cmp_ge>
800042ec:	c0 31       	brne	800042f2 <__kernel_rem_pio2+0x206>
800042ee:	30 04       	mov	r4,0
800042f0:	c5 58       	rjmp	8000439a <__kernel_rem_pio2+0x2ae>
800042f2:	30 24       	mov	r4,2
800042f4:	c0 48       	rjmp	800042fc <__kernel_rem_pio2+0x210>
800042f6:	58 04       	cp.w	r4,0
800042f8:	e0 8a 00 51 	brle	8000439a <__kernel_rem_pio2+0x2ae>
800042fc:	30 08       	mov	r8,0
800042fe:	2f f0       	sub	r0,-1
80004300:	10 93       	mov	r3,r8
80004302:	c1 48       	rjmp	8000432a <__kernel_rem_pio2+0x23e>
80004304:	62 09       	ld.w	r9,r1[0x0]
80004306:	58 03       	cp.w	r3,0
80004308:	c0 81       	brne	80004318 <__kernel_rem_pio2+0x22c>
8000430a:	58 09       	cp.w	r9,0
8000430c:	c0 d0       	breq	80004326 <__kernel_rem_pio2+0x23a>
8000430e:	fc 1a 01 00 	movh	r10,0x100
80004312:	12 1a       	sub	r10,r9
80004314:	83 0a       	st.w	r1[0x0],r10
80004316:	c0 78       	rjmp	80004324 <__kernel_rem_pio2+0x238>
80004318:	e0 6b ff ff 	mov	r11,65535
8000431c:	ea 1b 00 ff 	orh	r11,0xff
80004320:	12 1b       	sub	r11,r9
80004322:	83 0b       	st.w	r1[0x0],r11
80004324:	30 13       	mov	r3,1
80004326:	2f f8       	sub	r8,-1
80004328:	2f c1       	sub	r1,-4
8000432a:	0e 38       	cp.w	r8,r7
8000432c:	ce c5       	brlt	80004304 <__kernel_rem_pio2+0x218>
8000432e:	58 06       	cp.w	r6,0
80004330:	e0 8a 00 1a 	brle	80004364 <__kernel_rem_pio2+0x278>
80004334:	58 16       	cp.w	r6,1
80004336:	c0 40       	breq	8000433e <__kernel_rem_pio2+0x252>
80004338:	58 26       	cp.w	r6,2
8000433a:	c1 51       	brne	80004364 <__kernel_rem_pio2+0x278>
8000433c:	c0 a8       	rjmp	80004350 <__kernel_rem_pio2+0x264>
8000433e:	fa ca fd 90 	sub	r10,sp,-624
80004342:	f4 05 00 28 	add	r8,r10,r5<<0x2
80004346:	f0 f9 ff b0 	ld.w	r9,r8[-80]
8000434a:	f3 d9 c0 17 	bfextu	r9,r9,0x0,0x17
8000434e:	c0 98       	rjmp	80004360 <__kernel_rem_pio2+0x274>
80004350:	fa c9 fd 90 	sub	r9,sp,-624
80004354:	f2 05 00 28 	add	r8,r9,r5<<0x2
80004358:	f0 f9 ff b0 	ld.w	r9,r8[-80]
8000435c:	f3 d9 c0 16 	bfextu	r9,r9,0x0,0x16
80004360:	f1 49 ff b0 	st.w	r8[-80],r9
80004364:	58 24       	cp.w	r4,2
80004366:	c1 a1       	brne	8000439a <__kernel_rem_pio2+0x2ae>
80004368:	fa e8 00 04 	ld.d	r8,sp[4]
8000436c:	30 0a       	mov	r10,0
8000436e:	fc 1b 3f f0 	movh	r11,0x3ff0
80004372:	e0 a0 04 f5 	rcall	80004d5c <__avr32_f64_sub>
80004376:	fa eb 00 04 	st.d	sp[4],r10
8000437a:	58 03       	cp.w	r3,0
8000437c:	c0 f0       	breq	8000439a <__kernel_rem_pio2+0x2ae>
8000437e:	0c 9c       	mov	r12,r6
80004380:	30 0a       	mov	r10,0
80004382:	fc 1b 3f f0 	movh	r11,0x3ff0
80004386:	e0 a0 03 85 	rcall	80004a90 <scalbn>
8000438a:	14 98       	mov	r8,r10
8000438c:	16 99       	mov	r9,r11
8000438e:	fa ea 00 04 	ld.d	r10,sp[4]
80004392:	e0 a0 04 e5 	rcall	80004d5c <__avr32_f64_sub>
80004396:	fa eb 00 04 	st.d	sp[4],r10
8000439a:	30 08       	mov	r8,0
8000439c:	30 09       	mov	r9,0
8000439e:	fa ea 00 04 	ld.d	r10,sp[4]
800043a2:	e0 a0 06 bc 	rcall	8000511a <__avr32_f64_cmp_eq>
800043a6:	c6 40       	breq	8000446e <__kernel_rem_pio2+0x382>
800043a8:	fa c8 fd e0 	sub	r8,sp,-544
800043ac:	f0 05 00 29 	add	r9,r8,r5<<0x2
800043b0:	30 08       	mov	r8,0
800043b2:	c0 58       	rjmp	800043bc <__kernel_rem_pio2+0x2d0>
800043b4:	72 0a       	ld.w	r10,r9[0x0]
800043b6:	20 15       	sub	r5,1
800043b8:	14 48       	or	r8,r10
800043ba:	20 49       	sub	r9,4
800043bc:	40 3b       	lddsp	r11,sp[0xc]
800043be:	16 35       	cp.w	r5,r11
800043c0:	cf a4       	brge	800043b4 <__kernel_rem_pio2+0x2c8>
800043c2:	58 08       	cp.w	r8,0
800043c4:	c5 b1       	brne	8000447a <__kernel_rem_pio2+0x38e>
800043c6:	40 f9       	lddsp	r9,sp[0x3c]
800043c8:	30 18       	mov	r8,1
800043ca:	c0 28       	rjmp	800043ce <__kernel_rem_pio2+0x2e2>
800043cc:	2f f8       	sub	r8,-1
800043ce:	72 0a       	ld.w	r10,r9[0x0]
800043d0:	20 49       	sub	r9,4
800043d2:	58 0a       	cp.w	r10,0
800043d4:	cf c0       	breq	800043cc <__kernel_rem_pio2+0x2e0>
800043d6:	0e 08       	add	r8,r7
800043d8:	40 ba       	lddsp	r10,sp[0x2c]
800043da:	50 d8       	stdsp	sp[0x34],r8
800043dc:	ee 0a 00 02 	add	r2,r7,r10
800043e0:	fa c8 fe 80 	sub	r8,sp,-384
800043e4:	04 91       	mov	r1,r2
800043e6:	ee c5 ff ff 	sub	r5,r7,-1
800043ea:	40 73       	lddsp	r3,sp[0x1c]
800043ec:	40 c9       	lddsp	r9,sp[0x30]
800043ee:	2f f3       	sub	r3,-1
800043f0:	fa cb ff c0 	sub	r11,sp,-64
800043f4:	0e 03       	add	r3,r7
800043f6:	f6 05 00 3b 	add	r11,r11,r5<<0x3
800043fa:	f2 03 00 23 	add	r3,r9,r3<<0x2
800043fe:	50 8b       	stdsp	sp[0x20],r11
80004400:	f0 02 00 32 	add	r2,r8,r2<<0x3
80004404:	0c 94       	mov	r4,r6
80004406:	c2 d8       	rjmp	80004460 <__kernel_rem_pio2+0x374>
80004408:	66 0c       	ld.w	r12,r3[0x0]
8000440a:	e0 a0 06 18 	rcall	8000503a <__avr32_s32_to_f64>
8000440e:	30 08       	mov	r8,0
80004410:	e4 eb 00 00 	st.d	r2[0],r10
80004414:	30 09       	mov	r9,0
80004416:	fa ca fe 80 	sub	r10,sp,-384
8000441a:	40 a0       	lddsp	r0,sp[0x28]
8000441c:	f4 01 00 37 	add	r7,r10,r1<<0x3
80004420:	30 06       	mov	r6,0
80004422:	fa e9 00 04 	st.d	sp[4],r8
80004426:	c1 08       	rjmp	80004446 <__kernel_rem_pio2+0x35a>
80004428:	ee e8 00 00 	ld.d	r8,r7[0]
8000442c:	a1 0b       	ld.d	r10,r0++
8000442e:	20 87       	sub	r7,8
80004430:	e0 a0 03 aa 	rcall	80004b84 <__avr32_f64_mul>
80004434:	2f f6       	sub	r6,-1
80004436:	14 98       	mov	r8,r10
80004438:	16 99       	mov	r9,r11
8000443a:	fa ea 00 04 	ld.d	r10,sp[4]
8000443e:	e0 a0 05 5d 	rcall	80004ef8 <__avr32_f64_add>
80004442:	fa eb 00 04 	st.d	sp[4],r10
80004446:	40 58       	lddsp	r8,sp[0x14]
80004448:	10 36       	cp.w	r6,r8
8000444a:	fe 9a ff ef 	brle	80004428 <__kernel_rem_pio2+0x33c>
8000444e:	40 89       	lddsp	r9,sp[0x20]
80004450:	fa ea 00 04 	ld.d	r10,sp[4]
80004454:	2f f5       	sub	r5,-1
80004456:	b3 2a       	st.d	r9++,r10
80004458:	2f c3       	sub	r3,-4
8000445a:	50 89       	stdsp	sp[0x20],r9
8000445c:	2f 82       	sub	r2,-8
8000445e:	2f f1       	sub	r1,-1
80004460:	40 d8       	lddsp	r8,sp[0x34]
80004462:	10 35       	cp.w	r5,r8
80004464:	fe 9a ff d2 	brle	80004408 <__kernel_rem_pio2+0x31c>
80004468:	08 96       	mov	r6,r4
8000446a:	10 97       	mov	r7,r8
8000446c:	cb 6a       	rjmp	800041d8 <__kernel_rem_pio2+0xec>
8000446e:	50 50       	stdsp	sp[0x14],r0
80004470:	08 95       	mov	r5,r4
80004472:	40 e4       	lddsp	r4,sp[0x38]
80004474:	58 0c       	cp.w	r12,0
80004476:	c1 30       	breq	8000449c <__kernel_rem_pio2+0x3b0>
80004478:	c0 48       	rjmp	80004480 <__kernel_rem_pio2+0x394>
8000447a:	08 95       	mov	r5,r4
8000447c:	50 50       	stdsp	sp[0x14],r0
8000447e:	40 e4       	lddsp	r4,sp[0x38]
80004480:	20 17       	sub	r7,1
80004482:	fa c8 fd e0 	sub	r8,sp,-544
80004486:	21 86       	sub	r6,24
80004488:	f0 07 00 28 	add	r8,r8,r7<<0x2
8000448c:	c0 38       	rjmp	80004492 <__kernel_rem_pio2+0x3a6>
8000448e:	20 17       	sub	r7,1
80004490:	21 86       	sub	r6,24
80004492:	70 09       	ld.w	r9,r8[0x0]
80004494:	20 48       	sub	r8,4
80004496:	58 09       	cp.w	r9,0
80004498:	cf b0       	breq	8000448e <__kernel_rem_pio2+0x3a2>
8000449a:	c4 48       	rjmp	80004522 <__kernel_rem_pio2+0x436>
8000449c:	fa ea 00 04 	ld.d	r10,sp[4]
800044a0:	ec 0c 11 00 	rsub	r12,r6,0
800044a4:	e0 a0 02 f6 	rcall	80004a90 <scalbn>
800044a8:	30 08       	mov	r8,0
800044aa:	14 90       	mov	r0,r10
800044ac:	16 91       	mov	r1,r11
800044ae:	fc 19 41 70 	movh	r9,0x4170
800044b2:	ee 03 15 02 	lsl	r3,r7,0x2
800044b6:	e0 a0 06 45 	rcall	80005140 <__avr32_f64_cmp_ge>
800044ba:	c2 a0       	breq	8000450e <__kernel_rem_pio2+0x422>
800044bc:	30 08       	mov	r8,0
800044be:	fc 19 3e 70 	movh	r9,0x3e70
800044c2:	00 9a       	mov	r10,r0
800044c4:	02 9b       	mov	r11,r1
800044c6:	e0 a0 03 5f 	rcall	80004b84 <__avr32_f64_mul>
800044ca:	e0 a0 05 a1 	rcall	8000500c <__avr32_f64_to_s32>
800044ce:	e0 a0 05 b6 	rcall	8000503a <__avr32_s32_to_f64>
800044d2:	30 08       	mov	r8,0
800044d4:	fc 19 c1 70 	movh	r9,0xc170
800044d8:	fa eb 00 04 	st.d	sp[4],r10
800044dc:	e0 a0 03 54 	rcall	80004b84 <__avr32_f64_mul>
800044e0:	16 99       	mov	r9,r11
800044e2:	14 98       	mov	r8,r10
800044e4:	02 9b       	mov	r11,r1
800044e6:	00 9a       	mov	r10,r0
800044e8:	e0 a0 05 08 	rcall	80004ef8 <__avr32_f64_add>
800044ec:	e0 a0 05 90 	rcall	8000500c <__avr32_f64_to_s32>
800044f0:	fa cb fd 90 	sub	r11,sp,-624
800044f4:	f6 03 00 03 	add	r3,r11,r3
800044f8:	2f f7       	sub	r7,-1
800044fa:	e7 4c ff b0 	st.w	r3[-80],r12
800044fe:	fa c9 fd 90 	sub	r9,sp,-624
80004502:	fa ea 00 04 	ld.d	r10,sp[4]
80004506:	2e 86       	sub	r6,-24
80004508:	f2 07 00 23 	add	r3,r9,r7<<0x2
8000450c:	c0 78       	rjmp	8000451a <__kernel_rem_pio2+0x42e>
8000450e:	fa c8 fd 90 	sub	r8,sp,-624
80004512:	00 9a       	mov	r10,r0
80004514:	f0 03 00 03 	add	r3,r8,r3
80004518:	02 9b       	mov	r11,r1
8000451a:	e0 a0 05 79 	rcall	8000500c <__avr32_f64_to_s32>
8000451e:	e7 4c ff b0 	st.w	r3[-80],r12
80004522:	0c 9c       	mov	r12,r6
80004524:	30 0a       	mov	r10,0
80004526:	fc 1b 3f f0 	movh	r11,0x3ff0
8000452a:	fa c3 fd e0 	sub	r3,sp,-544
8000452e:	e0 a0 02 b1 	rcall	80004a90 <scalbn>
80004532:	fa c2 ff c0 	sub	r2,sp,-64
80004536:	0e 96       	mov	r6,r7
80004538:	14 90       	mov	r0,r10
8000453a:	16 91       	mov	r1,r11
8000453c:	e6 07 00 23 	add	r3,r3,r7<<0x2
80004540:	e4 07 00 32 	add	r2,r2,r7<<0x3
80004544:	c1 88       	rjmp	80004574 <__kernel_rem_pio2+0x488>
80004546:	66 0c       	ld.w	r12,r3[0x0]
80004548:	e0 a0 05 79 	rcall	8000503a <__avr32_s32_to_f64>
8000454c:	14 98       	mov	r8,r10
8000454e:	16 99       	mov	r9,r11
80004550:	00 9a       	mov	r10,r0
80004552:	02 9b       	mov	r11,r1
80004554:	e0 a0 03 18 	rcall	80004b84 <__avr32_f64_mul>
80004558:	30 08       	mov	r8,0
8000455a:	e4 eb 00 00 	st.d	r2[0],r10
8000455e:	fc 19 3e 70 	movh	r9,0x3e70
80004562:	00 9a       	mov	r10,r0
80004564:	02 9b       	mov	r11,r1
80004566:	20 16       	sub	r6,1
80004568:	e0 a0 03 0e 	rcall	80004b84 <__avr32_f64_mul>
8000456c:	20 43       	sub	r3,4
8000456e:	20 82       	sub	r2,8
80004570:	14 90       	mov	r0,r10
80004572:	16 91       	mov	r1,r11
80004574:	58 06       	cp.w	r6,0
80004576:	ce 84       	brge	80004546 <__kernel_rem_pio2+0x45a>
80004578:	fa cc ff 20 	sub	r12,sp,-224
8000457c:	0a 91       	mov	r1,r5
8000457e:	0e 93       	mov	r3,r7
80004580:	30 02       	mov	r2,0
80004582:	18 96       	mov	r6,r12
80004584:	0e 95       	mov	r5,r7
80004586:	c1 c8       	rjmp	800045be <__kernel_rem_pio2+0x4d2>
80004588:	ad 09       	ld.d	r8,r6++
8000458a:	2f f7       	sub	r7,-1
8000458c:	a1 0b       	ld.d	r10,r0++
8000458e:	e0 a0 02 fb 	rcall	80004b84 <__avr32_f64_mul>
80004592:	14 98       	mov	r8,r10
80004594:	16 99       	mov	r9,r11
80004596:	fa ea 00 04 	ld.d	r10,sp[4]
8000459a:	e0 a0 04 af 	rcall	80004ef8 <__avr32_f64_add>
8000459e:	fa eb 00 04 	st.d	sp[4],r10
800045a2:	40 3b       	lddsp	r11,sp[0xc]
800045a4:	16 37       	cp.w	r7,r11
800045a6:	e0 89 00 05 	brgt	800045b0 <__kernel_rem_pio2+0x4c4>
800045aa:	04 37       	cp.w	r7,r2
800045ac:	fe 9a ff ee 	brle	80004588 <__kernel_rem_pio2+0x49c>
800045b0:	06 96       	mov	r6,r3
800045b2:	fa e8 00 04 	ld.d	r8,sp[4]
800045b6:	40 73       	lddsp	r3,sp[0x1c]
800045b8:	ad 28       	st.d	r6++,r8
800045ba:	20 13       	sub	r3,1
800045bc:	2f f2       	sub	r2,-1
800045be:	58 03       	cp.w	r3,0
800045c0:	c1 05       	brlt	800045e0 <__kernel_rem_pio2+0x4f4>
800045c2:	fa c8 ff c0 	sub	r8,sp,-64
800045c6:	30 0a       	mov	r10,0
800045c8:	f0 03 00 3c 	add	r12,r8,r3<<0x3
800045cc:	30 0b       	mov	r11,0
800045ce:	50 73       	stdsp	sp[0x1c],r3
800045d0:	fe c0 e1 c8 	sub	r0,pc,-7736
800045d4:	0c 93       	mov	r3,r6
800045d6:	fa eb 00 04 	st.d	sp[4],r10
800045da:	30 07       	mov	r7,0
800045dc:	18 96       	mov	r6,r12
800045de:	ce 2b       	rjmp	800045a2 <__kernel_rem_pio2+0x4b6>
800045e0:	0a 97       	mov	r7,r5
800045e2:	40 6a       	lddsp	r10,sp[0x18]
800045e4:	02 95       	mov	r5,r1
800045e6:	58 2a       	cp.w	r10,2
800045e8:	e0 89 00 07 	brgt	800045f6 <__kernel_rem_pio2+0x50a>
800045ec:	58 1a       	cp.w	r10,1
800045ee:	c1 14       	brge	80004610 <__kernel_rem_pio2+0x524>
800045f0:	58 0a       	cp.w	r10,0
800045f2:	c1 70       	breq	80004620 <__kernel_rem_pio2+0x534>
800045f4:	ce 58       	rjmp	800047be <__kernel_rem_pio2+0x6d2>
800045f6:	40 69       	lddsp	r9,sp[0x18]
800045f8:	58 39       	cp.w	r9,3
800045fa:	e0 81 00 e2 	brne	800047be <__kernel_rem_pio2+0x6d2>
800045fe:	ee c6 00 01 	sub	r6,r7,1
80004602:	fa c8 ff 20 	sub	r8,sp,-224
80004606:	0e 92       	mov	r2,r7
80004608:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000460c:	0c 93       	mov	r3,r6
8000460e:	c7 d8       	rjmp	80004708 <__kernel_rem_pio2+0x61c>
80004610:	fa c6 ff 20 	sub	r6,sp,-224
80004614:	30 0c       	mov	r12,0
80004616:	ec 07 00 36 	add	r6,r6,r7<<0x3
8000461a:	0e 93       	mov	r3,r7
8000461c:	18 9a       	mov	r10,r12
8000461e:	c2 98       	rjmp	80004670 <__kernel_rem_pio2+0x584>
80004620:	40 6c       	lddsp	r12,sp[0x18]
80004622:	0e 96       	mov	r6,r7
80004624:	fa c8 ff 20 	sub	r8,sp,-224
80004628:	18 9a       	mov	r10,r12
8000462a:	f0 07 00 37 	add	r7,r8,r7<<0x3
8000462e:	c0 a8       	rjmp	80004642 <__kernel_rem_pio2+0x556>
80004630:	ee e8 00 00 	ld.d	r8,r7[0]
80004634:	18 9b       	mov	r11,r12
80004636:	20 87       	sub	r7,8
80004638:	06 9a       	mov	r10,r3
8000463a:	20 16       	sub	r6,1
8000463c:	e0 a0 04 5e 	rcall	80004ef8 <__avr32_f64_add>
80004640:	16 9c       	mov	r12,r11
80004642:	14 93       	mov	r3,r10
80004644:	58 06       	cp.w	r6,0
80004646:	cf 54       	brge	80004630 <__kernel_rem_pio2+0x544>
80004648:	18 98       	mov	r8,r12
8000464a:	ee 18 80 00 	eorh	r8,0x8000
8000464e:	58 05       	cp.w	r5,0
80004650:	f0 0c 17 10 	movne	r12,r8
80004654:	14 98       	mov	r8,r10
80004656:	18 99       	mov	r9,r12
80004658:	e8 e9 00 00 	st.d	r4[0],r8
8000465c:	cb 18       	rjmp	800047be <__kernel_rem_pio2+0x6d2>
8000465e:	ec e8 00 00 	ld.d	r8,r6[0]
80004662:	18 9b       	mov	r11,r12
80004664:	04 9a       	mov	r10,r2
80004666:	20 13       	sub	r3,1
80004668:	e0 a0 04 48 	rcall	80004ef8 <__avr32_f64_add>
8000466c:	20 86       	sub	r6,8
8000466e:	16 9c       	mov	r12,r11
80004670:	14 92       	mov	r2,r10
80004672:	58 03       	cp.w	r3,0
80004674:	cf 54       	brge	8000465e <__kernel_rem_pio2+0x572>
80004676:	18 9b       	mov	r11,r12
80004678:	18 98       	mov	r8,r12
8000467a:	ee 18 80 00 	eorh	r8,0x8000
8000467e:	58 05       	cp.w	r5,0
80004680:	f0 0c 17 10 	movne	r12,r8
80004684:	18 93       	mov	r3,r12
80004686:	14 92       	mov	r2,r10
80004688:	16 99       	mov	r9,r11
8000468a:	e8 e3 00 00 	st.d	r4[0],r2
8000468e:	14 98       	mov	r8,r10
80004690:	fa c3 ff 18 	sub	r3,sp,-232
80004694:	fa ea 00 e0 	ld.d	r10,sp[224]
80004698:	30 16       	mov	r6,1
8000469a:	e0 a0 03 61 	rcall	80004d5c <__avr32_f64_sub>
8000469e:	c0 78       	rjmp	800046ac <__kernel_rem_pio2+0x5c0>
800046a0:	2f f6       	sub	r6,-1
800046a2:	a7 09       	ld.d	r8,r3++
800046a4:	18 9b       	mov	r11,r12
800046a6:	04 9a       	mov	r10,r2
800046a8:	e0 a0 04 28 	rcall	80004ef8 <__avr32_f64_add>
800046ac:	16 9c       	mov	r12,r11
800046ae:	14 92       	mov	r2,r10
800046b0:	0e 36       	cp.w	r6,r7
800046b2:	fe 9a ff f7 	brle	800046a0 <__kernel_rem_pio2+0x5b4>
800046b6:	16 98       	mov	r8,r11
800046b8:	ee 18 80 00 	eorh	r8,0x8000
800046bc:	58 05       	cp.w	r5,0
800046be:	f0 0c 17 10 	movne	r12,r8
800046c2:	14 98       	mov	r8,r10
800046c4:	18 99       	mov	r9,r12
800046c6:	e8 e9 00 08 	st.d	r4[8],r8
800046ca:	c7 a8       	rjmp	800047be <__kernel_rem_pio2+0x6d2>
800046cc:	e6 e0 00 00 	ld.d	r0,r3[0]
800046d0:	e6 e8 00 08 	ld.d	r8,r3[8]
800046d4:	00 9a       	mov	r10,r0
800046d6:	02 9b       	mov	r11,r1
800046d8:	e0 a0 04 10 	rcall	80004ef8 <__avr32_f64_add>
800046dc:	fa eb 00 0c 	st.d	sp[12],r10
800046e0:	14 98       	mov	r8,r10
800046e2:	16 99       	mov	r9,r11
800046e4:	00 9a       	mov	r10,r0
800046e6:	02 9b       	mov	r11,r1
800046e8:	e0 a0 03 3a 	rcall	80004d5c <__avr32_f64_sub>
800046ec:	14 98       	mov	r8,r10
800046ee:	16 99       	mov	r9,r11
800046f0:	e6 ea 00 08 	ld.d	r10,r3[8]
800046f4:	e0 a0 04 02 	rcall	80004ef8 <__avr32_f64_add>
800046f8:	fa e8 00 0c 	ld.d	r8,sp[12]
800046fc:	e6 eb 00 08 	st.d	r3[8],r10
80004700:	e6 e9 00 00 	st.d	r3[0],r8
80004704:	20 12       	sub	r2,1
80004706:	20 83       	sub	r3,8
80004708:	58 02       	cp.w	r2,0
8000470a:	fe 99 ff e1 	brgt	800046cc <__kernel_rem_pio2+0x5e0>
8000470e:	0e 93       	mov	r3,r7
80004710:	c2 08       	rjmp	80004750 <__kernel_rem_pio2+0x664>
80004712:	d7 03       	nop
80004714:	ec e0 00 00 	ld.d	r0,r6[0]
80004718:	ec e8 00 08 	ld.d	r8,r6[8]
8000471c:	00 9a       	mov	r10,r0
8000471e:	02 9b       	mov	r11,r1
80004720:	e0 a0 03 ec 	rcall	80004ef8 <__avr32_f64_add>
80004724:	fa eb 00 0c 	st.d	sp[12],r10
80004728:	14 98       	mov	r8,r10
8000472a:	16 99       	mov	r9,r11
8000472c:	00 9a       	mov	r10,r0
8000472e:	02 9b       	mov	r11,r1
80004730:	e0 a0 03 16 	rcall	80004d5c <__avr32_f64_sub>
80004734:	14 98       	mov	r8,r10
80004736:	16 99       	mov	r9,r11
80004738:	ec ea 00 08 	ld.d	r10,r6[8]
8000473c:	e0 a0 03 de 	rcall	80004ef8 <__avr32_f64_add>
80004740:	fa e8 00 0c 	ld.d	r8,sp[12]
80004744:	ec eb 00 08 	st.d	r6[8],r10
80004748:	ec e9 00 00 	st.d	r6[0],r8
8000474c:	20 13       	sub	r3,1
8000474e:	20 86       	sub	r6,8
80004750:	58 13       	cp.w	r3,1
80004752:	fe 99 ff e1 	brgt	80004714 <__kernel_rem_pio2+0x628>
80004756:	0e 96       	mov	r6,r7
80004758:	fa c8 ff 20 	sub	r8,sp,-224
8000475c:	30 0c       	mov	r12,0
8000475e:	f0 07 00 37 	add	r7,r8,r7<<0x3
80004762:	18 9a       	mov	r10,r12
80004764:	c0 a8       	rjmp	80004778 <__kernel_rem_pio2+0x68c>
80004766:	ee e8 00 00 	ld.d	r8,r7[0]
8000476a:	18 9b       	mov	r11,r12
8000476c:	20 87       	sub	r7,8
8000476e:	06 9a       	mov	r10,r3
80004770:	20 16       	sub	r6,1
80004772:	e0 a0 03 c3 	rcall	80004ef8 <__avr32_f64_add>
80004776:	16 9c       	mov	r12,r11
80004778:	14 93       	mov	r3,r10
8000477a:	58 16       	cp.w	r6,1
8000477c:	fe 99 ff f5 	brgt	80004766 <__kernel_rem_pio2+0x67a>
80004780:	58 05       	cp.w	r5,0
80004782:	c0 e1       	brne	8000479e <__kernel_rem_pio2+0x6b2>
80004784:	fa e8 00 e0 	ld.d	r8,sp[224]
80004788:	e8 e9 00 00 	st.d	r4[0],r8
8000478c:	fa e8 00 e8 	ld.d	r8,sp[232]
80004790:	e8 e9 00 08 	st.d	r4[8],r8
80004794:	18 99       	mov	r9,r12
80004796:	14 98       	mov	r8,r10
80004798:	e8 e9 00 10 	st.d	r4[16],r8
8000479c:	c1 18       	rjmp	800047be <__kernel_rem_pio2+0x6d2>
8000479e:	89 5a       	st.w	r4[0x14],r10
800047a0:	ee 1c 80 00 	eorh	r12,0x8000
800047a4:	89 4c       	st.w	r4[0x10],r12
800047a6:	43 88       	lddsp	r8,sp[0xe0]
800047a8:	ee 18 80 00 	eorh	r8,0x8000
800047ac:	89 08       	st.w	r4[0x0],r8
800047ae:	43 98       	lddsp	r8,sp[0xe4]
800047b0:	89 18       	st.w	r4[0x4],r8
800047b2:	43 a8       	lddsp	r8,sp[0xe8]
800047b4:	ee 18 80 00 	eorh	r8,0x8000
800047b8:	89 28       	st.w	r4[0x8],r8
800047ba:	43 b8       	lddsp	r8,sp[0xec]
800047bc:	89 38       	st.w	r4[0xc],r8
800047be:	40 58       	lddsp	r8,sp[0x14]
800047c0:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
800047c4:	fe 3d fd 90 	sub	sp,-624
800047c8:	d8 32       	popm	r0-r7,pc
800047ca:	d7 03       	nop

800047cc <__kernel_sin>:
800047cc:	d4 31       	pushm	r0-r7,lr
800047ce:	20 4d       	sub	sp,16
800047d0:	fa e9 00 08 	st.d	sp[8],r8
800047d4:	50 0c       	stdsp	sp[0x0],r12
800047d6:	14 96       	mov	r6,r10
800047d8:	16 97       	mov	r7,r11
800047da:	f1 db c0 1f 	bfextu	r8,r11,0x0,0x1f
800047de:	e0 69 ff ff 	mov	r9,65535
800047e2:	ea 19 3e 3f 	orh	r9,0x3e3f
800047e6:	12 38       	cp.w	r8,r9
800047e8:	e0 89 00 06 	brgt	800047f4 <__kernel_sin+0x28>
800047ec:	e0 a0 04 10 	rcall	8000500c <__avr32_f64_to_s32>
800047f0:	e0 80 00 a7 	breq	8000493e <__kernel_sin+0x172>
800047f4:	0c 98       	mov	r8,r6
800047f6:	0e 99       	mov	r9,r7
800047f8:	0c 9a       	mov	r10,r6
800047fa:	0e 9b       	mov	r11,r7
800047fc:	cc 4d       	rcall	80004b84 <__avr32_f64_mul>
800047fe:	0c 98       	mov	r8,r6
80004800:	14 94       	mov	r4,r10
80004802:	16 95       	mov	r5,r11
80004804:	0e 99       	mov	r9,r7
80004806:	cb fd       	rcall	80004b84 <__avr32_f64_mul>
80004808:	e0 68 d5 7c 	mov	r8,54652
8000480c:	ea 18 5a cf 	orh	r8,0x5acf
80004810:	e0 69 d9 3a 	mov	r9,55610
80004814:	ea 19 3d e5 	orh	r9,0x3de5
80004818:	14 90       	mov	r0,r10
8000481a:	16 91       	mov	r1,r11
8000481c:	08 9a       	mov	r10,r4
8000481e:	0a 9b       	mov	r11,r5
80004820:	cb 2d       	rcall	80004b84 <__avr32_f64_mul>
80004822:	e0 68 9c eb 	mov	r8,40171
80004826:	ea 18 8a 2b 	orh	r8,0x8a2b
8000482a:	e0 69 e5 e6 	mov	r9,58854
8000482e:	ea 19 3e 5a 	orh	r9,0x3e5a
80004832:	e0 a0 02 95 	rcall	80004d5c <__avr32_f64_sub>
80004836:	14 98       	mov	r8,r10
80004838:	16 99       	mov	r9,r11
8000483a:	08 9a       	mov	r10,r4
8000483c:	0a 9b       	mov	r11,r5
8000483e:	ca 3d       	rcall	80004b84 <__avr32_f64_mul>
80004840:	e0 68 fe 7d 	mov	r8,65149
80004844:	ea 18 57 b1 	orh	r8,0x57b1
80004848:	e0 69 1d e3 	mov	r9,7651
8000484c:	ea 19 3e c7 	orh	r9,0x3ec7
80004850:	e0 a0 03 54 	rcall	80004ef8 <__avr32_f64_add>
80004854:	14 98       	mov	r8,r10
80004856:	16 99       	mov	r9,r11
80004858:	08 9a       	mov	r10,r4
8000485a:	0a 9b       	mov	r11,r5
8000485c:	c9 4d       	rcall	80004b84 <__avr32_f64_mul>
8000485e:	e0 68 61 d5 	mov	r8,25045
80004862:	ea 18 19 c1 	orh	r8,0x19c1
80004866:	e0 69 01 a0 	mov	r9,416
8000486a:	ea 19 3f 2a 	orh	r9,0x3f2a
8000486e:	e0 a0 02 77 	rcall	80004d5c <__avr32_f64_sub>
80004872:	14 98       	mov	r8,r10
80004874:	16 99       	mov	r9,r11
80004876:	08 9a       	mov	r10,r4
80004878:	0a 9b       	mov	r11,r5
8000487a:	c8 5d       	rcall	80004b84 <__avr32_f64_mul>
8000487c:	e0 68 f8 a6 	mov	r8,63654
80004880:	ea 18 11 10 	orh	r8,0x1110
80004884:	e0 69 11 11 	mov	r9,4369
80004888:	ea 19 3f 81 	orh	r9,0x3f81
8000488c:	e0 a0 03 36 	rcall	80004ef8 <__avr32_f64_add>
80004890:	40 08       	lddsp	r8,sp[0x0]
80004892:	14 92       	mov	r2,r10
80004894:	16 93       	mov	r3,r11
80004896:	58 08       	cp.w	r8,0
80004898:	c1 c1       	brne	800048d0 <__kernel_sin+0x104>
8000489a:	14 98       	mov	r8,r10
8000489c:	06 99       	mov	r9,r3
8000489e:	08 9a       	mov	r10,r4
800048a0:	0a 9b       	mov	r11,r5
800048a2:	c7 1d       	rcall	80004b84 <__avr32_f64_mul>
800048a4:	e0 68 55 49 	mov	r8,21833
800048a8:	ea 18 55 55 	orh	r8,0x5555
800048ac:	e0 69 55 55 	mov	r9,21845
800048b0:	ea 19 3f c5 	orh	r9,0x3fc5
800048b4:	e0 a0 02 54 	rcall	80004d5c <__avr32_f64_sub>
800048b8:	14 98       	mov	r8,r10
800048ba:	16 99       	mov	r9,r11
800048bc:	00 9a       	mov	r10,r0
800048be:	02 9b       	mov	r11,r1
800048c0:	c6 2d       	rcall	80004b84 <__avr32_f64_mul>
800048c2:	14 98       	mov	r8,r10
800048c4:	16 99       	mov	r9,r11
800048c6:	0c 9a       	mov	r10,r6
800048c8:	0e 9b       	mov	r11,r7
800048ca:	e0 a0 03 17 	rcall	80004ef8 <__avr32_f64_add>
800048ce:	c3 68       	rjmp	8000493a <__kernel_sin+0x16e>
800048d0:	30 08       	mov	r8,0
800048d2:	fc 19 3f e0 	movh	r9,0x3fe0
800048d6:	fa ea 00 08 	ld.d	r10,sp[8]
800048da:	c5 5d       	rcall	80004b84 <__avr32_f64_mul>
800048dc:	04 98       	mov	r8,r2
800048de:	fa eb 00 00 	st.d	sp[0],r10
800048e2:	06 99       	mov	r9,r3
800048e4:	00 9a       	mov	r10,r0
800048e6:	02 9b       	mov	r11,r1
800048e8:	c4 ed       	rcall	80004b84 <__avr32_f64_mul>
800048ea:	14 98       	mov	r8,r10
800048ec:	16 99       	mov	r9,r11
800048ee:	fa ea 00 00 	ld.d	r10,sp[0]
800048f2:	e0 a0 02 35 	rcall	80004d5c <__avr32_f64_sub>
800048f6:	14 98       	mov	r8,r10
800048f8:	16 99       	mov	r9,r11
800048fa:	08 9a       	mov	r10,r4
800048fc:	0a 9b       	mov	r11,r5
800048fe:	c4 3d       	rcall	80004b84 <__avr32_f64_mul>
80004900:	fa e8 00 08 	ld.d	r8,sp[8]
80004904:	e0 a0 02 2c 	rcall	80004d5c <__avr32_f64_sub>
80004908:	e0 68 55 49 	mov	r8,21833
8000490c:	ea 18 55 55 	orh	r8,0x5555
80004910:	14 94       	mov	r4,r10
80004912:	16 95       	mov	r5,r11
80004914:	e0 69 55 55 	mov	r9,21845
80004918:	ea 19 3f c5 	orh	r9,0x3fc5
8000491c:	00 9a       	mov	r10,r0
8000491e:	02 9b       	mov	r11,r1
80004920:	c3 2d       	rcall	80004b84 <__avr32_f64_mul>
80004922:	14 98       	mov	r8,r10
80004924:	16 99       	mov	r9,r11
80004926:	08 9a       	mov	r10,r4
80004928:	0a 9b       	mov	r11,r5
8000492a:	e0 a0 02 e7 	rcall	80004ef8 <__avr32_f64_add>
8000492e:	14 98       	mov	r8,r10
80004930:	16 99       	mov	r9,r11
80004932:	0c 9a       	mov	r10,r6
80004934:	0e 9b       	mov	r11,r7
80004936:	e0 a0 02 13 	rcall	80004d5c <__avr32_f64_sub>
8000493a:	14 96       	mov	r6,r10
8000493c:	16 97       	mov	r7,r11
8000493e:	0c 9a       	mov	r10,r6
80004940:	0e 9b       	mov	r11,r7
80004942:	2f cd       	sub	sp,-16
80004944:	d8 32       	popm	r0-r7,pc
80004946:	d7 03       	nop

80004948 <fabs>:
80004948:	f3 db c0 1f 	bfextu	r9,r11,0x0,0x1f
8000494c:	12 9b       	mov	r11,r9
8000494e:	5e fc       	retal	r12

80004950 <floor>:
80004950:	d4 31       	pushm	r0-r7,lr
80004952:	e9 db c2 8b 	bfextu	r4,r11,0x14,0xb
80004956:	14 98       	mov	r8,r10
80004958:	16 99       	mov	r9,r11
8000495a:	14 92       	mov	r2,r10
8000495c:	16 93       	mov	r3,r11
8000495e:	16 97       	mov	r7,r11
80004960:	14 91       	mov	r1,r10
80004962:	14 96       	mov	r6,r10
80004964:	e8 c5 03 ff 	sub	r5,r4,1023
80004968:	59 35       	cp.w	r5,19
8000496a:	e0 89 00 48 	brgt	800049fa <floor+0xaa>
8000496e:	58 05       	cp.w	r5,0
80004970:	c2 04       	brge	800049b0 <floor+0x60>
80004972:	e0 68 75 9c 	mov	r8,30108
80004976:	ea 18 88 00 	orh	r8,0x8800
8000497a:	e0 69 e4 3c 	mov	r9,58428
8000497e:	ea 19 7e 37 	orh	r9,0x7e37
80004982:	e0 a0 02 bb 	rcall	80004ef8 <__avr32_f64_add>
80004986:	14 98       	mov	r8,r10
80004988:	16 99       	mov	r9,r11
8000498a:	30 0a       	mov	r10,0
8000498c:	30 0b       	mov	r11,0
8000498e:	e0 a0 04 0d 	rcall	800051a8 <__avr32_f64_cmp_lt>
80004992:	c6 a0       	breq	80004a66 <floor+0x116>
80004994:	58 03       	cp.w	r3,0
80004996:	c0 45       	brlt	8000499e <floor+0x4e>
80004998:	30 06       	mov	r6,0
8000499a:	0c 97       	mov	r7,r6
8000499c:	c6 58       	rjmp	80004a66 <floor+0x116>
8000499e:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
800049a2:	f1 e2 10 06 	or	r6,r8,r2
800049a6:	fc 18 bf f0 	movh	r8,0xbff0
800049aa:	f0 07 17 10 	movne	r7,r8
800049ae:	c2 48       	rjmp	800049f6 <floor+0xa6>
800049b0:	ee 74 ff ff 	mov	r4,1048575
800049b4:	e8 05 08 44 	asr	r4,r4,r5
800049b8:	e9 eb 00 0c 	and	r12,r4,r11
800049bc:	f9 ea 10 01 	or	r1,r12,r10
800049c0:	c5 50       	breq	80004a6a <floor+0x11a>
800049c2:	e0 68 75 9c 	mov	r8,30108
800049c6:	ea 18 88 00 	orh	r8,0x8800
800049ca:	e0 69 e4 3c 	mov	r9,58428
800049ce:	ea 19 7e 37 	orh	r9,0x7e37
800049d2:	e0 a0 02 93 	rcall	80004ef8 <__avr32_f64_add>
800049d6:	14 98       	mov	r8,r10
800049d8:	16 99       	mov	r9,r11
800049da:	30 0a       	mov	r10,0
800049dc:	30 0b       	mov	r11,0
800049de:	e0 a0 03 e5 	rcall	800051a8 <__avr32_f64_cmp_lt>
800049e2:	c4 20       	breq	80004a66 <floor+0x116>
800049e4:	58 03       	cp.w	r3,0
800049e6:	c0 64       	brge	800049f2 <floor+0xa2>
800049e8:	fc 18 00 10 	movh	r8,0x10
800049ec:	f0 05 08 45 	asr	r5,r8,r5
800049f0:	0a 07       	add	r7,r5
800049f2:	5c d4       	com	r4
800049f4:	08 67       	and	r7,r4
800049f6:	30 06       	mov	r6,0
800049f8:	c3 78       	rjmp	80004a66 <floor+0x116>
800049fa:	e0 45 00 33 	cp.w	r5,51
800049fe:	e0 8a 00 0a 	brle	80004a12 <floor+0xc2>
80004a02:	e0 45 04 00 	cp.w	r5,1024
80004a06:	c3 21       	brne	80004a6a <floor+0x11a>
80004a08:	e0 a0 02 78 	rcall	80004ef8 <__avr32_f64_add>
80004a0c:	14 98       	mov	r8,r10
80004a0e:	16 99       	mov	r9,r11
80004a10:	c2 d8       	rjmp	80004a6a <floor+0x11a>
80004a12:	3f fc       	mov	r12,-1
80004a14:	e8 c4 04 13 	sub	r4,r4,1043
80004a18:	f8 04 0a 44 	lsr	r4,r12,r4
80004a1c:	e9 ea 00 0c 	and	r12,r4,r10
80004a20:	c2 50       	breq	80004a6a <floor+0x11a>
80004a22:	e0 68 75 9c 	mov	r8,30108
80004a26:	ea 18 88 00 	orh	r8,0x8800
80004a2a:	e0 69 e4 3c 	mov	r9,58428
80004a2e:	ea 19 7e 37 	orh	r9,0x7e37
80004a32:	e0 a0 02 63 	rcall	80004ef8 <__avr32_f64_add>
80004a36:	14 98       	mov	r8,r10
80004a38:	16 99       	mov	r9,r11
80004a3a:	30 0a       	mov	r10,0
80004a3c:	30 0b       	mov	r11,0
80004a3e:	e0 a0 03 b5 	rcall	800051a8 <__avr32_f64_cmp_lt>
80004a42:	c1 20       	breq	80004a66 <floor+0x116>
80004a44:	58 03       	cp.w	r3,0
80004a46:	c0 e4       	brge	80004a62 <floor+0x112>
80004a48:	59 45       	cp.w	r5,20
80004a4a:	c0 31       	brne	80004a50 <floor+0x100>
80004a4c:	2f f7       	sub	r7,-1
80004a4e:	c0 a8       	rjmp	80004a62 <floor+0x112>
80004a50:	30 18       	mov	r8,1
80004a52:	ea 05 11 34 	rsub	r5,r5,52
80004a56:	f0 05 09 45 	lsl	r5,r8,r5
80004a5a:	0a 06       	add	r6,r5
80004a5c:	04 36       	cp.w	r6,r2
80004a5e:	e7 d8 e3 07 	addcs	r7,r3,r8
80004a62:	5c d4       	com	r4
80004a64:	08 66       	and	r6,r4
80004a66:	0e 99       	mov	r9,r7
80004a68:	0c 98       	mov	r8,r6
80004a6a:	10 9a       	mov	r10,r8
80004a6c:	12 9b       	mov	r11,r9
80004a6e:	d8 32       	popm	r0-r7,pc

80004a70 <__isnand>:
80004a70:	14 98       	mov	r8,r10
80004a72:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
80004a76:	f0 0c 11 00 	rsub	r12,r8,0
80004a7a:	10 4c       	or	r12,r8
80004a7c:	fc 18 7f f0 	movh	r8,0x7ff0
80004a80:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
80004a84:	f0 0c 01 0c 	sub	r12,r8,r12
80004a88:	bf 9c       	lsr	r12,0x1f
80004a8a:	5e fc       	retal	r12

80004a8c <matherr>:
80004a8c:	5e fd       	retal	0
80004a8e:	d7 03       	nop

80004a90 <scalbn>:
80004a90:	d4 21       	pushm	r4-r7,lr
80004a92:	18 97       	mov	r7,r12
80004a94:	14 98       	mov	r8,r10
80004a96:	16 99       	mov	r9,r11
80004a98:	14 94       	mov	r4,r10
80004a9a:	16 95       	mov	r5,r11
80004a9c:	14 96       	mov	r6,r10
80004a9e:	16 9c       	mov	r12,r11
80004aa0:	fd db c2 8b 	bfextu	lr,r11,0x14,0xb
80004aa4:	c1 11       	brne	80004ac6 <scalbn+0x36>
80004aa6:	f9 db c0 1f 	bfextu	r12,r11,0x0,0x1f
80004aaa:	14 4c       	or	r12,r10
80004aac:	c5 c0       	breq	80004b64 <scalbn+0xd4>
80004aae:	30 08       	mov	r8,0
80004ab0:	fc 19 43 50 	movh	r9,0x4350
80004ab4:	c6 8c       	rcall	80004b84 <__avr32_f64_mul>
80004ab6:	16 99       	mov	r9,r11
80004ab8:	14 98       	mov	r8,r10
80004aba:	14 94       	mov	r4,r10
80004abc:	12 95       	mov	r5,r9
80004abe:	fe 57 3c b0 	cp.w	r7,-50000
80004ac2:	c0 84       	brge	80004ad2 <scalbn+0x42>
80004ac4:	c3 a8       	rjmp	80004b38 <scalbn+0xa8>
80004ac6:	e0 4e 07 ff 	cp.w	lr,2047
80004aca:	c0 81       	brne	80004ada <scalbn+0x4a>
80004acc:	e0 a0 02 16 	rcall	80004ef8 <__avr32_f64_add>
80004ad0:	c4 88       	rjmp	80004b60 <scalbn+0xd0>
80004ad2:	fd d9 c2 8b 	bfextu	lr,r9,0x14,0xb
80004ad6:	12 9c       	mov	r12,r9
80004ad8:	23 6e       	sub	lr,54
80004ada:	0e 0e       	add	lr,r7
80004adc:	e0 4e 07 fe 	cp.w	lr,2046
80004ae0:	e0 89 00 11 	brgt	80004b02 <scalbn+0x72>
80004ae4:	58 0e       	cp.w	lr,0
80004ae6:	e0 8a 00 07 	brle	80004af4 <scalbn+0x64>
80004aea:	e4 1c 80 0f 	andh	r12,0x800f
80004aee:	f9 ee 11 49 	or	r9,r12,lr<<0x14
80004af2:	c3 98       	rjmp	80004b64 <scalbn+0xd4>
80004af4:	fe 5e ff cb 	cp.w	lr,-53
80004af8:	c2 94       	brge	80004b4a <scalbn+0xba>
80004afa:	e0 47 c3 50 	cp.w	r7,50000
80004afe:	e0 8a 00 14 	brle	80004b26 <scalbn+0x96>
80004b02:	e0 6a 75 9c 	mov	r10,30108
80004b06:	ea 1a 88 00 	orh	r10,0x8800
80004b0a:	e0 6b e4 3c 	mov	r11,58428
80004b0e:	ea 1b 7e 37 	orh	r11,0x7e37
80004b12:	c2 dc       	rcall	80004b6c <copysign>
80004b14:	e0 68 75 9c 	mov	r8,30108
80004b18:	ea 18 88 00 	orh	r8,0x8800
80004b1c:	e0 69 e4 3c 	mov	r9,58428
80004b20:	ea 19 7e 37 	orh	r9,0x7e37
80004b24:	c1 d8       	rjmp	80004b5e <scalbn+0xce>
80004b26:	e0 6a f3 59 	mov	r10,62297
80004b2a:	ea 1a c2 f8 	orh	r10,0xc2f8
80004b2e:	e0 6b 6e 1f 	mov	r11,28191
80004b32:	ea 1b 01 a5 	orh	r11,0x1a5
80004b36:	c1 bc       	rcall	80004b6c <copysign>
80004b38:	e0 68 f3 59 	mov	r8,62297
80004b3c:	ea 18 c2 f8 	orh	r8,0xc2f8
80004b40:	e0 69 6e 1f 	mov	r9,28191
80004b44:	ea 19 01 a5 	orh	r9,0x1a5
80004b48:	c0 b8       	rjmp	80004b5e <scalbn+0xce>
80004b4a:	2c ae       	sub	lr,-54
80004b4c:	e4 1c 80 0f 	andh	r12,0x800f
80004b50:	f9 ee 11 49 	or	r9,r12,lr<<0x14
80004b54:	10 9a       	mov	r10,r8
80004b56:	12 9b       	mov	r11,r9
80004b58:	30 08       	mov	r8,0
80004b5a:	fc 19 3c 90 	movh	r9,0x3c90
80004b5e:	c1 3c       	rcall	80004b84 <__avr32_f64_mul>
80004b60:	14 98       	mov	r8,r10
80004b62:	16 99       	mov	r9,r11
80004b64:	10 9a       	mov	r10,r8
80004b66:	12 9b       	mov	r11,r9
80004b68:	d8 22       	popm	r4-r7,pc
80004b6a:	d7 03       	nop

80004b6c <copysign>:
80004b6c:	d4 21       	pushm	r4-r7,lr
80004b6e:	e6 19 80 00 	andh	r9,0x8000,COH
80004b72:	16 95       	mov	r5,r11
80004b74:	14 94       	mov	r4,r10
80004b76:	14 96       	mov	r6,r10
80004b78:	f7 db c0 1f 	bfextu	r11,r11,0x0,0x1f
80004b7c:	f3 eb 10 0b 	or	r11,r9,r11
80004b80:	16 97       	mov	r7,r11
80004b82:	d8 22       	popm	r4-r7,pc

80004b84 <__avr32_f64_mul>:
80004b84:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
80004b88:	e0 80 00 dc 	breq	80004d40 <__avr32_f64_mul_op1_zero>
80004b8c:	d4 21       	pushm	r4-r7,lr
80004b8e:	f7 e9 20 0e 	eor	lr,r11,r9
80004b92:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
80004b96:	30 15       	mov	r5,1
80004b98:	c4 30       	breq	80004c1e <__avr32_f64_mul_op1_subnormal>
80004b9a:	ab 6b       	lsl	r11,0xa
80004b9c:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
80004ba0:	ab 6a       	lsl	r10,0xa
80004ba2:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
80004ba6:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
80004baa:	c5 c0       	breq	80004c62 <__avr32_f64_mul_op2_subnormal>
80004bac:	a1 78       	lsl	r8,0x1
80004bae:	5c f9       	rol	r9
80004bb0:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
80004bb4:	e0 47 07 ff 	cp.w	r7,2047
80004bb8:	c7 70       	breq	80004ca6 <__avr32_f64_mul_op_nan_or_inf>
80004bba:	e0 46 07 ff 	cp.w	r6,2047
80004bbe:	c7 40       	breq	80004ca6 <__avr32_f64_mul_op_nan_or_inf>
80004bc0:	ee 06 00 0c 	add	r12,r7,r6
80004bc4:	e0 2c 03 fe 	sub	r12,1022
80004bc8:	f6 08 06 44 	mulu.d	r4,r11,r8
80004bcc:	f4 09 07 44 	macu.d	r4,r10,r9
80004bd0:	f4 08 06 46 	mulu.d	r6,r10,r8
80004bd4:	f6 09 06 4a 	mulu.d	r10,r11,r9
80004bd8:	08 07       	add	r7,r4
80004bda:	f4 05 00 4a 	adc	r10,r10,r5
80004bde:	5c 0b       	acr	r11
80004be0:	ed bb 00 14 	bld	r11,0x14
80004be4:	c0 50       	breq	80004bee <__avr32_f64_mul+0x6a>
80004be6:	a1 77       	lsl	r7,0x1
80004be8:	5c fa       	rol	r10
80004bea:	5c fb       	rol	r11
80004bec:	20 1c       	sub	r12,1
80004bee:	58 0c       	cp.w	r12,0
80004bf0:	e0 8a 00 6f 	brle	80004cce <__avr32_f64_mul_res_subnormal>
80004bf4:	e0 4c 07 ff 	cp.w	r12,2047
80004bf8:	e0 84 00 9c 	brge	80004d30 <__avr32_f64_mul_res_inf>
80004bfc:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
80004c00:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
80004c04:	ef e6 12 17 	or	r7,r7,r6>>0x1
80004c08:	ee 17 80 00 	eorh	r7,0x8000
80004c0c:	f1 b7 04 20 	satu	r7,0x1
80004c10:	0e 0a       	add	r10,r7
80004c12:	5c 0b       	acr	r11
80004c14:	ed be 00 1f 	bld	lr,0x1f
80004c18:	ef bb 00 1f 	bst	r11,0x1f
80004c1c:	d8 22       	popm	r4-r7,pc

80004c1e <__avr32_f64_mul_op1_subnormal>:
80004c1e:	e4 1b 00 0f 	andh	r11,0xf
80004c22:	f4 0c 12 00 	clz	r12,r10
80004c26:	f6 06 12 00 	clz	r6,r11
80004c2a:	f7 bc 03 e1 	sublo	r12,-31
80004c2e:	f8 06 17 30 	movlo	r6,r12
80004c32:	f7 b6 02 01 	subhs	r6,1
80004c36:	e0 46 00 20 	cp.w	r6,32
80004c3a:	c0 d4       	brge	80004c54 <__avr32_f64_mul_op1_subnormal+0x36>
80004c3c:	ec 0c 11 20 	rsub	r12,r6,32
80004c40:	f6 06 09 4b 	lsl	r11,r11,r6
80004c44:	f4 0c 0a 4c 	lsr	r12,r10,r12
80004c48:	18 4b       	or	r11,r12
80004c4a:	f4 06 09 4a 	lsl	r10,r10,r6
80004c4e:	20 b6       	sub	r6,11
80004c50:	0c 17       	sub	r7,r6
80004c52:	ca ab       	rjmp	80004ba6 <__avr32_f64_mul+0x22>
80004c54:	f4 06 09 4b 	lsl	r11,r10,r6
80004c58:	c6 40       	breq	80004d20 <__avr32_f64_mul_res_zero>
80004c5a:	30 0a       	mov	r10,0
80004c5c:	20 b6       	sub	r6,11
80004c5e:	0c 17       	sub	r7,r6
80004c60:	ca 3b       	rjmp	80004ba6 <__avr32_f64_mul+0x22>

80004c62 <__avr32_f64_mul_op2_subnormal>:
80004c62:	e4 19 00 0f 	andh	r9,0xf
80004c66:	f0 0c 12 00 	clz	r12,r8
80004c6a:	f2 05 12 00 	clz	r5,r9
80004c6e:	f7 bc 03 ea 	sublo	r12,-22
80004c72:	f8 05 17 30 	movlo	r5,r12
80004c76:	f7 b5 02 0a 	subhs	r5,10
80004c7a:	e0 45 00 20 	cp.w	r5,32
80004c7e:	c0 d4       	brge	80004c98 <__avr32_f64_mul_op2_subnormal+0x36>
80004c80:	ea 0c 11 20 	rsub	r12,r5,32
80004c84:	f2 05 09 49 	lsl	r9,r9,r5
80004c88:	f0 0c 0a 4c 	lsr	r12,r8,r12
80004c8c:	18 49       	or	r9,r12
80004c8e:	f0 05 09 48 	lsl	r8,r8,r5
80004c92:	20 25       	sub	r5,2
80004c94:	0a 16       	sub	r6,r5
80004c96:	c8 fb       	rjmp	80004bb4 <__avr32_f64_mul+0x30>
80004c98:	f0 05 09 49 	lsl	r9,r8,r5
80004c9c:	c4 20       	breq	80004d20 <__avr32_f64_mul_res_zero>
80004c9e:	30 08       	mov	r8,0
80004ca0:	20 25       	sub	r5,2
80004ca2:	0a 16       	sub	r6,r5
80004ca4:	c8 8b       	rjmp	80004bb4 <__avr32_f64_mul+0x30>

80004ca6 <__avr32_f64_mul_op_nan_or_inf>:
80004ca6:	e4 19 00 0f 	andh	r9,0xf
80004caa:	e4 1b 00 0f 	andh	r11,0xf
80004cae:	14 4b       	or	r11,r10
80004cb0:	10 49       	or	r9,r8
80004cb2:	e0 47 07 ff 	cp.w	r7,2047
80004cb6:	c0 91       	brne	80004cc8 <__avr32_f64_mul_op1_not_naninf>
80004cb8:	58 0b       	cp.w	r11,0
80004cba:	c3 81       	brne	80004d2a <__avr32_f64_mul_res_nan>
80004cbc:	e0 46 07 ff 	cp.w	r6,2047
80004cc0:	c3 81       	brne	80004d30 <__avr32_f64_mul_res_inf>
80004cc2:	58 09       	cp.w	r9,0
80004cc4:	c3 60       	breq	80004d30 <__avr32_f64_mul_res_inf>
80004cc6:	c3 28       	rjmp	80004d2a <__avr32_f64_mul_res_nan>

80004cc8 <__avr32_f64_mul_op1_not_naninf>:
80004cc8:	58 09       	cp.w	r9,0
80004cca:	c3 30       	breq	80004d30 <__avr32_f64_mul_res_inf>
80004ccc:	c2 f8       	rjmp	80004d2a <__avr32_f64_mul_res_nan>

80004cce <__avr32_f64_mul_res_subnormal>:
80004cce:	5c 3c       	neg	r12
80004cd0:	2f fc       	sub	r12,-1
80004cd2:	f1 bc 04 c0 	satu	r12,0x6
80004cd6:	e0 4c 00 20 	cp.w	r12,32
80004cda:	c1 14       	brge	80004cfc <__avr32_f64_mul_res_subnormal+0x2e>
80004cdc:	f8 08 11 20 	rsub	r8,r12,32
80004ce0:	0e 46       	or	r6,r7
80004ce2:	ee 0c 0a 47 	lsr	r7,r7,r12
80004ce6:	f4 08 09 49 	lsl	r9,r10,r8
80004cea:	12 47       	or	r7,r9
80004cec:	f4 0c 0a 4a 	lsr	r10,r10,r12
80004cf0:	f6 08 09 49 	lsl	r9,r11,r8
80004cf4:	12 4a       	or	r10,r9
80004cf6:	f6 0c 0a 4b 	lsr	r11,r11,r12
80004cfa:	c8 3b       	rjmp	80004c00 <__avr32_f64_mul+0x7c>
80004cfc:	f8 08 11 20 	rsub	r8,r12,32
80004d00:	f9 b9 00 00 	moveq	r9,0
80004d04:	c0 30       	breq	80004d0a <__avr32_f64_mul_res_subnormal+0x3c>
80004d06:	f6 08 09 49 	lsl	r9,r11,r8
80004d0a:	0e 46       	or	r6,r7
80004d0c:	ed ea 10 16 	or	r6,r6,r10<<0x1
80004d10:	f4 0c 0a 4a 	lsr	r10,r10,r12
80004d14:	f3 ea 10 07 	or	r7,r9,r10
80004d18:	f6 0c 0a 4a 	lsr	r10,r11,r12
80004d1c:	30 0b       	mov	r11,0
80004d1e:	c7 1b       	rjmp	80004c00 <__avr32_f64_mul+0x7c>

80004d20 <__avr32_f64_mul_res_zero>:
80004d20:	1c 9b       	mov	r11,lr
80004d22:	e6 1b 80 00 	andh	r11,0x8000,COH
80004d26:	30 0a       	mov	r10,0
80004d28:	d8 22       	popm	r4-r7,pc

80004d2a <__avr32_f64_mul_res_nan>:
80004d2a:	3f fb       	mov	r11,-1
80004d2c:	3f fa       	mov	r10,-1
80004d2e:	d8 22       	popm	r4-r7,pc

80004d30 <__avr32_f64_mul_res_inf>:
80004d30:	f0 6b 00 00 	mov	r11,-1048576
80004d34:	ed be 00 1f 	bld	lr,0x1f
80004d38:	ef bb 00 1f 	bst	r11,0x1f
80004d3c:	30 0a       	mov	r10,0
80004d3e:	d8 22       	popm	r4-r7,pc

80004d40 <__avr32_f64_mul_op1_zero>:
80004d40:	f7 e9 20 0b 	eor	r11,r11,r9
80004d44:	e6 1b 80 00 	andh	r11,0x8000,COH
80004d48:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
80004d4c:	e0 4c 07 ff 	cp.w	r12,2047
80004d50:	5e 1c       	retne	r12
80004d52:	3f fa       	mov	r10,-1
80004d54:	3f fb       	mov	r11,-1
80004d56:	5e fc       	retal	r12

80004d58 <__avr32_f64_sub_from_add>:
80004d58:	ee 19 80 00 	eorh	r9,0x8000

80004d5c <__avr32_f64_sub>:
80004d5c:	f7 e9 20 0c 	eor	r12,r11,r9
80004d60:	e0 86 00 ca 	brmi	80004ef4 <__avr32_f64_add_from_sub>
80004d64:	eb cd 40 e0 	pushm	r5-r7,lr
80004d68:	16 9c       	mov	r12,r11
80004d6a:	e6 1c 80 00 	andh	r12,0x8000,COH
80004d6e:	bf db       	cbr	r11,0x1f
80004d70:	bf d9       	cbr	r9,0x1f
80004d72:	10 3a       	cp.w	r10,r8
80004d74:	f2 0b 13 00 	cpc	r11,r9
80004d78:	c0 92       	brcc	80004d8a <__avr32_f64_sub+0x2e>
80004d7a:	16 97       	mov	r7,r11
80004d7c:	12 9b       	mov	r11,r9
80004d7e:	0e 99       	mov	r9,r7
80004d80:	14 97       	mov	r7,r10
80004d82:	10 9a       	mov	r10,r8
80004d84:	0e 98       	mov	r8,r7
80004d86:	ee 1c 80 00 	eorh	r12,0x8000
80004d8a:	f6 07 16 14 	lsr	r7,r11,0x14
80004d8e:	ab 7b       	lsl	r11,0xb
80004d90:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
80004d94:	ab 7a       	lsl	r10,0xb
80004d96:	bf bb       	sbr	r11,0x1f
80004d98:	f2 06 16 14 	lsr	r6,r9,0x14
80004d9c:	c4 40       	breq	80004e24 <__avr32_f64_sub_opL_subnormal>
80004d9e:	ab 79       	lsl	r9,0xb
80004da0:	f3 e8 13 59 	or	r9,r9,r8>>0x15
80004da4:	ab 78       	lsl	r8,0xb
80004da6:	bf b9       	sbr	r9,0x1f

80004da8 <__avr32_f64_sub_opL_subnormal_done>:
80004da8:	e0 47 07 ff 	cp.w	r7,2047
80004dac:	c4 f0       	breq	80004e4a <__avr32_f64_sub_opH_nan_or_inf>
80004dae:	0e 26       	rsub	r6,r7
80004db0:	c1 20       	breq	80004dd4 <__avr32_f64_sub_shift_done>
80004db2:	ec 05 11 20 	rsub	r5,r6,32
80004db6:	e0 46 00 20 	cp.w	r6,32
80004dba:	c7 c2       	brcc	80004eb2 <__avr32_f64_sub_longshift>
80004dbc:	f0 05 09 4e 	lsl	lr,r8,r5
80004dc0:	f2 05 09 45 	lsl	r5,r9,r5
80004dc4:	f0 06 0a 48 	lsr	r8,r8,r6
80004dc8:	f2 06 0a 49 	lsr	r9,r9,r6
80004dcc:	0a 48       	or	r8,r5
80004dce:	58 0e       	cp.w	lr,0
80004dd0:	5f 1e       	srne	lr
80004dd2:	1c 48       	or	r8,lr

80004dd4 <__avr32_f64_sub_shift_done>:
80004dd4:	10 1a       	sub	r10,r8
80004dd6:	f6 09 01 4b 	sbc	r11,r11,r9
80004dda:	f6 06 12 00 	clz	r6,r11
80004dde:	c0 e0       	breq	80004dfa <__avr32_f64_sub_longnormalize_done>
80004de0:	c7 83       	brcs	80004ed0 <__avr32_f64_sub_longnormalize>
80004de2:	ec 0e 11 20 	rsub	lr,r6,32
80004de6:	f6 06 09 4b 	lsl	r11,r11,r6
80004dea:	f4 0e 0a 4e 	lsr	lr,r10,lr
80004dee:	1c 4b       	or	r11,lr
80004df0:	f4 06 09 4a 	lsl	r10,r10,r6
80004df4:	0c 17       	sub	r7,r6
80004df6:	e0 8a 00 39 	brle	80004e68 <__avr32_f64_sub_subnormal_result>

80004dfa <__avr32_f64_sub_longnormalize_done>:
80004dfa:	f4 09 15 15 	lsl	r9,r10,0x15
80004dfe:	ab 9a       	lsr	r10,0xb
80004e00:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
80004e04:	ab 9b       	lsr	r11,0xb
80004e06:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
80004e0a:	18 4b       	or	r11,r12

80004e0c <__avr32_f64_sub_round>:
80004e0c:	fc 17 80 00 	movh	r7,0x8000
80004e10:	ed ba 00 00 	bld	r10,0x0
80004e14:	f7 b7 01 ff 	subne	r7,-1
80004e18:	0e 39       	cp.w	r9,r7
80004e1a:	5f 29       	srhs	r9
80004e1c:	12 0a       	add	r10,r9
80004e1e:	5c 0b       	acr	r11
80004e20:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80004e24 <__avr32_f64_sub_opL_subnormal>:
80004e24:	ab 79       	lsl	r9,0xb
80004e26:	f3 e8 13 59 	or	r9,r9,r8>>0x15
80004e2a:	ab 78       	lsl	r8,0xb
80004e2c:	f3 e8 10 0e 	or	lr,r9,r8
80004e30:	f9 b6 01 01 	movne	r6,1
80004e34:	ee 0e 11 00 	rsub	lr,r7,0
80004e38:	f9 b7 00 01 	moveq	r7,1
80004e3c:	ef bb 00 1f 	bst	r11,0x1f
80004e40:	f7 ea 10 0e 	or	lr,r11,r10
80004e44:	f9 b7 00 00 	moveq	r7,0
80004e48:	cb 0b       	rjmp	80004da8 <__avr32_f64_sub_opL_subnormal_done>

80004e4a <__avr32_f64_sub_opH_nan_or_inf>:
80004e4a:	bf db       	cbr	r11,0x1f
80004e4c:	f7 ea 10 0e 	or	lr,r11,r10
80004e50:	c0 81       	brne	80004e60 <__avr32_f64_sub_return_nan>
80004e52:	e0 46 07 ff 	cp.w	r6,2047
80004e56:	c0 50       	breq	80004e60 <__avr32_f64_sub_return_nan>
80004e58:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
80004e5c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80004e60 <__avr32_f64_sub_return_nan>:
80004e60:	3f fa       	mov	r10,-1
80004e62:	3f fb       	mov	r11,-1
80004e64:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80004e68 <__avr32_f64_sub_subnormal_result>:
80004e68:	5c 37       	neg	r7
80004e6a:	2f f7       	sub	r7,-1
80004e6c:	f1 b7 04 c0 	satu	r7,0x6
80004e70:	e0 47 00 20 	cp.w	r7,32
80004e74:	c1 14       	brge	80004e96 <__avr32_f64_sub_subnormal_result+0x2e>
80004e76:	ee 08 11 20 	rsub	r8,r7,32
80004e7a:	f4 08 09 49 	lsl	r9,r10,r8
80004e7e:	5f 16       	srne	r6
80004e80:	f4 07 0a 4a 	lsr	r10,r10,r7
80004e84:	0c 4a       	or	r10,r6
80004e86:	f6 08 09 49 	lsl	r9,r11,r8
80004e8a:	f5 e9 10 0a 	or	r10,r10,r9
80004e8e:	f4 07 0a 4b 	lsr	r11,r10,r7
80004e92:	30 07       	mov	r7,0
80004e94:	cb 3b       	rjmp	80004dfa <__avr32_f64_sub_longnormalize_done>
80004e96:	ee 08 11 40 	rsub	r8,r7,64
80004e9a:	f6 08 09 49 	lsl	r9,r11,r8
80004e9e:	14 49       	or	r9,r10
80004ea0:	5f 16       	srne	r6
80004ea2:	f6 07 0a 4a 	lsr	r10,r11,r7
80004ea6:	0c 4a       	or	r10,r6
80004ea8:	30 0b       	mov	r11,0
80004eaa:	30 07       	mov	r7,0
80004eac:	ca 7b       	rjmp	80004dfa <__avr32_f64_sub_longnormalize_done>
80004eae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80004eb2 <__avr32_f64_sub_longshift>:
80004eb2:	f1 b6 04 c0 	satu	r6,0x6
80004eb6:	f0 0e 17 00 	moveq	lr,r8
80004eba:	c0 40       	breq	80004ec2 <__avr32_f64_sub_longshift+0x10>
80004ebc:	f2 05 09 4e 	lsl	lr,r9,r5
80004ec0:	10 4e       	or	lr,r8
80004ec2:	f2 06 0a 48 	lsr	r8,r9,r6
80004ec6:	30 09       	mov	r9,0
80004ec8:	58 0e       	cp.w	lr,0
80004eca:	5f 1e       	srne	lr
80004ecc:	1c 48       	or	r8,lr
80004ece:	c8 3b       	rjmp	80004dd4 <__avr32_f64_sub_shift_done>

80004ed0 <__avr32_f64_sub_longnormalize>:
80004ed0:	f4 06 12 00 	clz	r6,r10
80004ed4:	f9 b7 03 00 	movlo	r7,0
80004ed8:	f9 b6 03 00 	movlo	r6,0
80004edc:	f9 bc 03 00 	movlo	r12,0
80004ee0:	f7 b6 02 e0 	subhs	r6,-32
80004ee4:	f4 06 09 4b 	lsl	r11,r10,r6
80004ee8:	30 0a       	mov	r10,0
80004eea:	0c 17       	sub	r7,r6
80004eec:	fe 9a ff be 	brle	80004e68 <__avr32_f64_sub_subnormal_result>
80004ef0:	c8 5b       	rjmp	80004dfa <__avr32_f64_sub_longnormalize_done>
80004ef2:	d7 03       	nop

80004ef4 <__avr32_f64_add_from_sub>:
80004ef4:	ee 19 80 00 	eorh	r9,0x8000

80004ef8 <__avr32_f64_add>:
80004ef8:	f7 e9 20 0c 	eor	r12,r11,r9
80004efc:	fe 96 ff 2e 	brmi	80004d58 <__avr32_f64_sub_from_add>
80004f00:	eb cd 40 e0 	pushm	r5-r7,lr
80004f04:	16 9c       	mov	r12,r11
80004f06:	e6 1c 80 00 	andh	r12,0x8000,COH
80004f0a:	bf db       	cbr	r11,0x1f
80004f0c:	bf d9       	cbr	r9,0x1f
80004f0e:	12 3b       	cp.w	r11,r9
80004f10:	c0 72       	brcc	80004f1e <__avr32_f64_add+0x26>
80004f12:	16 97       	mov	r7,r11
80004f14:	12 9b       	mov	r11,r9
80004f16:	0e 99       	mov	r9,r7
80004f18:	14 97       	mov	r7,r10
80004f1a:	10 9a       	mov	r10,r8
80004f1c:	0e 98       	mov	r8,r7
80004f1e:	30 0e       	mov	lr,0
80004f20:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
80004f24:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
80004f28:	b5 ab       	sbr	r11,0x14
80004f2a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
80004f2e:	c6 20       	breq	80004ff2 <__avr32_f64_add_op2_subnormal>
80004f30:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
80004f34:	b5 a9       	sbr	r9,0x14
80004f36:	e0 47 07 ff 	cp.w	r7,2047
80004f3a:	c2 80       	breq	80004f8a <__avr32_f64_add_opH_nan_or_inf>
80004f3c:	0e 26       	rsub	r6,r7
80004f3e:	c1 20       	breq	80004f62 <__avr32_f64_add_shift_done>
80004f40:	e0 46 00 36 	cp.w	r6,54
80004f44:	c1 52       	brcc	80004f6e <__avr32_f64_add_res_of_done>
80004f46:	ec 05 11 20 	rsub	r5,r6,32
80004f4a:	e0 46 00 20 	cp.w	r6,32
80004f4e:	c3 52       	brcc	80004fb8 <__avr32_f64_add_longshift>
80004f50:	f0 05 09 4e 	lsl	lr,r8,r5
80004f54:	f2 05 09 45 	lsl	r5,r9,r5
80004f58:	f0 06 0a 48 	lsr	r8,r8,r6
80004f5c:	f2 06 0a 49 	lsr	r9,r9,r6
80004f60:	0a 48       	or	r8,r5

80004f62 <__avr32_f64_add_shift_done>:
80004f62:	10 0a       	add	r10,r8
80004f64:	f6 09 00 4b 	adc	r11,r11,r9
80004f68:	ed bb 00 15 	bld	r11,0x15
80004f6c:	c3 40       	breq	80004fd4 <__avr32_f64_add_res_of>

80004f6e <__avr32_f64_add_res_of_done>:
80004f6e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
80004f72:	18 4b       	or	r11,r12

80004f74 <__avr32_f64_add_round>:
80004f74:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
80004f78:	18 4e       	or	lr,r12
80004f7a:	ee 1e 80 00 	eorh	lr,0x8000
80004f7e:	f1 be 04 20 	satu	lr,0x1
80004f82:	1c 0a       	add	r10,lr
80004f84:	5c 0b       	acr	r11
80004f86:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80004f8a <__avr32_f64_add_opH_nan_or_inf>:
80004f8a:	b5 cb       	cbr	r11,0x14
80004f8c:	f7 ea 10 0e 	or	lr,r11,r10
80004f90:	c1 01       	brne	80004fb0 <__avr32_f64_add_return_nan>
80004f92:	e0 46 07 ff 	cp.w	r6,2047
80004f96:	c0 30       	breq	80004f9c <__avr32_f64_add_opL_nan_or_inf>
80004f98:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80004f9c <__avr32_f64_add_opL_nan_or_inf>:
80004f9c:	b5 c9       	cbr	r9,0x14
80004f9e:	f3 e8 10 0e 	or	lr,r9,r8
80004fa2:	c0 71       	brne	80004fb0 <__avr32_f64_add_return_nan>
80004fa4:	30 0a       	mov	r10,0
80004fa6:	fc 1b 7f f0 	movh	r11,0x7ff0
80004faa:	18 4b       	or	r11,r12
80004fac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80004fb0 <__avr32_f64_add_return_nan>:
80004fb0:	3f fa       	mov	r10,-1
80004fb2:	3f fb       	mov	r11,-1
80004fb4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80004fb8 <__avr32_f64_add_longshift>:
80004fb8:	f1 b6 04 c0 	satu	r6,0x6
80004fbc:	f0 0e 17 00 	moveq	lr,r8
80004fc0:	c0 60       	breq	80004fcc <__avr32_f64_add_longshift+0x14>
80004fc2:	f2 05 09 4e 	lsl	lr,r9,r5
80004fc6:	58 08       	cp.w	r8,0
80004fc8:	5f 18       	srne	r8
80004fca:	10 4e       	or	lr,r8
80004fcc:	f2 06 0a 48 	lsr	r8,r9,r6
80004fd0:	30 09       	mov	r9,0
80004fd2:	cc 8b       	rjmp	80004f62 <__avr32_f64_add_shift_done>

80004fd4 <__avr32_f64_add_res_of>:
80004fd4:	fd ee 10 1e 	or	lr,lr,lr<<0x1
80004fd8:	a1 9b       	lsr	r11,0x1
80004fda:	5d 0a       	ror	r10
80004fdc:	5d 0e       	ror	lr
80004fde:	2f f7       	sub	r7,-1
80004fe0:	e0 47 07 ff 	cp.w	r7,2047
80004fe4:	f9 ba 00 00 	moveq	r10,0
80004fe8:	f9 bb 00 00 	moveq	r11,0
80004fec:	f9 be 00 00 	moveq	lr,0
80004ff0:	cb fb       	rjmp	80004f6e <__avr32_f64_add_res_of_done>

80004ff2 <__avr32_f64_add_op2_subnormal>:
80004ff2:	30 16       	mov	r6,1
80004ff4:	58 07       	cp.w	r7,0
80004ff6:	ca 01       	brne	80004f36 <__avr32_f64_add+0x3e>
80004ff8:	b5 cb       	cbr	r11,0x14
80004ffa:	10 0a       	add	r10,r8
80004ffc:	f6 09 00 4b 	adc	r11,r11,r9
80005000:	18 4b       	or	r11,r12
80005002:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005006:	d7 03       	nop

80005008 <__avr32_f64_to_u32>:
80005008:	58 0b       	cp.w	r11,0
8000500a:	5e 6d       	retmi	0

8000500c <__avr32_f64_to_s32>:
8000500c:	f6 0c 15 01 	lsl	r12,r11,0x1
80005010:	b5 9c       	lsr	r12,0x15
80005012:	e0 2c 03 ff 	sub	r12,1023
80005016:	5e 3d       	retlo	0
80005018:	f8 0c 11 1f 	rsub	r12,r12,31
8000501c:	16 99       	mov	r9,r11
8000501e:	ab 7b       	lsl	r11,0xb
80005020:	bf bb       	sbr	r11,0x1f
80005022:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
80005026:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000502a:	a1 79       	lsl	r9,0x1
8000502c:	5e 2b       	reths	r11
8000502e:	5c 3b       	neg	r11
80005030:	5e fb       	retal	r11

80005032 <__avr32_u32_to_f64>:
80005032:	f8 cb 00 00 	sub	r11,r12,0
80005036:	30 0c       	mov	r12,0
80005038:	c0 38       	rjmp	8000503e <__avr32_s32_to_f64+0x4>

8000503a <__avr32_s32_to_f64>:
8000503a:	18 9b       	mov	r11,r12
8000503c:	5c 4b       	abs	r11
8000503e:	30 0a       	mov	r10,0
80005040:	5e 0b       	reteq	r11
80005042:	d4 01       	pushm	lr
80005044:	e0 69 04 1e 	mov	r9,1054
80005048:	f6 08 12 00 	clz	r8,r11
8000504c:	c1 70       	breq	8000507a <__avr32_s32_to_f64+0x40>
8000504e:	c0 c3       	brcs	80005066 <__avr32_s32_to_f64+0x2c>
80005050:	f0 0e 11 20 	rsub	lr,r8,32
80005054:	f6 08 09 4b 	lsl	r11,r11,r8
80005058:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000505c:	1c 4b       	or	r11,lr
8000505e:	f4 08 09 4a 	lsl	r10,r10,r8
80005062:	10 19       	sub	r9,r8
80005064:	c0 b8       	rjmp	8000507a <__avr32_s32_to_f64+0x40>
80005066:	f4 08 12 00 	clz	r8,r10
8000506a:	f9 b8 03 00 	movlo	r8,0
8000506e:	f7 b8 02 e0 	subhs	r8,-32
80005072:	f4 08 09 4b 	lsl	r11,r10,r8
80005076:	30 0a       	mov	r10,0
80005078:	10 19       	sub	r9,r8
8000507a:	58 09       	cp.w	r9,0
8000507c:	e0 89 00 30 	brgt	800050dc <__avr32_s32_to_f64+0xa2>
80005080:	5c 39       	neg	r9
80005082:	2f f9       	sub	r9,-1
80005084:	e0 49 00 36 	cp.w	r9,54
80005088:	c0 43       	brcs	80005090 <__avr32_s32_to_f64+0x56>
8000508a:	30 0b       	mov	r11,0
8000508c:	30 0a       	mov	r10,0
8000508e:	c2 68       	rjmp	800050da <__avr32_s32_to_f64+0xa0>
80005090:	2f 69       	sub	r9,-10
80005092:	f2 08 11 20 	rsub	r8,r9,32
80005096:	e0 49 00 20 	cp.w	r9,32
8000509a:	c0 b2       	brcc	800050b0 <__avr32_s32_to_f64+0x76>
8000509c:	f4 08 09 4e 	lsl	lr,r10,r8
800050a0:	f6 08 09 48 	lsl	r8,r11,r8
800050a4:	f4 09 0a 4a 	lsr	r10,r10,r9
800050a8:	f6 09 0a 4b 	lsr	r11,r11,r9
800050ac:	10 4b       	or	r11,r8
800050ae:	c0 88       	rjmp	800050be <__avr32_s32_to_f64+0x84>
800050b0:	f6 08 09 4e 	lsl	lr,r11,r8
800050b4:	14 4e       	or	lr,r10
800050b6:	16 9a       	mov	r10,r11
800050b8:	30 0b       	mov	r11,0
800050ba:	f4 09 0a 4a 	lsr	r10,r10,r9
800050be:	ed ba 00 00 	bld	r10,0x0
800050c2:	c0 92       	brcc	800050d4 <__avr32_s32_to_f64+0x9a>
800050c4:	1c 7e       	tst	lr,lr
800050c6:	c0 41       	brne	800050ce <__avr32_s32_to_f64+0x94>
800050c8:	ed ba 00 01 	bld	r10,0x1
800050cc:	c0 42       	brcc	800050d4 <__avr32_s32_to_f64+0x9a>
800050ce:	2f fa       	sub	r10,-1
800050d0:	f7 bb 02 ff 	subhs	r11,-1
800050d4:	5c fc       	rol	r12
800050d6:	5d 0b       	ror	r11
800050d8:	5d 0a       	ror	r10
800050da:	d8 02       	popm	pc
800050dc:	e0 68 03 ff 	mov	r8,1023
800050e0:	ed ba 00 0b 	bld	r10,0xb
800050e4:	f7 b8 00 ff 	subeq	r8,-1
800050e8:	10 0a       	add	r10,r8
800050ea:	5c 0b       	acr	r11
800050ec:	f7 b9 03 fe 	sublo	r9,-2
800050f0:	e0 49 07 ff 	cp.w	r9,2047
800050f4:	c0 55       	brlt	800050fe <__avr32_s32_to_f64+0xc4>
800050f6:	30 0a       	mov	r10,0
800050f8:	fc 1b ff e0 	movh	r11,0xffe0
800050fc:	c0 c8       	rjmp	80005114 <__floatsidf_return_op1>
800050fe:	ed bb 00 1f 	bld	r11,0x1f
80005102:	f7 b9 01 01 	subne	r9,1
80005106:	ab 9a       	lsr	r10,0xb
80005108:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000510c:	a1 7b       	lsl	r11,0x1
8000510e:	ab 9b       	lsr	r11,0xb
80005110:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

80005114 <__floatsidf_return_op1>:
80005114:	a1 7c       	lsl	r12,0x1
80005116:	5d 0b       	ror	r11
80005118:	d8 02       	popm	pc

8000511a <__avr32_f64_cmp_eq>:
8000511a:	10 3a       	cp.w	r10,r8
8000511c:	f2 0b 13 00 	cpc	r11,r9
80005120:	c0 80       	breq	80005130 <__avr32_f64_cmp_eq+0x16>
80005122:	a1 7b       	lsl	r11,0x1
80005124:	a1 79       	lsl	r9,0x1
80005126:	14 4b       	or	r11,r10
80005128:	12 4b       	or	r11,r9
8000512a:	10 4b       	or	r11,r8
8000512c:	5e 0f       	reteq	1
8000512e:	5e fd       	retal	0
80005130:	a1 7b       	lsl	r11,0x1
80005132:	fc 1c ff e0 	movh	r12,0xffe0
80005136:	58 0a       	cp.w	r10,0
80005138:	f8 0b 13 00 	cpc	r11,r12
8000513c:	5e 8f       	retls	1
8000513e:	5e fd       	retal	0

80005140 <__avr32_f64_cmp_ge>:
80005140:	1a de       	st.w	--sp,lr
80005142:	1a d7       	st.w	--sp,r7
80005144:	a1 7b       	lsl	r11,0x1
80005146:	5f 3c       	srlo	r12
80005148:	a1 79       	lsl	r9,0x1
8000514a:	5f 37       	srlo	r7
8000514c:	5c fc       	rol	r12
8000514e:	fc 1e ff e0 	movh	lr,0xffe0
80005152:	58 0a       	cp.w	r10,0
80005154:	fc 0b 13 00 	cpc	r11,lr
80005158:	e0 8b 00 1d 	brhi	80005192 <__avr32_f64_cmp_ge+0x52>
8000515c:	58 08       	cp.w	r8,0
8000515e:	fc 09 13 00 	cpc	r9,lr
80005162:	e0 8b 00 18 	brhi	80005192 <__avr32_f64_cmp_ge+0x52>
80005166:	58 0b       	cp.w	r11,0
80005168:	f5 ba 00 00 	subfeq	r10,0
8000516c:	c1 50       	breq	80005196 <__avr32_f64_cmp_ge+0x56>
8000516e:	1b 07       	ld.w	r7,sp++
80005170:	1b 0e       	ld.w	lr,sp++
80005172:	58 3c       	cp.w	r12,3
80005174:	c0 a0       	breq	80005188 <__avr32_f64_cmp_ge+0x48>
80005176:	58 1c       	cp.w	r12,1
80005178:	c0 33       	brcs	8000517e <__avr32_f64_cmp_ge+0x3e>
8000517a:	5e 0f       	reteq	1
8000517c:	5e 1d       	retne	0
8000517e:	10 3a       	cp.w	r10,r8
80005180:	f2 0b 13 00 	cpc	r11,r9
80005184:	5e 2f       	reths	1
80005186:	5e 3d       	retlo	0
80005188:	14 38       	cp.w	r8,r10
8000518a:	f6 09 13 00 	cpc	r9,r11
8000518e:	5e 2f       	reths	1
80005190:	5e 3d       	retlo	0
80005192:	1b 07       	ld.w	r7,sp++
80005194:	d8 0a       	popm	pc,r12=0
80005196:	58 17       	cp.w	r7,1
80005198:	5f 0c       	sreq	r12
8000519a:	58 09       	cp.w	r9,0
8000519c:	f5 b8 00 00 	subfeq	r8,0
800051a0:	1b 07       	ld.w	r7,sp++
800051a2:	1b 0e       	ld.w	lr,sp++
800051a4:	5e 0f       	reteq	1
800051a6:	5e fc       	retal	r12

800051a8 <__avr32_f64_cmp_lt>:
800051a8:	1a de       	st.w	--sp,lr
800051aa:	1a d7       	st.w	--sp,r7
800051ac:	a1 7b       	lsl	r11,0x1
800051ae:	5f 3c       	srlo	r12
800051b0:	a1 79       	lsl	r9,0x1
800051b2:	5f 37       	srlo	r7
800051b4:	5c fc       	rol	r12
800051b6:	fc 1e ff e0 	movh	lr,0xffe0
800051ba:	58 0a       	cp.w	r10,0
800051bc:	fc 0b 13 00 	cpc	r11,lr
800051c0:	e0 8b 00 1d 	brhi	800051fa <__avr32_f64_cmp_lt+0x52>
800051c4:	58 08       	cp.w	r8,0
800051c6:	fc 09 13 00 	cpc	r9,lr
800051ca:	e0 8b 00 18 	brhi	800051fa <__avr32_f64_cmp_lt+0x52>
800051ce:	58 0b       	cp.w	r11,0
800051d0:	f5 ba 00 00 	subfeq	r10,0
800051d4:	c1 50       	breq	800051fe <__avr32_f64_cmp_lt+0x56>
800051d6:	1b 07       	ld.w	r7,sp++
800051d8:	1b 0e       	ld.w	lr,sp++
800051da:	58 3c       	cp.w	r12,3
800051dc:	c0 a0       	breq	800051f0 <__avr32_f64_cmp_lt+0x48>
800051de:	58 1c       	cp.w	r12,1
800051e0:	c0 33       	brcs	800051e6 <__avr32_f64_cmp_lt+0x3e>
800051e2:	5e 0d       	reteq	0
800051e4:	5e 1f       	retne	1
800051e6:	10 3a       	cp.w	r10,r8
800051e8:	f2 0b 13 00 	cpc	r11,r9
800051ec:	5e 2d       	reths	0
800051ee:	5e 3f       	retlo	1
800051f0:	14 38       	cp.w	r8,r10
800051f2:	f6 09 13 00 	cpc	r9,r11
800051f6:	5e 2d       	reths	0
800051f8:	5e 3f       	retlo	1
800051fa:	1b 07       	ld.w	r7,sp++
800051fc:	d8 0a       	popm	pc,r12=0
800051fe:	58 17       	cp.w	r7,1
80005200:	5f 1c       	srne	r12
80005202:	58 09       	cp.w	r9,0
80005204:	f5 b8 00 00 	subfeq	r8,0
80005208:	1b 07       	ld.w	r7,sp++
8000520a:	1b 0e       	ld.w	lr,sp++
8000520c:	5e 0d       	reteq	0
8000520e:	5e fc       	retal	r12

80005210 <__avr32_f32_cmp_ge>:
80005210:	f8 0a 15 01 	lsl	r10,r12,0x1
80005214:	f6 09 15 01 	lsl	r9,r11,0x1
80005218:	f5 ba 00 00 	subfeq	r10,0
8000521c:	5e 0f       	reteq	1
8000521e:	fc 18 ff 00 	movh	r8,0xff00
80005222:	10 3a       	cp.w	r10,r8
80005224:	5e bd       	rethi	0
80005226:	10 39       	cp.w	r9,r8
80005228:	5e bd       	rethi	0
8000522a:	f7 ec 20 08 	eor	r8,r11,r12
8000522e:	ed bc 00 1f 	bld	r12,0x1f
80005232:	5f 28       	srhs	r8
80005234:	5e 68       	retmi	r8
80005236:	c0 43       	brcs	8000523e <__avr32_f32_cmp_ge+0x2e>
80005238:	16 3c       	cp.w	r12,r11
8000523a:	5e 2f       	reths	1
8000523c:	5e 3d       	retlo	0
8000523e:	18 3b       	cp.w	r11,r12
80005240:	5e 2f       	reths	1
80005242:	5e 3d       	retlo	0

80005244 <__avr32_f64_div>:
80005244:	eb cd 40 ff 	pushm	r0-r7,lr
80005248:	f7 e9 20 0e 	eor	lr,r11,r9
8000524c:	f6 07 16 14 	lsr	r7,r11,0x14
80005250:	a9 7b       	lsl	r11,0x9
80005252:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
80005256:	a9 7a       	lsl	r10,0x9
80005258:	bd bb       	sbr	r11,0x1d
8000525a:	e4 1b 3f ff 	andh	r11,0x3fff
8000525e:	ab d7       	cbr	r7,0xb
80005260:	e0 80 00 cc 	breq	800053f8 <__avr32_f64_div_round_subnormal+0x54>
80005264:	e0 47 07 ff 	cp.w	r7,2047
80005268:	e0 84 00 b5 	brge	800053d2 <__avr32_f64_div_round_subnormal+0x2e>
8000526c:	f2 06 16 14 	lsr	r6,r9,0x14
80005270:	a9 79       	lsl	r9,0x9
80005272:	f3 e8 13 79 	or	r9,r9,r8>>0x17
80005276:	a9 78       	lsl	r8,0x9
80005278:	bd b9       	sbr	r9,0x1d
8000527a:	e4 19 3f ff 	andh	r9,0x3fff
8000527e:	ab d6       	cbr	r6,0xb
80005280:	e0 80 00 e2 	breq	80005444 <__avr32_f64_div_round_subnormal+0xa0>
80005284:	e0 46 07 ff 	cp.w	r6,2047
80005288:	e0 84 00 b2 	brge	800053ec <__avr32_f64_div_round_subnormal+0x48>
8000528c:	0c 17       	sub	r7,r6
8000528e:	fe 37 fc 01 	sub	r7,-1023
80005292:	fc 1c 80 00 	movh	r12,0x8000
80005296:	f8 03 16 01 	lsr	r3,r12,0x1
8000529a:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000529e:	5c d4       	com	r4
800052a0:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
800052a4:	e6 09 06 44 	mulu.d	r4,r3,r9
800052a8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
800052ac:	e6 05 06 44 	mulu.d	r4,r3,r5
800052b0:	ea 03 15 02 	lsl	r3,r5,0x2
800052b4:	e6 09 06 44 	mulu.d	r4,r3,r9
800052b8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
800052bc:	e6 05 06 44 	mulu.d	r4,r3,r5
800052c0:	ea 03 15 02 	lsl	r3,r5,0x2
800052c4:	e6 09 06 44 	mulu.d	r4,r3,r9
800052c8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
800052cc:	e6 05 06 44 	mulu.d	r4,r3,r5
800052d0:	ea 03 15 02 	lsl	r3,r5,0x2
800052d4:	e6 08 06 40 	mulu.d	r0,r3,r8
800052d8:	e4 09 07 40 	macu.d	r0,r2,r9
800052dc:	e6 09 06 44 	mulu.d	r4,r3,r9
800052e0:	02 04       	add	r4,r1
800052e2:	5c 05       	acr	r5
800052e4:	a3 65       	lsl	r5,0x2
800052e6:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
800052ea:	a3 64       	lsl	r4,0x2
800052ec:	5c 34       	neg	r4
800052ee:	f8 05 01 45 	sbc	r5,r12,r5
800052f2:	e6 04 06 40 	mulu.d	r0,r3,r4
800052f6:	e4 05 07 40 	macu.d	r0,r2,r5
800052fa:	e6 05 06 44 	mulu.d	r4,r3,r5
800052fe:	02 04       	add	r4,r1
80005300:	5c 05       	acr	r5
80005302:	ea 03 15 02 	lsl	r3,r5,0x2
80005306:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000530a:	e8 02 15 02 	lsl	r2,r4,0x2
8000530e:	e6 08 06 40 	mulu.d	r0,r3,r8
80005312:	e4 09 07 40 	macu.d	r0,r2,r9
80005316:	e6 09 06 44 	mulu.d	r4,r3,r9
8000531a:	02 04       	add	r4,r1
8000531c:	5c 05       	acr	r5
8000531e:	a3 65       	lsl	r5,0x2
80005320:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
80005324:	a3 64       	lsl	r4,0x2
80005326:	5c 34       	neg	r4
80005328:	f8 05 01 45 	sbc	r5,r12,r5
8000532c:	e6 04 06 40 	mulu.d	r0,r3,r4
80005330:	e4 05 07 40 	macu.d	r0,r2,r5
80005334:	e6 05 06 44 	mulu.d	r4,r3,r5
80005338:	02 04       	add	r4,r1
8000533a:	5c 05       	acr	r5
8000533c:	ea 03 15 02 	lsl	r3,r5,0x2
80005340:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
80005344:	e8 02 15 02 	lsl	r2,r4,0x2
80005348:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000534c:	e4 0b 07 40 	macu.d	r0,r2,r11
80005350:	e6 0b 06 42 	mulu.d	r2,r3,r11
80005354:	02 02       	add	r2,r1
80005356:	5c 03       	acr	r3
80005358:	ed b3 00 1c 	bld	r3,0x1c
8000535c:	c0 90       	breq	8000536e <__avr32_f64_div+0x12a>
8000535e:	a1 72       	lsl	r2,0x1
80005360:	5c f3       	rol	r3
80005362:	20 17       	sub	r7,1
80005364:	a3 9a       	lsr	r10,0x3
80005366:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000536a:	a3 9b       	lsr	r11,0x3
8000536c:	c0 58       	rjmp	80005376 <__avr32_f64_div+0x132>
8000536e:	a5 8a       	lsr	r10,0x4
80005370:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
80005374:	a5 8b       	lsr	r11,0x4
80005376:	58 07       	cp.w	r7,0
80005378:	e0 8a 00 8b 	brle	8000548e <__avr32_f64_div_res_subnormal>
8000537c:	e0 12 ff 00 	andl	r2,0xff00
80005380:	e8 12 00 80 	orl	r2,0x80
80005384:	e6 08 06 40 	mulu.d	r0,r3,r8
80005388:	e4 09 07 40 	macu.d	r0,r2,r9
8000538c:	e4 08 06 44 	mulu.d	r4,r2,r8
80005390:	e6 09 06 48 	mulu.d	r8,r3,r9
80005394:	00 05       	add	r5,r0
80005396:	f0 01 00 48 	adc	r8,r8,r1
8000539a:	5c 09       	acr	r9
8000539c:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
800053a0:	58 04       	cp.w	r4,0
800053a2:	5c 25       	cpc	r5

800053a4 <__avr32_f64_div_round_subnormal>:
800053a4:	f4 08 13 00 	cpc	r8,r10
800053a8:	f6 09 13 00 	cpc	r9,r11
800053ac:	5f 36       	srlo	r6
800053ae:	f8 06 17 00 	moveq	r6,r12
800053b2:	e4 0a 16 08 	lsr	r10,r2,0x8
800053b6:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
800053ba:	e6 0b 16 08 	lsr	r11,r3,0x8
800053be:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
800053c2:	ed be 00 1f 	bld	lr,0x1f
800053c6:	ef bb 00 1f 	bst	r11,0x1f
800053ca:	0c 0a       	add	r10,r6
800053cc:	5c 0b       	acr	r11
800053ce:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
800053d2:	e4 1b 00 0f 	andh	r11,0xf
800053d6:	14 4b       	or	r11,r10
800053d8:	e0 81 00 a7 	brne	80005526 <__avr32_f64_div_res_subnormal+0x98>
800053dc:	f2 06 16 14 	lsr	r6,r9,0x14
800053e0:	ab d6       	cbr	r6,0xb
800053e2:	e0 46 07 ff 	cp.w	r6,2047
800053e6:	e0 81 00 a4 	brne	8000552e <__avr32_f64_div_res_subnormal+0xa0>
800053ea:	c9 e8       	rjmp	80005526 <__avr32_f64_div_res_subnormal+0x98>
800053ec:	e4 19 00 0f 	andh	r9,0xf
800053f0:	10 49       	or	r9,r8
800053f2:	e0 81 00 9a 	brne	80005526 <__avr32_f64_div_res_subnormal+0x98>
800053f6:	c9 28       	rjmp	8000551a <__avr32_f64_div_res_subnormal+0x8c>
800053f8:	a3 7b       	lsl	r11,0x3
800053fa:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
800053fe:	a3 7a       	lsl	r10,0x3
80005400:	f5 eb 10 04 	or	r4,r10,r11
80005404:	e0 80 00 a0 	breq	80005544 <__avr32_f64_div_op1_zero>
80005408:	f6 04 12 00 	clz	r4,r11
8000540c:	c1 70       	breq	8000543a <__avr32_f64_div_round_subnormal+0x96>
8000540e:	c0 c3       	brcs	80005426 <__avr32_f64_div_round_subnormal+0x82>
80005410:	e8 05 11 20 	rsub	r5,r4,32
80005414:	f6 04 09 4b 	lsl	r11,r11,r4
80005418:	f4 05 0a 45 	lsr	r5,r10,r5
8000541c:	0a 4b       	or	r11,r5
8000541e:	f4 04 09 4a 	lsl	r10,r10,r4
80005422:	08 17       	sub	r7,r4
80005424:	c0 b8       	rjmp	8000543a <__avr32_f64_div_round_subnormal+0x96>
80005426:	f4 04 12 00 	clz	r4,r10
8000542a:	f9 b4 03 00 	movlo	r4,0
8000542e:	f7 b4 02 e0 	subhs	r4,-32
80005432:	f4 04 09 4b 	lsl	r11,r10,r4
80005436:	30 0a       	mov	r10,0
80005438:	08 17       	sub	r7,r4
8000543a:	a3 8a       	lsr	r10,0x2
8000543c:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
80005440:	a3 8b       	lsr	r11,0x2
80005442:	c1 1b       	rjmp	80005264 <__avr32_f64_div+0x20>
80005444:	a3 79       	lsl	r9,0x3
80005446:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000544a:	a3 78       	lsl	r8,0x3
8000544c:	f3 e8 10 04 	or	r4,r9,r8
80005450:	c6 f0       	breq	8000552e <__avr32_f64_div_res_subnormal+0xa0>
80005452:	f2 04 12 00 	clz	r4,r9
80005456:	c1 70       	breq	80005484 <__avr32_f64_div_round_subnormal+0xe0>
80005458:	c0 c3       	brcs	80005470 <__avr32_f64_div_round_subnormal+0xcc>
8000545a:	e8 05 11 20 	rsub	r5,r4,32
8000545e:	f2 04 09 49 	lsl	r9,r9,r4
80005462:	f0 05 0a 45 	lsr	r5,r8,r5
80005466:	0a 49       	or	r9,r5
80005468:	f0 04 09 48 	lsl	r8,r8,r4
8000546c:	08 16       	sub	r6,r4
8000546e:	c0 b8       	rjmp	80005484 <__avr32_f64_div_round_subnormal+0xe0>
80005470:	f0 04 12 00 	clz	r4,r8
80005474:	f9 b4 03 00 	movlo	r4,0
80005478:	f7 b4 02 e0 	subhs	r4,-32
8000547c:	f0 04 09 49 	lsl	r9,r8,r4
80005480:	30 08       	mov	r8,0
80005482:	08 16       	sub	r6,r4
80005484:	a3 88       	lsr	r8,0x2
80005486:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000548a:	a3 89       	lsr	r9,0x2
8000548c:	cf ca       	rjmp	80005284 <__avr32_f64_div+0x40>

8000548e <__avr32_f64_div_res_subnormal>:
8000548e:	5c 37       	neg	r7
80005490:	2f f7       	sub	r7,-1
80005492:	f1 b7 04 c0 	satu	r7,0x6
80005496:	e0 47 00 20 	cp.w	r7,32
8000549a:	c1 54       	brge	800054c4 <__avr32_f64_div_res_subnormal+0x36>
8000549c:	ee 06 11 20 	rsub	r6,r7,32
800054a0:	e4 07 0a 42 	lsr	r2,r2,r7
800054a4:	e6 06 09 4c 	lsl	r12,r3,r6
800054a8:	18 42       	or	r2,r12
800054aa:	e6 07 0a 43 	lsr	r3,r3,r7
800054ae:	f4 06 09 41 	lsl	r1,r10,r6
800054b2:	f4 07 0a 4a 	lsr	r10,r10,r7
800054b6:	f6 06 09 4c 	lsl	r12,r11,r6
800054ba:	18 4a       	or	r10,r12
800054bc:	f6 07 0a 4b 	lsr	r11,r11,r7
800054c0:	30 00       	mov	r0,0
800054c2:	c1 58       	rjmp	800054ec <__avr32_f64_div_res_subnormal+0x5e>
800054c4:	ee 06 11 20 	rsub	r6,r7,32
800054c8:	f9 b0 00 00 	moveq	r0,0
800054cc:	f9 bc 00 00 	moveq	r12,0
800054d0:	c0 50       	breq	800054da <__avr32_f64_div_res_subnormal+0x4c>
800054d2:	f4 06 09 40 	lsl	r0,r10,r6
800054d6:	f6 06 09 4c 	lsl	r12,r11,r6
800054da:	e6 07 0a 42 	lsr	r2,r3,r7
800054de:	30 03       	mov	r3,0
800054e0:	f4 07 0a 41 	lsr	r1,r10,r7
800054e4:	18 41       	or	r1,r12
800054e6:	f6 07 0a 4a 	lsr	r10,r11,r7
800054ea:	30 0b       	mov	r11,0
800054ec:	e0 12 ff 00 	andl	r2,0xff00
800054f0:	e8 12 00 80 	orl	r2,0x80
800054f4:	e6 08 06 46 	mulu.d	r6,r3,r8
800054f8:	e4 09 07 46 	macu.d	r6,r2,r9
800054fc:	e4 08 06 44 	mulu.d	r4,r2,r8
80005500:	e6 09 06 48 	mulu.d	r8,r3,r9
80005504:	0c 05       	add	r5,r6
80005506:	f0 07 00 48 	adc	r8,r8,r7
8000550a:	5c 09       	acr	r9
8000550c:	30 07       	mov	r7,0
8000550e:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
80005512:	00 34       	cp.w	r4,r0
80005514:	e2 05 13 00 	cpc	r5,r1
80005518:	c4 6b       	rjmp	800053a4 <__avr32_f64_div_round_subnormal>
8000551a:	1c 9b       	mov	r11,lr
8000551c:	e6 1b 80 00 	andh	r11,0x8000,COH
80005520:	30 0a       	mov	r10,0
80005522:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
80005526:	3f fb       	mov	r11,-1
80005528:	30 0a       	mov	r10,0
8000552a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000552e:	f5 eb 10 04 	or	r4,r10,r11
80005532:	c0 90       	breq	80005544 <__avr32_f64_div_op1_zero>
80005534:	1c 9b       	mov	r11,lr
80005536:	e6 1b 80 00 	andh	r11,0x8000,COH
8000553a:	ea 1b 7f f0 	orh	r11,0x7ff0
8000553e:	30 0a       	mov	r10,0
80005540:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

80005544 <__avr32_f64_div_op1_zero>:
80005544:	f1 e9 10 15 	or	r5,r8,r9<<0x1
80005548:	ce f0       	breq	80005526 <__avr32_f64_div_res_subnormal+0x98>
8000554a:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000554e:	e0 44 07 ff 	cp.w	r4,2047
80005552:	ce 41       	brne	8000551a <__avr32_f64_div_res_subnormal+0x8c>
80005554:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
80005558:	ce 10       	breq	8000551a <__avr32_f64_div_res_subnormal+0x8c>
8000555a:	ce 6b       	rjmp	80005526 <__avr32_f64_div_res_subnormal+0x98>

8000555c <__avr32_f32_sub_from_add>:
8000555c:	ee 1b 80 00 	eorh	r11,0x8000

80005560 <__avr32_f32_sub>:
80005560:	f7 ec 20 08 	eor	r8,r11,r12
80005564:	c6 46       	brmi	8000562c <__avr32_f32_add_from_sub>
80005566:	18 98       	mov	r8,r12
80005568:	e6 1c 80 00 	andh	r12,0x8000,COH
8000556c:	bf db       	cbr	r11,0x1f
8000556e:	bf d8       	cbr	r8,0x1f
80005570:	f0 0b 0c 4a 	max	r10,r8,r11
80005574:	f0 0b 0d 49 	min	r9,r8,r11
80005578:	10 3a       	cp.w	r10,r8
8000557a:	f7 bc 01 01 	subne	r12,1
8000557e:	e6 1c 80 00 	andh	r12,0x8000,COH
80005582:	f4 08 15 08 	lsl	r8,r10,0x8
80005586:	bf b8       	sbr	r8,0x1f
80005588:	b7 9a       	lsr	r10,0x17
8000558a:	e0 4a 00 ff 	cp.w	r10,255
8000558e:	c3 80       	breq	800055fe <__avr32_f32_sub_op1_nan_or_inf>
80005590:	f2 0b 15 08 	lsl	r11,r9,0x8
80005594:	bf bb       	sbr	r11,0x1f
80005596:	b7 99       	lsr	r9,0x17
80005598:	1a dc       	st.w	--sp,r12
8000559a:	c2 90       	breq	800055ec <__avr32_f32_sub_op2_subnormal>
8000559c:	f4 09 01 0c 	sub	r12,r10,r9
800055a0:	c0 c0       	breq	800055b8 <__avr32_f32_sub_shift_done>
800055a2:	f1 bc 04 a0 	satu	r12,0x5
800055a6:	f8 09 11 20 	rsub	r9,r12,32
800055aa:	f6 09 09 49 	lsl	r9,r11,r9
800055ae:	f7 b8 01 01 	subne	r8,1
800055b2:	5f 19       	srne	r9
800055b4:	f6 0c 0a 4b 	lsr	r11,r11,r12

800055b8 <__avr32_f32_sub_shift_done>:
800055b8:	16 18       	sub	r8,r11
800055ba:	1b 0c       	ld.w	r12,sp++
800055bc:	f0 0b 12 00 	clz	r11,r8
800055c0:	5e 3d       	retlo	0
800055c2:	f0 0b 09 48 	lsl	r8,r8,r11
800055c6:	16 1a       	sub	r10,r11
800055c8:	e0 8a 00 26 	brle	80005614 <__avr32_f32_sub_subnormal_result>
800055cc:	f3 e8 11 89 	or	r9,r9,r8<<0x18
800055d0:	f9 e8 12 8c 	or	r12,r12,r8>>0x8
800055d4:	f9 da d2 e8 	bfins	r12,r10,0x17,0x8

800055d8 <__avr32_f32_sub_round>:
800055d8:	fc 1a 80 00 	movh	r10,0x8000
800055dc:	ed bc 00 00 	bld	r12,0x0
800055e0:	f7 ba 01 ff 	subne	r10,-1
800055e4:	14 39       	cp.w	r9,r10
800055e6:	f7 bc 02 ff 	subhs	r12,-1
800055ea:	5e fc       	retal	r12

800055ec <__avr32_f32_sub_op2_subnormal>:
800055ec:	bf db       	cbr	r11,0x1f
800055ee:	f9 b9 01 01 	movne	r9,1
800055f2:	58 0a       	cp.w	r10,0
800055f4:	cd 41       	brne	8000559c <__avr32_f32_sub+0x3c>
800055f6:	bf d8       	cbr	r8,0x1f
800055f8:	f9 ba 01 01 	movne	r10,1
800055fc:	cd 0b       	rjmp	8000559c <__avr32_f32_sub+0x3c>

800055fe <__avr32_f32_sub_op1_nan_or_inf>:
800055fe:	f0 0b 15 01 	lsl	r11,r8,0x1
80005602:	5e 1e       	retne	-1
80005604:	f9 da d2 e8 	bfins	r12,r10,0x17,0x8
80005608:	f2 0b 16 17 	lsr	r11,r9,0x17
8000560c:	e0 4b 00 ff 	cp.w	r11,255
80005610:	5e 1c       	retne	r12
80005612:	5e fe       	retal	-1

80005614 <__avr32_f32_sub_subnormal_result>:
80005614:	f4 0a 11 09 	rsub	r10,r10,9
80005618:	f4 0b 11 20 	rsub	r11,r10,32
8000561c:	5e 3d       	retlo	0
8000561e:	f0 0a 0a 4a 	lsr	r10,r8,r10
80005622:	14 4c       	or	r12,r10
80005624:	f0 0b 09 48 	lsl	r8,r8,r11
80005628:	10 49       	or	r9,r8
8000562a:	cd 7b       	rjmp	800055d8 <__avr32_f32_sub_round>

8000562c <__avr32_f32_add_from_sub>:
8000562c:	ee 1b 80 00 	eorh	r11,0x8000

80005630 <__avr32_f32_add>:
80005630:	f7 ec 20 08 	eor	r8,r11,r12
80005634:	c9 46       	brmi	8000555c <__avr32_f32_sub_from_add>
80005636:	18 98       	mov	r8,r12
80005638:	e6 1c 80 00 	andh	r12,0x8000,COH
8000563c:	bf db       	cbr	r11,0x1f
8000563e:	bf d8       	cbr	r8,0x1f
80005640:	f0 0b 0c 4a 	max	r10,r8,r11
80005644:	f0 0b 0d 49 	min	r9,r8,r11
80005648:	f4 08 15 08 	lsl	r8,r10,0x8
8000564c:	bf b8       	sbr	r8,0x1f
8000564e:	b7 9a       	lsr	r10,0x17
80005650:	e0 4a 00 ff 	cp.w	r10,255
80005654:	c2 d0       	breq	800056ae <__avr32_f32_add_op1_nan_or_inf>
80005656:	f2 0b 15 08 	lsl	r11,r9,0x8
8000565a:	bf bb       	sbr	r11,0x1f
8000565c:	b7 99       	lsr	r9,0x17
8000565e:	c1 e0       	breq	8000569a <__avr32_f32_add_op2_subnormal>
80005660:	1a dc       	st.w	--sp,r12
80005662:	14 29       	rsub	r9,r10
80005664:	f1 b9 04 a0 	satu	r9,0x5
80005668:	f6 09 0a 4c 	lsr	r12,r11,r9
8000566c:	f2 09 11 18 	rsub	r9,r9,24
80005670:	f6 09 09 4b 	lsl	r11,r11,r9
80005674:	f7 dc d3 08 	bfins	r11,r12,0x18,0x8
80005678:	18 08       	add	r8,r12
8000567a:	1b 0c       	ld.w	r12,sp++
8000567c:	c2 63       	brcs	800056c8 <__avr32_f32_add_res_of>
8000567e:	f9 e8 12 8c 	or	r12,r12,r8>>0x8
80005682:	f9 da d2 e8 	bfins	r12,r10,0x17,0x8
80005686:	fc 1a 80 00 	movh	r10,0x8000
8000568a:	ed bc 00 00 	bld	r12,0x0
8000568e:	f7 ba 01 ff 	subne	r10,-1
80005692:	14 3b       	cp.w	r11,r10
80005694:	f7 bc 02 ff 	subhs	r12,-1
80005698:	5e fc       	retal	r12

8000569a <__avr32_f32_add_op2_subnormal>:
8000569a:	bf db       	cbr	r11,0x1f
8000569c:	f9 b9 01 01 	movne	r9,1
800056a0:	58 0a       	cp.w	r10,0
800056a2:	cd f1       	brne	80005660 <__avr32_f32_add+0x30>
800056a4:	bf d8       	cbr	r8,0x1f
800056a6:	10 0b       	add	r11,r8
800056a8:	f9 eb 12 8c 	or	r12,r12,r11>>0x8
800056ac:	5e fc       	retal	r12

800056ae <__avr32_f32_add_op1_nan_or_inf>:
800056ae:	f0 0b 15 01 	lsl	r11,r8,0x1
800056b2:	5e 1e       	retne	-1
800056b4:	f9 da d2 e8 	bfins	r12,r10,0x17,0x8
800056b8:	f2 0b 16 17 	lsr	r11,r9,0x17
800056bc:	e0 4b 00 ff 	cp.w	r11,255
800056c0:	5e 1c       	retne	r12
800056c2:	a9 79       	lsl	r9,0x9
800056c4:	5e 0c       	reteq	r12
800056c6:	5e fe       	retal	-1

800056c8 <__avr32_f32_add_res_of>:
800056c8:	a1 98       	lsr	r8,0x1
800056ca:	2f fa       	sub	r10,-1
800056cc:	e0 4a 00 ff 	cp.w	r10,255
800056d0:	f9 b8 00 00 	moveq	r8,0
800056d4:	f9 bb 00 00 	moveq	r11,0
800056d8:	cd 3b       	rjmp	8000567e <__avr32_f32_add+0x4e>
800056da:	d7 03       	nop

800056dc <__avr32_f32_mul>:
800056dc:	18 98       	mov	r8,r12
800056de:	16 5c       	eor	r12,r11
800056e0:	e6 1c 80 00 	andh	r12,0x8000,COH
800056e4:	bf d8       	cbr	r8,0x1f
800056e6:	c6 60       	breq	800057b2 <__avr32_f32_mul_op1_zero>
800056e8:	bf db       	cbr	r11,0x1f
800056ea:	f0 0b 0c 4a 	max	r10,r8,r11
800056ee:	f0 0b 0d 49 	min	r9,r8,r11
800056f2:	f4 08 15 08 	lsl	r8,r10,0x8
800056f6:	bf b8       	sbr	r8,0x1f
800056f8:	b7 9a       	lsr	r10,0x17
800056fa:	e0 4a 00 ff 	cp.w	r10,255
800056fe:	c3 d0       	breq	80005778 <__avr32_f32_mul_op1_nan_or_inf>
80005700:	f2 0b 15 08 	lsl	r11,r9,0x8
80005704:	bf bb       	sbr	r11,0x1f
80005706:	b7 99       	lsr	r9,0x17
80005708:	c2 40       	breq	80005750 <__avr32_f32_mul_op2_subnormal>
8000570a:	14 09       	add	r9,r10
8000570c:	f0 0b 06 4a 	mulu.d	r10,r8,r11
80005710:	f6 08 15 01 	lsl	r8,r11,0x1
80005714:	f0 0b 17 20 	movhs	r11,r8
80005718:	f7 b9 02 01 	subhs	r9,1
8000571c:	a9 8a       	lsr	r10,0x8
8000571e:	f5 db d3 08 	bfins	r10,r11,0x18,0x8
80005722:	27 e9       	sub	r9,126
80005724:	e0 8a 00 39 	brle	80005796 <__avr32_f32_mul_res_subnormal>
80005728:	e0 49 00 ff 	cp.w	r9,255
8000572c:	c0 f4       	brge	8000574a <__avr32_f32_mul_round+0x14>
8000572e:	f9 eb 12 8c 	or	r12,r12,r11>>0x8
80005732:	f9 d9 d2 e8 	bfins	r12,r9,0x17,0x8

80005736 <__avr32_f32_mul_round>:
80005736:	fc 18 80 00 	movh	r8,0x8000
8000573a:	ed bc 00 00 	bld	r12,0x0
8000573e:	f7 b8 01 ff 	subne	r8,-1
80005742:	10 3a       	cp.w	r10,r8
80005744:	f7 bc 02 ff 	subhs	r12,-1
80005748:	5e fc       	retal	r12
8000574a:	ea 1c 7f 80 	orh	r12,0x7f80
8000574e:	5e fc       	retal	r12

80005750 <__avr32_f32_mul_op2_subnormal>:
80005750:	bf db       	cbr	r11,0x1f
80005752:	f6 09 12 00 	clz	r9,r11
80005756:	5e 3d       	retlo	0
80005758:	20 89       	sub	r9,8
8000575a:	f6 09 09 4b 	lsl	r11,r11,r9
8000575e:	f2 09 11 01 	rsub	r9,r9,1
80005762:	14 7a       	tst	r10,r10
80005764:	cd 31       	brne	8000570a <__avr32_f32_mul+0x2e>
80005766:	bf d8       	cbr	r8,0x1f
80005768:	f6 0a 12 00 	clz	r10,r11
8000576c:	5e 3d       	retlo	0
8000576e:	f0 0a 09 48 	lsl	r8,r8,r10
80005772:	f4 0a 11 01 	rsub	r10,r10,1
80005776:	cc ab       	rjmp	8000570a <__avr32_f32_mul+0x2e>

80005778 <__avr32_f32_mul_op1_nan_or_inf>:
80005778:	f0 0b 15 01 	lsl	r11,r8,0x1
8000577c:	5e 1e       	retne	-1
8000577e:	12 79       	tst	r9,r9
80005780:	5e 0e       	reteq	-1
80005782:	f9 da d2 e8 	bfins	r12,r10,0x17,0x8
80005786:	f2 0b 16 17 	lsr	r11,r9,0x17
8000578a:	e0 4b 00 ff 	cp.w	r11,255
8000578e:	5e 1c       	retne	r12
80005790:	a9 79       	lsl	r9,0x9
80005792:	5e 0c       	reteq	r12
80005794:	5e fe       	retal	-1

80005796 <__avr32_f32_mul_res_subnormal>:
80005796:	f2 09 11 09 	rsub	r9,r9,9
8000579a:	f2 08 11 20 	rsub	r8,r9,32
8000579e:	5e 3d       	retlo	0
800057a0:	f6 09 0a 49 	lsr	r9,r11,r9
800057a4:	12 4c       	or	r12,r9
800057a6:	f6 08 09 4b 	lsl	r11,r11,r8
800057aa:	e4 1a 00 ff 	andh	r10,0xff
800057ae:	16 4a       	or	r10,r11
800057b0:	cc 3b       	rjmp	80005736 <__avr32_f32_mul_round>

800057b2 <__avr32_f32_mul_op1_zero>:
800057b2:	f5 db c2 e8 	bfextu	r10,r11,0x17,0x8
800057b6:	e0 4a 00 ff 	cp.w	r10,255
800057ba:	5e 1c       	retne	r12
800057bc:	5e 0e       	reteq	-1

800057be <__avr32_s32_to_f32>:
800057be:	58 0c       	cp.w	r12,0
800057c0:	5e 0c       	reteq	r12
800057c2:	18 9b       	mov	r11,r12
800057c4:	5c 4c       	abs	r12
800057c6:	e0 6a 00 9e 	mov	r10,158
800057ca:	f8 09 12 00 	clz	r9,r12
800057ce:	12 1a       	sub	r10,r9
800057d0:	f8 09 09 4c 	lsl	r12,r12,r9
800057d4:	58 0a       	cp.w	r10,0
800057d6:	e0 8a 00 15 	brle	80005800 <__avr32_s32_to_f32_subnormal>
800057da:	37 f9       	mov	r9,127
800057dc:	ed bc 00 08 	bld	r12,0x8
800057e0:	f7 b9 00 ff 	subeq	r9,-1
800057e4:	12 0c       	add	r12,r9
800057e6:	f7 ba 03 fe 	sublo	r10,-2
800057ea:	ed bc 00 1f 	bld	r12,0x1f
800057ee:	f7 ba 01 01 	subne	r10,1
800057f2:	f8 0c 16 07 	lsr	r12,r12,0x7
800057f6:	f9 da d3 08 	bfins	r12,r10,0x18,0x8
800057fa:	a1 7b       	lsl	r11,0x1
800057fc:	5d 0c       	ror	r12
800057fe:	5e fc       	retal	r12

80005800 <__avr32_s32_to_f32_subnormal>:
80005800:	f4 0a 11 01 	rsub	r10,r10,1
80005804:	59 9a       	cp.w	r10,25
80005806:	f9 bc 02 00 	movhs	r12,0
8000580a:	c1 32       	brcc	80005830 <__avr32_s32_to_f32_subnormal+0x30>
8000580c:	f4 09 11 20 	rsub	r9,r10,32
80005810:	f8 09 09 49 	lsl	r9,r12,r9
80005814:	5f 19       	srne	r9
80005816:	f8 0a 0a 4c 	lsr	r12,r12,r10
8000581a:	12 4c       	or	r12,r9
8000581c:	37 f9       	mov	r9,127
8000581e:	ed bc 00 08 	bld	r12,0x8
80005822:	f7 b9 00 ff 	subeq	r9,-1
80005826:	12 0c       	add	r12,r9
80005828:	f8 0c 16 07 	lsr	r12,r12,0x7
8000582c:	a1 7b       	lsl	r11,0x1
8000582e:	5d 0c       	ror	r12
80005830:	5e fc       	retal	r12

80005832 <__avr32_f32_to_u32>:
80005832:	58 0c       	cp.w	r12,0
80005834:	5e 6d       	retmi	0
80005836:	f7 dc c2 e8 	bfextu	r11,r12,0x17,0x8
8000583a:	27 fb       	sub	r11,127
8000583c:	5e 3d       	retlo	0
8000583e:	f6 0b 11 1f 	rsub	r11,r11,31
80005842:	a9 6c       	lsl	r12,0x8
80005844:	bf bc       	sbr	r12,0x1f
80005846:	f8 0b 0a 4c 	lsr	r12,r12,r11
8000584a:	5e fc       	retal	r12

8000584c <__avr32_f32_to_f64>:
8000584c:	f8 0b 15 01 	lsl	r11,r12,0x1
80005850:	f9 ba 00 00 	moveq	r10,0
80005854:	5e 0b       	reteq	r11
80005856:	f3 db c3 08 	bfextu	r9,r11,0x18,0x8
8000585a:	e0 49 00 ff 	cp.w	r9,255
8000585e:	c1 e0       	breq	8000589a <__extendsfdf_return_op1+0x6>
80005860:	a7 7b       	lsl	r11,0x7
80005862:	30 0a       	mov	r10,0
80005864:	58 09       	cp.w	r9,0
80005866:	f7 b9 00 ff 	subeq	r9,-1
8000586a:	5f 18       	srne	r8
8000586c:	f7 e8 11 fb 	or	r11,r11,r8<<0x1f
80005870:	fe 39 fc 80 	sub	r9,-896
80005874:	f6 08 12 00 	clz	r8,r11
80005878:	10 19       	sub	r9,r8
8000587a:	f6 08 09 4b 	lsl	r11,r11,r8
8000587e:	ed bb 00 1f 	bld	r11,0x1f
80005882:	f7 b9 01 01 	subne	r9,1
80005886:	ab 9a       	lsr	r10,0xb
80005888:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000588c:	a1 7b       	lsl	r11,0x1
8000588e:	ab 9b       	lsr	r11,0xb
80005890:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

80005894 <__extendsfdf_return_op1>:
80005894:	a1 7c       	lsl	r12,0x1
80005896:	5d 0b       	ror	r11
80005898:	5e fb       	retal	r11
8000589a:	fc 1a ff e0 	movh	r10,0xffe0
8000589e:	a9 6b       	lsl	r11,0x8
800058a0:	f9 bb 01 ff 	movne	r11,-1
800058a4:	f4 0b 17 00 	moveq	r11,r10
800058a8:	30 0a       	mov	r10,0
800058aa:	cf 5b       	rjmp	80005894 <__extendsfdf_return_op1>

800058ac <__avr32_f64_to_f32>:
800058ac:	f6 09 15 01 	lsl	r9,r11,0x1
800058b0:	b5 99       	lsr	r9,0x15
800058b2:	5e 0d       	reteq	0
800058b4:	f6 08 15 0a 	lsl	r8,r11,0xa
800058b8:	f1 ea 13 6c 	or	r12,r8,r10>>0x16
800058bc:	ab 6a       	lsl	r10,0xa
800058be:	5c 3a       	neg	r10
800058c0:	5c fc       	rol	r12
800058c2:	e0 49 07 ff 	cp.w	r9,2047
800058c6:	c1 a0       	breq	800058fa <__truncdfsf_return_op1+0x6>
800058c8:	e0 29 03 80 	sub	r9,896
800058cc:	bf bc       	sbr	r12,0x1f
800058ce:	58 09       	cp.w	r9,0
800058d0:	e0 8a 00 1a 	brle	80005904 <__truncdfsf_return_op1+0x10>
800058d4:	37 fa       	mov	r10,127
800058d6:	ed bc 00 08 	bld	r12,0x8
800058da:	f7 ba 00 ff 	subeq	r10,-1
800058de:	14 0c       	add	r12,r10
800058e0:	f7 b9 03 fe 	sublo	r9,-2
800058e4:	ed bc 00 1f 	bld	r12,0x1f
800058e8:	f7 b9 01 01 	subne	r9,1
800058ec:	f8 0c 16 07 	lsr	r12,r12,0x7
800058f0:	f9 d9 d3 08 	bfins	r12,r9,0x18,0x8

800058f4 <__truncdfsf_return_op1>:
800058f4:	a1 7b       	lsl	r11,0x1
800058f6:	5d 0c       	ror	r12
800058f8:	5e fc       	retal	r12
800058fa:	bf dc       	cbr	r12,0x1f
800058fc:	5e 1e       	retne	-1
800058fe:	fc 1c 7f 80 	movh	r12,0x7f80
80005902:	5e fc       	retal	r12
80005904:	f2 09 11 01 	rsub	r9,r9,1
80005908:	59 99       	cp.w	r9,25
8000590a:	f9 bc 02 00 	movhs	r12,0
8000590e:	c1 32       	brcc	80005934 <__truncdfsf_return_op1+0x40>
80005910:	f2 0a 11 20 	rsub	r10,r9,32
80005914:	f8 0a 09 4a 	lsl	r10,r12,r10
80005918:	5f 1a       	srne	r10
8000591a:	f8 09 0a 4c 	lsr	r12,r12,r9
8000591e:	14 4c       	or	r12,r10
80005920:	37 fa       	mov	r10,127
80005922:	ed bc 00 08 	bld	r12,0x8
80005926:	f7 ba 00 ff 	subeq	r10,-1
8000592a:	14 0c       	add	r12,r10
8000592c:	f8 0c 16 07 	lsr	r12,r12,0x7
80005930:	a1 7b       	lsl	r11,0x1
80005932:	5d 0c       	ror	r12
80005934:	5e fc       	retal	r12

80005936 <__avr32_udiv64>:
80005936:	d4 31       	pushm	r0-r7,lr
80005938:	1a 97       	mov	r7,sp
8000593a:	20 3d       	sub	sp,12
8000593c:	10 9c       	mov	r12,r8
8000593e:	12 9e       	mov	lr,r9
80005940:	14 93       	mov	r3,r10
80005942:	58 09       	cp.w	r9,0
80005944:	e0 81 00 bd 	brne	80005abe <__avr32_udiv64+0x188>
80005948:	16 38       	cp.w	r8,r11
8000594a:	e0 88 00 40 	brls	800059ca <__avr32_udiv64+0x94>
8000594e:	f0 08 12 00 	clz	r8,r8
80005952:	c0 d0       	breq	8000596c <__avr32_udiv64+0x36>
80005954:	f6 08 09 4b 	lsl	r11,r11,r8
80005958:	f0 09 11 20 	rsub	r9,r8,32
8000595c:	f8 08 09 4c 	lsl	r12,r12,r8
80005960:	f4 09 0a 49 	lsr	r9,r10,r9
80005964:	f4 08 09 43 	lsl	r3,r10,r8
80005968:	f3 eb 10 0b 	or	r11,r9,r11
8000596c:	f8 0e 16 10 	lsr	lr,r12,0x10
80005970:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80005974:	f6 0e 0d 00 	divu	r0,r11,lr
80005978:	e6 0b 16 10 	lsr	r11,r3,0x10
8000597c:	00 99       	mov	r9,r0
8000597e:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80005982:	e0 0a 02 48 	mul	r8,r0,r10
80005986:	10 3b       	cp.w	r11,r8
80005988:	c0 a2       	brcc	8000599c <__avr32_udiv64+0x66>
8000598a:	20 19       	sub	r9,1
8000598c:	18 0b       	add	r11,r12
8000598e:	18 3b       	cp.w	r11,r12
80005990:	c0 63       	brcs	8000599c <__avr32_udiv64+0x66>
80005992:	10 3b       	cp.w	r11,r8
80005994:	f7 b9 03 01 	sublo	r9,1
80005998:	f7 dc e3 0b 	addcs	r11,r11,r12
8000599c:	f6 08 01 01 	sub	r1,r11,r8
800059a0:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
800059a4:	e2 0e 0d 00 	divu	r0,r1,lr
800059a8:	e7 e1 11 03 	or	r3,r3,r1<<0x10
800059ac:	00 98       	mov	r8,r0
800059ae:	e0 0a 02 4a 	mul	r10,r0,r10
800059b2:	14 33       	cp.w	r3,r10
800059b4:	c0 82       	brcc	800059c4 <__avr32_udiv64+0x8e>
800059b6:	20 18       	sub	r8,1
800059b8:	18 03       	add	r3,r12
800059ba:	18 33       	cp.w	r3,r12
800059bc:	c0 43       	brcs	800059c4 <__avr32_udiv64+0x8e>
800059be:	14 33       	cp.w	r3,r10
800059c0:	f7 b8 03 01 	sublo	r8,1
800059c4:	f1 e9 11 08 	or	r8,r8,r9<<0x10
800059c8:	cd f8       	rjmp	80005b86 <__avr32_udiv64+0x250>
800059ca:	58 08       	cp.w	r8,0
800059cc:	c0 51       	brne	800059d6 <__avr32_udiv64+0xa0>
800059ce:	30 19       	mov	r9,1
800059d0:	f2 08 0d 08 	divu	r8,r9,r8
800059d4:	10 9c       	mov	r12,r8
800059d6:	f8 06 12 00 	clz	r6,r12
800059da:	c0 41       	brne	800059e2 <__avr32_udiv64+0xac>
800059dc:	18 1b       	sub	r11,r12
800059de:	30 19       	mov	r9,1
800059e0:	c4 08       	rjmp	80005a60 <__avr32_udiv64+0x12a>
800059e2:	ec 01 11 20 	rsub	r1,r6,32
800059e6:	f4 01 0a 49 	lsr	r9,r10,r1
800059ea:	f8 06 09 4c 	lsl	r12,r12,r6
800059ee:	f6 06 09 48 	lsl	r8,r11,r6
800059f2:	f6 01 0a 41 	lsr	r1,r11,r1
800059f6:	f3 e8 10 08 	or	r8,r9,r8
800059fa:	f8 03 16 10 	lsr	r3,r12,0x10
800059fe:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
80005a02:	e2 03 0d 00 	divu	r0,r1,r3
80005a06:	f0 0b 16 10 	lsr	r11,r8,0x10
80005a0a:	00 9e       	mov	lr,r0
80005a0c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80005a10:	e0 05 02 49 	mul	r9,r0,r5
80005a14:	12 3b       	cp.w	r11,r9
80005a16:	c0 a2       	brcc	80005a2a <__avr32_udiv64+0xf4>
80005a18:	20 1e       	sub	lr,1
80005a1a:	18 0b       	add	r11,r12
80005a1c:	18 3b       	cp.w	r11,r12
80005a1e:	c0 63       	brcs	80005a2a <__avr32_udiv64+0xf4>
80005a20:	12 3b       	cp.w	r11,r9
80005a22:	f7 be 03 01 	sublo	lr,1
80005a26:	f7 dc e3 0b 	addcs	r11,r11,r12
80005a2a:	12 1b       	sub	r11,r9
80005a2c:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
80005a30:	f6 03 0d 02 	divu	r2,r11,r3
80005a34:	f1 e3 11 08 	or	r8,r8,r3<<0x10
80005a38:	04 99       	mov	r9,r2
80005a3a:	e4 05 02 4b 	mul	r11,r2,r5
80005a3e:	16 38       	cp.w	r8,r11
80005a40:	c0 a2       	brcc	80005a54 <__avr32_udiv64+0x11e>
80005a42:	20 19       	sub	r9,1
80005a44:	18 08       	add	r8,r12
80005a46:	18 38       	cp.w	r8,r12
80005a48:	c0 63       	brcs	80005a54 <__avr32_udiv64+0x11e>
80005a4a:	16 38       	cp.w	r8,r11
80005a4c:	f7 b9 03 01 	sublo	r9,1
80005a50:	f1 dc e3 08 	addcs	r8,r8,r12
80005a54:	f4 06 09 43 	lsl	r3,r10,r6
80005a58:	f0 0b 01 0b 	sub	r11,r8,r11
80005a5c:	f3 ee 11 09 	or	r9,r9,lr<<0x10
80005a60:	f8 06 16 10 	lsr	r6,r12,0x10
80005a64:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
80005a68:	f6 06 0d 00 	divu	r0,r11,r6
80005a6c:	e6 0b 16 10 	lsr	r11,r3,0x10
80005a70:	00 9a       	mov	r10,r0
80005a72:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80005a76:	e0 0e 02 48 	mul	r8,r0,lr
80005a7a:	10 3b       	cp.w	r11,r8
80005a7c:	c0 a2       	brcc	80005a90 <__avr32_udiv64+0x15a>
80005a7e:	20 1a       	sub	r10,1
80005a80:	18 0b       	add	r11,r12
80005a82:	18 3b       	cp.w	r11,r12
80005a84:	c0 63       	brcs	80005a90 <__avr32_udiv64+0x15a>
80005a86:	10 3b       	cp.w	r11,r8
80005a88:	f7 ba 03 01 	sublo	r10,1
80005a8c:	f7 dc e3 0b 	addcs	r11,r11,r12
80005a90:	f6 08 01 01 	sub	r1,r11,r8
80005a94:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
80005a98:	e2 06 0d 00 	divu	r0,r1,r6
80005a9c:	e7 e1 11 03 	or	r3,r3,r1<<0x10
80005aa0:	00 98       	mov	r8,r0
80005aa2:	e0 0e 02 4b 	mul	r11,r0,lr
80005aa6:	16 33       	cp.w	r3,r11
80005aa8:	c0 82       	brcc	80005ab8 <__avr32_udiv64+0x182>
80005aaa:	20 18       	sub	r8,1
80005aac:	18 03       	add	r3,r12
80005aae:	18 33       	cp.w	r3,r12
80005ab0:	c0 43       	brcs	80005ab8 <__avr32_udiv64+0x182>
80005ab2:	16 33       	cp.w	r3,r11
80005ab4:	f7 b8 03 01 	sublo	r8,1
80005ab8:	f1 ea 11 08 	or	r8,r8,r10<<0x10
80005abc:	c6 98       	rjmp	80005b8e <__avr32_udiv64+0x258>
80005abe:	16 39       	cp.w	r9,r11
80005ac0:	e0 8b 00 65 	brhi	80005b8a <__avr32_udiv64+0x254>
80005ac4:	f2 09 12 00 	clz	r9,r9
80005ac8:	c0 b1       	brne	80005ade <__avr32_udiv64+0x1a8>
80005aca:	10 3a       	cp.w	r10,r8
80005acc:	5f 2a       	srhs	r10
80005ace:	1c 3b       	cp.w	r11,lr
80005ad0:	5f b8       	srhi	r8
80005ad2:	10 4a       	or	r10,r8
80005ad4:	f2 0a 18 00 	cp.b	r10,r9
80005ad8:	c5 90       	breq	80005b8a <__avr32_udiv64+0x254>
80005ada:	30 18       	mov	r8,1
80005adc:	c5 98       	rjmp	80005b8e <__avr32_udiv64+0x258>
80005ade:	f0 09 09 46 	lsl	r6,r8,r9
80005ae2:	f2 03 11 20 	rsub	r3,r9,32
80005ae6:	fc 09 09 4e 	lsl	lr,lr,r9
80005aea:	f0 03 0a 48 	lsr	r8,r8,r3
80005aee:	f6 09 09 4c 	lsl	r12,r11,r9
80005af2:	f4 03 0a 42 	lsr	r2,r10,r3
80005af6:	ef 46 ff f4 	st.w	r7[-12],r6
80005afa:	f6 03 0a 43 	lsr	r3,r11,r3
80005afe:	18 42       	or	r2,r12
80005b00:	f1 ee 10 0c 	or	r12,r8,lr
80005b04:	f8 01 16 10 	lsr	r1,r12,0x10
80005b08:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
80005b0c:	e6 01 0d 04 	divu	r4,r3,r1
80005b10:	e4 03 16 10 	lsr	r3,r2,0x10
80005b14:	08 9e       	mov	lr,r4
80005b16:	e7 e5 11 03 	or	r3,r3,r5<<0x10
80005b1a:	e8 06 02 48 	mul	r8,r4,r6
80005b1e:	10 33       	cp.w	r3,r8
80005b20:	c0 a2       	brcc	80005b34 <__avr32_udiv64+0x1fe>
80005b22:	20 1e       	sub	lr,1
80005b24:	18 03       	add	r3,r12
80005b26:	18 33       	cp.w	r3,r12
80005b28:	c0 63       	brcs	80005b34 <__avr32_udiv64+0x1fe>
80005b2a:	10 33       	cp.w	r3,r8
80005b2c:	f7 be 03 01 	sublo	lr,1
80005b30:	e7 dc e3 03 	addcs	r3,r3,r12
80005b34:	10 13       	sub	r3,r8
80005b36:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
80005b3a:	e6 01 0d 00 	divu	r0,r3,r1
80005b3e:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80005b42:	00 98       	mov	r8,r0
80005b44:	e0 06 02 46 	mul	r6,r0,r6
80005b48:	0c 3b       	cp.w	r11,r6
80005b4a:	c0 a2       	brcc	80005b5e <__avr32_udiv64+0x228>
80005b4c:	20 18       	sub	r8,1
80005b4e:	18 0b       	add	r11,r12
80005b50:	18 3b       	cp.w	r11,r12
80005b52:	c0 63       	brcs	80005b5e <__avr32_udiv64+0x228>
80005b54:	0c 3b       	cp.w	r11,r6
80005b56:	f7 dc e3 0b 	addcs	r11,r11,r12
80005b5a:	f7 b8 03 01 	sublo	r8,1
80005b5e:	f1 ee 11 08 	or	r8,r8,lr<<0x10
80005b62:	ee f4 ff f4 	ld.w	r4,r7[-12]
80005b66:	0c 1b       	sub	r11,r6
80005b68:	f0 04 06 42 	mulu.d	r2,r8,r4
80005b6c:	06 95       	mov	r5,r3
80005b6e:	16 35       	cp.w	r5,r11
80005b70:	e0 8b 00 0a 	brhi	80005b84 <__avr32_udiv64+0x24e>
80005b74:	5f 0b       	sreq	r11
80005b76:	f4 09 09 49 	lsl	r9,r10,r9
80005b7a:	12 32       	cp.w	r2,r9
80005b7c:	5f b9       	srhi	r9
80005b7e:	f7 e9 00 09 	and	r9,r11,r9
80005b82:	c0 60       	breq	80005b8e <__avr32_udiv64+0x258>
80005b84:	20 18       	sub	r8,1
80005b86:	30 09       	mov	r9,0
80005b88:	c0 38       	rjmp	80005b8e <__avr32_udiv64+0x258>
80005b8a:	30 09       	mov	r9,0
80005b8c:	12 98       	mov	r8,r9
80005b8e:	10 9a       	mov	r10,r8
80005b90:	12 93       	mov	r3,r9
80005b92:	10 92       	mov	r2,r8
80005b94:	12 9b       	mov	r11,r9
80005b96:	2f dd       	sub	sp,-12
80005b98:	d8 32       	popm	r0-r7,pc
80005b9a:	d7 03       	nop

80005b9c <__errno>:
80005b9c:	e0 68 01 1c 	mov	r8,284
80005ba0:	70 0c       	ld.w	r12,r8[0x0]
80005ba2:	2f 4c       	sub	r12,-12
80005ba4:	5e fc       	retal	r12
80005ba6:	d7 03       	nop

Disassembly of section .exception:

80005c00 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
80005c00:	c0 08       	rjmp	80005c00 <_evba>
	...

80005c04 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
80005c04:	c0 08       	rjmp	80005c04 <_handle_TLB_Multiple_Hit>
	...

80005c08 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
80005c08:	c0 08       	rjmp	80005c08 <_handle_Bus_Error_Data_Fetch>
	...

80005c0c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
80005c0c:	c0 08       	rjmp	80005c0c <_handle_Bus_Error_Instruction_Fetch>
	...

80005c10 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
80005c10:	c0 08       	rjmp	80005c10 <_handle_NMI>
	...

80005c14 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
80005c14:	c0 08       	rjmp	80005c14 <_handle_Instruction_Address>
	...

80005c18 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
80005c18:	c0 08       	rjmp	80005c18 <_handle_ITLB_Protection>
	...

80005c1c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
80005c1c:	c0 08       	rjmp	80005c1c <_handle_Breakpoint>
	...

80005c20 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
80005c20:	c0 08       	rjmp	80005c20 <_handle_Illegal_Opcode>
	...

80005c24 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
80005c24:	c0 08       	rjmp	80005c24 <_handle_Unimplemented_Instruction>
	...

80005c28 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
80005c28:	c0 08       	rjmp	80005c28 <_handle_Privilege_Violation>
	...

80005c2c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR32UC and AVR32AP.
_handle_Floating_Point:
	rjmp $
80005c2c:	c0 08       	rjmp	80005c2c <_handle_Floating_Point>
	...

80005c30 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
	rjmp $
80005c30:	c0 08       	rjmp	80005c30 <_handle_Coprocessor_Absent>
	...

80005c34 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
80005c34:	c0 08       	rjmp	80005c34 <_handle_Data_Address_Read>
	...

80005c38 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
80005c38:	c0 08       	rjmp	80005c38 <_handle_Data_Address_Write>
	...

80005c3c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
80005c3c:	c0 08       	rjmp	80005c3c <_handle_DTLB_Protection_Read>
	...

80005c40 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
80005c40:	c0 08       	rjmp	80005c40 <_handle_DTLB_Protection_Write>
	...

80005c44 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
80005c44:	c0 08       	rjmp	80005c44 <_handle_DTLB_Modified>
	...

80005c50 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
80005c50:	c0 08       	rjmp	80005c50 <_handle_ITLB_Miss>
	...

80005c60 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
80005c60:	c0 08       	rjmp	80005c60 <_handle_DTLB_Miss_Read>
	...

80005c70 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
80005c70:	c0 08       	rjmp	80005c70 <_handle_DTLB_Miss_Write>
	...

80005d00 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	rjmp $
80005d00:	c0 08       	rjmp	80005d00 <_handle_Supervisor_Call>
80005d02:	d7 03       	nop

80005d04 <_int0>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80005d04:	30 0c       	mov	r12,0
80005d06:	fe b0 e7 6b 	rcall	80002bdc <_get_interrupt_handler>
80005d0a:	58 0c       	cp.w	r12,0
80005d0c:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80005d10:	d6 03       	rete

80005d12 <_int1>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80005d12:	30 1c       	mov	r12,1
80005d14:	fe b0 e7 64 	rcall	80002bdc <_get_interrupt_handler>
80005d18:	58 0c       	cp.w	r12,0
80005d1a:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80005d1e:	d6 03       	rete

80005d20 <_int2>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80005d20:	30 2c       	mov	r12,2
80005d22:	fe b0 e7 5d 	rcall	80002bdc <_get_interrupt_handler>
80005d26:	58 0c       	cp.w	r12,0
80005d28:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80005d2c:	d6 03       	rete

80005d2e <_int3>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80005d2e:	30 3c       	mov	r12,3
80005d30:	fe b0 e7 56 	rcall	80002bdc <_get_interrupt_handler>
80005d34:	58 0c       	cp.w	r12,0
80005d36:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80005d3a:	d6 03       	rete
80005d3c:	d7 03       	nop
80005d3e:	d7 03       	nop
80005d40:	d7 03       	nop
80005d42:	d7 03       	nop
80005d44:	d7 03       	nop
80005d46:	d7 03       	nop
80005d48:	d7 03       	nop
80005d4a:	d7 03       	nop
80005d4c:	d7 03       	nop
80005d4e:	d7 03       	nop
80005d50:	d7 03       	nop
80005d52:	d7 03       	nop
80005d54:	d7 03       	nop
80005d56:	d7 03       	nop
80005d58:	d7 03       	nop
80005d5a:	d7 03       	nop
80005d5c:	d7 03       	nop
80005d5e:	d7 03       	nop
80005d60:	d7 03       	nop
80005d62:	d7 03       	nop
80005d64:	d7 03       	nop
80005d66:	d7 03       	nop
80005d68:	d7 03       	nop
80005d6a:	d7 03       	nop
80005d6c:	d7 03       	nop
80005d6e:	d7 03       	nop
80005d70:	d7 03       	nop
80005d72:	d7 03       	nop
80005d74:	d7 03       	nop
80005d76:	d7 03       	nop
80005d78:	d7 03       	nop
80005d7a:	d7 03       	nop
80005d7c:	d7 03       	nop
80005d7e:	d7 03       	nop
80005d80:	d7 03       	nop
80005d82:	d7 03       	nop
80005d84:	d7 03       	nop
80005d86:	d7 03       	nop
80005d88:	d7 03       	nop
80005d8a:	d7 03       	nop
80005d8c:	d7 03       	nop
80005d8e:	d7 03       	nop
80005d90:	d7 03       	nop
80005d92:	d7 03       	nop
80005d94:	d7 03       	nop
80005d96:	d7 03       	nop
80005d98:	d7 03       	nop
80005d9a:	d7 03       	nop
80005d9c:	d7 03       	nop
80005d9e:	d7 03       	nop
80005da0:	d7 03       	nop
80005da2:	d7 03       	nop
80005da4:	d7 03       	nop
80005da6:	d7 03       	nop
80005da8:	d7 03       	nop
80005daa:	d7 03       	nop
80005dac:	d7 03       	nop
80005dae:	d7 03       	nop
80005db0:	d7 03       	nop
80005db2:	d7 03       	nop
80005db4:	d7 03       	nop
80005db6:	d7 03       	nop
80005db8:	d7 03       	nop
80005dba:	d7 03       	nop
80005dbc:	d7 03       	nop
80005dbe:	d7 03       	nop
80005dc0:	d7 03       	nop
80005dc2:	d7 03       	nop
80005dc4:	d7 03       	nop
80005dc6:	d7 03       	nop
80005dc8:	d7 03       	nop
80005dca:	d7 03       	nop
80005dcc:	d7 03       	nop
80005dce:	d7 03       	nop
80005dd0:	d7 03       	nop
80005dd2:	d7 03       	nop
80005dd4:	d7 03       	nop
80005dd6:	d7 03       	nop
80005dd8:	d7 03       	nop
80005dda:	d7 03       	nop
80005ddc:	d7 03       	nop
80005dde:	d7 03       	nop
80005de0:	d7 03       	nop
80005de2:	d7 03       	nop
80005de4:	d7 03       	nop
80005de6:	d7 03       	nop
80005de8:	d7 03       	nop
80005dea:	d7 03       	nop
80005dec:	d7 03       	nop
80005dee:	d7 03       	nop
80005df0:	d7 03       	nop
80005df2:	d7 03       	nop
80005df4:	d7 03       	nop
80005df6:	d7 03       	nop
80005df8:	d7 03       	nop
80005dfa:	d7 03       	nop
80005dfc:	d7 03       	nop
80005dfe:	d7 03       	nop
